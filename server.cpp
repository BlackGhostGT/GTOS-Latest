#include "stdafx.h"
#include <iostream>
#include <sstream>
#include <fstream>
#include "Server_tile.h"
#include <cmath>
#include <string>
#include <vector>
#include <ctime>
#include <time.h>
#include "json.hpp"
#include <thread>
#include <experimental/filesystem>
#include <cstdlib>
#include <cstdio>
#include <cctype>
#include <regex>
#include <cstring>
#include <locale>
#include <stdexcept>
#include "World_events.h"
#ifdef _WIN32
#include <windows.h>
typedef __int8 __int8_t;
typedef __int16 __int16_t;
#elif __APPLE__ || __linux__
typedef unsigned int DWORD;
#endif
typedef unsigned char BYTE;
#define N_DECIMAL_POINTS_PRECISION (1000)
#pragma warning(disable:4996)
#pragma comment(lib,"ws2_32.lib")
int main() {
	ConnectToDatabase();
	if (!Connected) return -1;
	srand(time(nullptr));
	LoadEvents();
	int itemdathash;
	enet_initialize();
	{
		std::ifstream file("items.dat", std::ios::binary | std::ios::ate);
		itemsDatSize = file.tellg();
		itemsDat = new BYTE[60 + itemsDatSize];
		string asdf = "0400000010000000FFFFFFFF000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
		for (auto i = 0; i < asdf.length(); i += 2) {
			char x = ch2n(asdf[i]);
			x = x << 4;
			x += ch2n(asdf[i + 1]);
			memcpy(itemsDat + (i / 2), &x, 1);
			if (asdf.length() > 60 * 2) throw 0;
		}
		memcpy(itemsDat + 56, &itemsDatSize, 4);
		file.seekg(0, std::ios::beg);
		if (file.read(reinterpret_cast<char*>(itemsDat + 60), itemsDatSize)) {
			uint8_t* pData;
			auto size = 0;
			const char filename[] = "items.dat";
			size = filesize(filename);
			pData = getA(static_cast<string>(filename), &size, false, false);
			SendConsole("Updating items data success!", "INFO");
			itemdathash = HashString(static_cast<unsigned char*>(pData), size);
			SendConsole("Items dat hash " + to_string(itemdathash) + "", "INFO");
			file.close();
			serializeItems();
		}
	}
	SendConsole("Items.dat serialized!", "INFO");
	ENetAddress address;
	address.host = ENET_HOST_ANY;
	address.port = 17095; // 17095
	server = enet_host_create(&address, 1024, 2, 0, 0);
	if (server == nullptr) exit(EXIT_FAILURE);
	server->checksum = enet_crc32;
	enet_host_compress_with_range_coder(server);
	buildItemsDatabase();
	//threads.push_back(std::thread(WorldEvents));
	//threads.push_back(std::thread(WorldPhysics));
	//threads.push_back(std::thread(WorldDisasters));
	threads.push_back(std::thread(DayTimer));
	SendConsole("Server is running...", "STARTUP");
	ENetEvent event;
	while (true) { 
		while (enet_host_service(server, &event, 1000) > 0) {
			ENetPeer* peer = event.peer;
			if (peer == NULL || peer == nullptr) {
				cout << "peer was null" << endl;
				continue;
			}
			switch (event.type) {
			case ENET_EVENT_TYPE_CONNECT:
			{
				event.peer->data = new PlayerInfo;
				char clientConnection[16];
				enet_address_get_host_ip(&peer->address, clientConnection, 16);
				static_cast<PlayerInfo*>(peer->data)->charIP = clientConnection;
				sendData(peer, 1, nullptr, 0);
				continue;
			}
			case ENET_EVENT_TYPE_RECEIVE:
			{
				string data = (char*)event.packet->data;
				if (!peer) continue;
				if (static_cast<PlayerInfo*>(peer->data)->currentWorld != "EXIT") {
					const auto info = static_cast<PlayerInfo*>(peer->data);
					const auto netID = info->netID;
					const auto state = getState(info);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
						if (isHere(peer, currentPeer)) {
							if (peer != currentPeer) {
								PlayerMoving data;
								data.packetType = 0x14;
								data.characterState = static_cast<PlayerInfo*>(peer->data)->characterState;
								data.x = 1000;
								data.y = 400;
								data.punchX = 0;
								data.punchY = 0;
								data.XSpeed = 300;
								data.YSpeed = 1000;
								data.netID = netID;
								data.plantingTree = state;
								const auto raw = packPlayerMoving(&data);
								auto var = static_cast<PlayerInfo*>(peer->data)->effect;
								memcpy(raw + 1, &var, 3);
								SendPacketRaw(4, raw, 56, nullptr, currentPeer, ENET_PACKET_FLAG_RELIABLE);
							}
						}
					}
				}
				int messageType = GetMessageTypeFromPacket(event.packet);
				WorldInfo* world = getPlyersWorld(peer);
				switch (messageType) {
				default:
				{
					string cch = GetTextPointerFromPacket(event.packet);
					cout << cch << endl;
                  	if (cch.size() <= 3) break;
					if (cch == "" || cch == " " || cch == "  " || cch == "   " || cch == "    " || cch == "     " || cch == "      " || cch == "       " || cch == "        " || cch == "        ") break;
					if (cch.size() > 2048) break;
					string str = cch.substr(cch.find("text|") + 5, cch.length() - cch.find("text|") - 1);
					if (cch.find("action|world_button\nname|_catselect_") == 0) {
						string worldOffers = "";
						worldOffers = "\nadd_button|Random|_0|0.8|3529161471|\nadd_button|Your Worlds|_16|0.8|3529161471|\nadd_button|Mining|_17|0.8|3529161471|\nadd_button|Adventure|_1|0.8|3529161471|\nadd_button|Art|_2|0.8|3529161471|\nadd_button|Farm|_3|0.8|3529161471|\nadd_button|Game|_4|0.8|3529161471|\nadd_button|Guild|_13|0.8|3529161471|\nadd_button|Information|_5|0.8|3529161471|\nadd_button|Music|_15|0.8|3529161471|\nadd_button|Parkour|_6|0.8|3529161471|\nadd_button|Puzzle|_14|0.8|3529161471|\nadd_button|Roleplay|_7|0.8|3529161471|\nadd_button|Shop|_8|0.8|3529161471|\nadd_button|Social|_9|0.8|3529161471|\nadd_button|Storage|_10|0.8|3529161471|\nadd_button|Story|_11|0.8|3529161471|\nadd_button|Trade|_12|0.8|3529161471|";
						auto p3 = packetEnd(appendString(appendString(createPacket(), "OnRequestWorldSelectMenu"), worldOffers));
						const auto packet3 = enet_packet_create(p3.data, p3.len, ENET_PACKET_FLAG_RELIABLE);
						enet_peer_send(peer, 0, packet3);
						delete p3.data;
					}
					if (cch.find("action|world_button\nname|_0") == 0) {
						sendWorldOffers(peer);
					}
					if (cch.find("action|world_button\nname|_16") == 0) {
						string worldOffers = "\nadd_button|Showing: `wYour Worlds``|_catselect_|0.6|3529161471|\n";
						std::sort(static_cast<PlayerInfo*>(peer->data)->worldsowned.begin(), static_cast<PlayerInfo*>(peer->data)->worldsowned.end());
						auto it = std::unique(static_cast<PlayerInfo*>(peer->data)->worldsowned.begin(), static_cast<PlayerInfo*>(peer->data)->worldsowned.end());
						static_cast<PlayerInfo*>(peer->data)->worldsowned.erase(it, static_cast<PlayerInfo*>(peer->data)->worldsowned.end());
						for (int i = 0; i < static_cast<PlayerInfo*>(peer->data)->worldsowned.size(); i++) {
							worldOffers += "add_floater|" + static_cast<PlayerInfo*>(peer->data)->worldsowned[i] + "|0|0.5|3417414143|\n";
						}
						auto p3 = packetEnd(appendString(appendString(createPacket(), "OnRequestWorldSelectMenu"), worldOffers));
						const auto packet3 = enet_packet_create(p3.data, p3.len, ENET_PACKET_FLAG_RELIABLE);
						enet_peer_send(peer, 0, packet3);
						delete p3.data;
					}
					if (cch.find("action|wrench") == 0) {
						std::stringstream ss(cch);
						std::string to;
						int id = -1;
						while (std::getline(ss, to, '\n')) {
							vector<string> infoDat = explode("|", to);
							if (infoDat[1].size() <= 4 || infoDat[1].size() >= 6)
							{
								//break;
							}
							else if (infoDat[1] != "netid")
							{
								//break;
							}
							else if (infoDat[1] == "netid")
							{
								try
								{
									id = atoi(infoDat[2].c_str());
								}
								catch (...)
								{
								}
							}
						}
						if (id < 0) continue;
						ENetPeer* currentPeer;
						for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
							if (isHere(peer, currentPeer)) {
								if (static_cast<PlayerInfo*>(currentPeer->data)->netID == id) {
									static_cast<PlayerInfo*>(peer->data)->lastInfo = static_cast<PlayerInfo*>(currentPeer->data)->rawName;
									static_cast<PlayerInfo*>(peer->data)->lastInfoname = static_cast<PlayerInfo*>(currentPeer->data)->tankIDName;
									static_cast<PlayerInfo*>(peer->data)->lastDisplayname = static_cast<PlayerInfo*>(currentPeer->data)->displayName;
									string name = static_cast<PlayerInfo*>(currentPeer->data)->displayName;
									string rawnam = static_cast<PlayerInfo*>(peer->data)->rawName;
									string rawnamofwrench = static_cast<PlayerInfo*>(currentPeer->data)->rawName;
									string guildlabel = "";
									string levellabel = "";
									int guildpoints = 0;
									if (static_cast<PlayerInfo*>(currentPeer->data)->guild == "" || isMod(currentPeer) && static_cast<PlayerInfo*>(currentPeer->data)->isNicked == false) {
										guildlabel = "";
									} else {
										guildlabel = "\nadd_dual_layer_icon_label|small|`9Guild: `2" + static_cast<PlayerInfo*>(currentPeer->data)->guild + "``|left|" + std::to_string(static_cast<PlayerInfo*>(currentPeer->data)->guildBg) + "|" + std::to_string(static_cast<PlayerInfo*>(currentPeer->data)->guildFg) + "|1.0|1|\nadd_textbox|`9Rank: `2Member``|left|\nadd_spacer|small|";
									}
									if (isMod(currentPeer) && static_cast<PlayerInfo*>(currentPeer->data)->isNicked == false) {
										levellabel = "?";
									} else {
										levellabel = to_string(static_cast<PlayerInfo*>(currentPeer->data)->level);
									}
									string guilddialog = "\nadd_button|inviteguildbutton|`2Invite to Guild|0|0|";
									if (static_cast<PlayerInfo*>(peer->data)->guild == "") guilddialog = "";
									if (rawnamofwrench != rawnam) {
										if (rawnamofwrench != "") {
											if (!RestrictedArea(peer, world, static_cast<PlayerInfo*>(currentPeer->data)->x / 32, static_cast<PlayerInfo*>(currentPeer->data)->y / 32) && world->owner == "" || world->owner == static_cast<PlayerInfo*>(peer->data)->rawName && static_cast<PlayerInfo*>(peer->data)->haveGrowId || isMod(peer)) {
												if (isMod(peer)) {
													Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`w" + name + " `w(`2" + levellabel + "`w)``|left|18|\nadd_spacer|small|" + guildlabel + "\nadd_button|punishview|`!Punish/View|0|0|\nadd_button|trade|`wTrade``|noflags|0|0|\nadd_textbox|(No Battle Leash equipped)|left|\nadd_textbox|Your opponent needs a valid license to battle!|left|\nadd_button|kick|`4Kick``|noflags|0|0|\nadd_button|pull|`5Pull``|noflags|0|0|\nadd_button|wban|`4World Ban``|noflags|0|0|" + guilddialog + "\nadd_button|addfriendrnbutton|`wAdd as friend``|noflags|0|0|\nadd_button|ignore_player|`wIgnore Player``|noflags|0|0|\nadd_button|report_player|`wReport Player``|noflags|0|0|\nadd_spacer|small|\nend_dialog|popup||Continue|\nadd_quick_exit|");
												} else {
													if (!RestrictedArea(peer, world, static_cast<PlayerInfo*>(currentPeer->data)->x / 32, static_cast<PlayerInfo*>(currentPeer->data)->y / 32) && world->owner == "") {
														Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`w" + name + " `w(`2" + levellabel + "`w)``|left|18|\nadd_spacer|small|" + guildlabel + "\nadd_button|trade|`wTrade``|noflags|0|0|\nadd_textbox|(No Battle Leash equipped)|left|\nadd_textbox|Your opponent needs a valid license to battle!|left|\nadd_button|kick|`4Kick``|noflags|0|0|\nadd_button|pull|`5Pull``|noflags|0|0|" + guilddialog + "\nadd_button|addfriendrnbutton|`wAdd as friend``|noflags|0|0|\nadd_button|ignore_player|`wIgnore Player``|noflags|0|0|\nadd_button|report_player|`wReport Player``|noflags|0|0|\nadd_spacer|small|\nend_dialog|popup||Continue|\nadd_quick_exit|");
													} else {
														Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`w" + name + " `w(`2" + levellabel + "`w)``|left|18|\nadd_spacer|small|" + guildlabel + "\nadd_button|trade|`wTrade``|noflags|0|0|\nadd_textbox|(No Battle Leash equipped)|left|\nadd_textbox|Your opponent needs a valid license to battle!|left|\nadd_button|kick|`4Kick``|noflags|0|0|\nadd_button|pull|`5Pull``|noflags|0|0|\nadd_button|wban|`4World Ban``|noflags|0|0|" + guilddialog + "\nadd_button|addfriendrnbutton|`wAdd as friend``|noflags|0|0|\nadd_button|ignore_player|`wIgnore Player``|noflags|0|0|\nadd_button|report_player|`wReport Player``|noflags|0|0|\nadd_spacer|small|\nend_dialog|popup||Continue|\nadd_quick_exit|");
													}
												}
											} else {
												Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`w" + name + " `w(`2" + levellabel + "`w)``|left|18|\nadd_spacer|small|" + guildlabel + "\nadd_button|trade|`wTrade``|noflags|0|0|\nadd_textbox|(No Battle Leash equipped)|left|\nadd_textbox|Your opponent needs a valid license to battle!|left|" + guilddialog + "\nadd_button|addfriendrnbutton|`wAdd as friend``|noflags|0|0|\nadd_button|ignore_player|`wIgnore Player``|noflags|0|0|\nadd_button|report_player|`wReport Player``|noflags|0|0|\nadd_spacer|small|\nend_dialog|popup||Continue|\nadd_quick_exit|");
											}
										}
									} else {
										if (static_cast<PlayerInfo*>(peer->data)->haveGrowId == true) {
											string buffs;
											if (isPickaxe(peer))
											{
												buffs += "|\nadd_label_with_icon|small|`wEnchanced Digging``|left|" + to_string(static_cast<PlayerInfo*>(peer->data)->cloth_hand) + "|";
											}
											if (static_cast<PlayerInfo*>(peer->data)->GeigerCooldown)
											{
												buffs += "|\nadd_label_with_icon|small|`wIrradiated`` (`w" + OutputBanTime(calcBanDuration(static_cast<PlayerInfo*>(peer->data)->GeigerTime)) + " left`o)|left|2204|";
											}
											if (static_cast<PlayerInfo*>(peer->data)->SurgeryCooldown)
											{
												buffs += "|\nadd_label_with_icon|small|`wMalpractice`` (`w" + OutputBanTime(calcBanDuration(static_cast<PlayerInfo*>(peer->data)->SurgeryTime)) + " left`o)|left|1260|";
											}
											if (static_cast<PlayerInfo*>(peer->data)->Subscriber)
											{
												buffs += "|\nadd_label_with_icon|small|`wPremium Benefits `o(`w" + to_string(static_cast<PlayerInfo*>(peer->data)->SubscribtionEndDay) + " days `oleft)``|left|6862|";
											}
											if (static_cast<PlayerInfo*>(peer->data)->cantsay)
											{
												buffs += "|\nadd_label_with_icon|small|`wDuct tape covered your mouth!``|left|408|";
											}
											if (static_cast<PlayerInfo*>(peer->data)->blueBerry)
											{
												buffs += "|\nadd_label_with_icon|small|`wBlueberry``|left|196|";
											}
											if (static_cast<PlayerInfo*>(peer->data)->LuckyClover || isRedAnces(peer) || FarmingEvent)
											{
												buffs += "|\nadd_label_with_icon|small|`wExtra Gem Drop``|left|528|";
											}
											if (isBlueAnces(peer) || FarmingEvent)
											{
												buffs += "|\nadd_label_with_icon|small|`wExtra Block Drop``|left|2|";
											}
											if (isYellowAnces(peer) || FarmingEvent)
											{
												buffs += "|\nadd_label_with_icon|small|`wExtra XP Buff``|left|1488|";
											}
											if (static_cast<PlayerInfo*>(peer->data)->PunchPotion)
											{
												buffs += "|\nadd_label_with_icon|small|`wOne HIT!``|left|6918|";
											}
											if (static_cast<PlayerInfo*>(peer->data)->PlacePotion)
											{
												buffs += "|\nadd_label_with_icon|small|`wTriple Place!``|left|6924|";
											}
											if (static_cast<PlayerInfo*>(peer->data)->cloth_hand == 6840)
											{
												buffs += "|\nadd_label_with_icon|small|`wHarvester!``|left|" + to_string(static_cast<PlayerInfo*>(peer->data)->cloth_hand) + "|";
											}
											if (static_cast<PlayerInfo*>(peer->data)->cloth_back == 10418 || static_cast<PlayerInfo*>(peer->data)->cloth_back == 10420) {
												buffs += "|\nadd_label_with_icon|small|`wFlying and Double jump``|left|" + to_string(static_cast<PlayerInfo*>(peer->data)->cloth_back) + "|";
											}
											else if (static_cast<PlayerInfo*>(peer->data)->canDoubleJump)
											{
												buffs += "|\nadd_label_with_icon|small|`wDouble jump``|left|" + to_string(static_cast<PlayerInfo*>(peer->data)->cloth_back) + "|";
											}
											if (static_cast<PlayerInfo*>(peer->data)->canWalkInBlocks)
											{
												buffs += "|\nadd_label_with_icon|small|`wI can walk in blocks. (Ghost)``|left|3106|";
											}
											if (static_cast<PlayerInfo*>(peer->data)->isinv)
											{
												buffs += "|\nadd_label_with_icon|small|`wNinja, invisible to all!``|left|290|";
											}
											if (buffs == "")
											{
												buffs += "|\nadd_label_with_icon|small|`wYou don't have any active effects!``|left|18|";
											}
											int levels = static_cast<PlayerInfo*>(peer->data)->level;
											int xp = static_cast<PlayerInfo*>(peer->data)->xp;
											string currentworld = static_cast<PlayerInfo*>(peer->data)->currentWorld;
											int xxx = static_cast<PlayerInfo*>(peer->data)->x / 32;
											int yyy = static_cast<PlayerInfo*>(peer->data)->y / 32;
											string joinguilddialog = "";
											if (static_cast<PlayerInfo*>(peer->data)->isinvited == true)
											{
												joinguilddialog = "\nadd_button|joinguild|`2Join Guild " + static_cast<PlayerInfo*>(peer->data)->guildlast + "!|";
											}
											Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_player_info|" + name + "|" + std::to_string(levels) + "|" + std::to_string(xp) + "|" + to_string(static_cast<PlayerInfo*>(peer->data)->level * 1500) + "|\nadd_spacer|small|" + joinguilddialog + "|\nadd_button|manage_title|`$Title``|\nadd_button|manage_audio|`$Audio``|\nadd_button|notebook_edit|`$Notebook``|\nadd_button|goals|`$Goals & Quests``|noflags|0|0|\nadd_button|worlds_view|`$My Worlds``|\nadd_spacer|small|\nadd_textbox|`wActive effects:``|left|" + buffs + "|\nadd_spacer|small|\nadd_textbox|`oYou have `w" + to_string(static_cast<PlayerInfo*>(peer->data)->currentInventorySize) + "`` `obackpack slots.``|left|\nadd_spacer|small|\nadd_textbox|`oCurrent world: `w" + currentworld + " `o(`w" + std::to_string(xxx) + "`o, `w" + std::to_string(yyy) + "`o)|left|\nadd_spacer|small|\nadd_button|chc0|`wContinue|noflags|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
										}
										else
										{
											SendRegisterDialog(peer);
											enet_host_flush(server);
										}
									}
								}
							}
						}
					}
					if (cch.find("action|setSkin") == 0) {
						if (!world) continue;
						std::stringstream ss(cch);
						std::string to;
						int id = -1;
						string color;
						while (std::getline(ss, to, '\n')) {
							vector<string> infoDat = explode("|", to);
							if (infoDat[0] == "color") color = infoDat[1];
							if (has_only_digits(color) == false) continue;
							id = atoi(color.c_str());
							if (color == "2190853119") id = -2104114177;
							else if (color == "2527912447") id = -1767054849;
							else if (color == "2864971775") id = -1429995521;
							else if (color == "3033464831") id = -1261502465;
							else if (color == "3370516479") id = -924450817;
						}
						static_cast<PlayerInfo*>(peer->data)->skinColor = id;
						sendClothes(peer);
					}
					if (cch.find("action|respawn") == 0) {
						playerRespawn(world, peer, false);
					}
					if (cch.find("action|respawn_spike") == 0) {
						playerRespawn(world, peer, false);
					}
					if (cch.find("action|friends") == 0) {
						string GuildButtonDialog = "";
						if (static_cast<PlayerInfo*>(peer->data)->joinguild == true) {
							GuildButtonDialog = "\nadd_button|showguild|Show Guild Members``";
						} else {
							GuildButtonDialog = "\nadd_button|createguildinfo|Create Guild``";
						}
						Player::OnDialogRequest(peer, "set_default_color|`w\n\nadd_label_with_icon|big|Social Portal``|left|1366|\n\nadd_spacer|small|\nadd_button|showfriend|Show Friends``|0|0|" + GuildButtonDialog + "|0|0|\nend_dialog||OK||\nadd_quick_exit|");
					}
					if (cch.find("action|growid") == 0) {
						SendRegisterDialog(peer);
						enet_host_flush(server);
					}
					if (cch.find("action|eventmenu") == 0) {
						Player::OnTextOverlay(peer, "Events are under development!");
						continue;
						if (static_cast<PlayerInfo*>(peer->data)->haveGrowId == false) {
							SendRegisterDialog(peer);
						} else {
							if (static_cast<PlayerInfo*>(peer->data)->guild == "") {
								Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`9Guild Rewards And Challenges``|left|7340|\nadd_spacer|small|\nadd_textbox|`5Join or Create a `^Guild `5In order to access `cGuild Rewards`5!|\nadd_spacer|small|\nadd_button|cl0se|`wClose|\nadd_quick_exit|");
								continue;
							}
							int gpoints = 0;
							ifstream guildstream1("guildrewards/guildpoints/" + static_cast<PlayerInfo*>(peer->data)->guild + ".txt");
							guildstream1 >> gpoints;
							guildstream1.close();
							int personalpoints = 0;
							ifstream guildstream3("guildrewards/contribution/" + static_cast<PlayerInfo*>(peer->data)->guild + "/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							guildstream3 >> personalpoints;
							guildstream3.close();
							Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`9Guild Rewards And Challenges``|left|7340|\nadd_label|small|`5Your guild currently have: `^" + std::to_string(gpoints) + " `5Points.|left|4||\nadd_label|small|`5Your personal contribution are: `^" + std::to_string(personalpoints) + " `5Points.|left|4||\nadd_spacer|small|\nadd_button|grewards|`wSpend Guild Points``|0|0|\nadd_button|gcontribution|`wMembers Contribution``|0|0|\nadd_spacer|small|\nadd_textbox|`2Guild `^Points `5Are `@Obtainable `5From those `9Activities`5: Usage of `9Magic Machine`5, Breaking `9Farmable Blocks`5, `6Harvesting `9Seeds`5.|\nadd_spacer|small|\nadd_button|cl0se|`wClose|\nadd_quick_exit|");
						}
					}
					if (cch.find("action|buy\nitem|birth_certificate") == 0) {
						/*Fast Item Setup*/
						auto Price = 6000;
						auto ItemID = 1280;
						ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
						auto gembux = atoi(content.c_str());
						if (gembux >= Price) {
							if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							gembux -= Price;
							ofstream myfile;
							myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile << gembux;
							myfile.close();
							Player::OnSetBux(peer, gembux, 0);
							bool success = true;
							SaveItemMoreTimes(ItemID, 1, peer, success, "Purchased from store");
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received: ``" + getItemDef(ItemID).name + ""));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						} else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - gembux) + "`` Gems short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}
					if (cch.find("action|buy\nitem|address_change") == 0) {
						/*Fast Item Setup*/
						auto Price = 6000;
						auto ItemID = 2580;
						ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
						auto gembux = atoi(content.c_str());
						if (gembux >= Price) {
							if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							gembux -= Price;
							ofstream myfile;
							myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile << gembux;
							myfile.close();
							Player::OnSetBux(peer, gembux, 0);
							bool success = true;
							SaveItemMoreTimes(ItemID, 1, peer, success, "Purchased from store");
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received: ``" + getItemDef(ItemID).name + ""));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						} else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - gembux) + "`` Gems short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}
					if (cch.find("action|buy\nitem|vending_machine") == 0) {
						/*Fast Item Setup*/
						auto Price = 1500;
						auto ItemID = 2978;
						ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
						auto gembux = atoi(content.c_str());
						if (gembux >= Price) {
							if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							gembux -= Price;
							ofstream myfile;
							myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile << gembux;
							myfile.close();
							Player::OnSetBux(peer, gembux, 0);
							bool success = true;
							SaveItemMoreTimes(ItemID, 1, peer, success, "Purchased from store");
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received: ``" + getItemDef(ItemID).name + ""));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						} else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - gembux) + "`` Gems short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}
					if (cch.find("action|buy\nitem|grows_spray") == 0) {
						/*Fast Item Setup*/
						auto Price = 200;
						auto ItemID = 228;
						ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
						auto gembux = atoi(content.c_str());
						if (gembux >= Price) {
							if (CheckItemMaxed(peer, ItemID, 5) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 5) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							gembux -= Price;
							ofstream myfile;
							myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile << gembux;
							myfile.close();
							Player::OnSetBux(peer, gembux, 0);
							bool success = true;
							SaveItemMoreTimes(ItemID, 5, peer, success, "Purchased from store");
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o5 " + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received:`` 5 " + getItemDef(ItemID).name + ""));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						} else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o5 " + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - gembux) + "`` Gems short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}
					if (cch.find("action|buy\nitem|deluxe_grow_spray") == 0) {
						/*Fast Item Setup*/
						auto Price = 900;
						auto ItemID = 1778;
						ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
						auto gembux = atoi(content.c_str());
						if (gembux >= Price) {
							if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							gembux -= Price;
							ofstream myfile;
							myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile << gembux;
							myfile.close();
							Player::OnSetBux(peer, gembux, 0);
							bool success = true;
							SaveItemMoreTimes(ItemID, 1, peer, success, "Purchased from store");
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received: ``" + getItemDef(ItemID).name + ""));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						} else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - gembux) + "`` Gems short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}
					if (cch.find("action|buy\nitem|antigravity_generator") == 0) {
						/*Fast Item Setup*/
						auto Price = 50000;
						auto ItemID = 4992;
						ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
						auto gembux = atoi(content.c_str());
						if (gembux >= Price) {
							if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							gembux -= Price;
							ofstream myfile;
							myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile << gembux;
							myfile.close();
							Player::OnSetBux(peer, gembux, 0);
							bool success = true;
							SaveItemMoreTimes(ItemID, 1, peer, success, "Purchased from store");
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received: ``" + getItemDef(ItemID).name + ""));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						} else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - gembux) + "`` Gems short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}
					if (cch.find("action|buy\nitem|zombie_jammer") == 0) {
						/*Fast Item Setup*/
						auto Price = 5000;
						auto ItemID = 1278;
						ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
						auto gembux = atoi(content.c_str());
						if (gembux >= Price) {
							if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							gembux -= Price;
							ofstream myfile;
							myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile << gembux;
							myfile.close();
							Player::OnSetBux(peer, gembux, 0);
							bool success = true;
							SaveItemMoreTimes(ItemID, 1, peer, success, "Purchased from store");
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received: ``" + getItemDef(ItemID).name + ""));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						} else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - gembux) + "`` Gems short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}
			 		if (cch.find("action|buy\nitem|punch_jammer") == 0) {
						/*Fast Item Setup*/
						auto Price = 5000;
						auto ItemID = 1276;
						ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
						auto gembux = atoi(content.c_str());
						if (gembux >= Price) {
							if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							gembux -= Price;
							ofstream myfile;
							myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile << gembux;
							myfile.close();
							Player::OnSetBux(peer, gembux, 0);
							bool success = true;
							SaveItemMoreTimes(ItemID, 1, peer, success, "Purchased from store");
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received: ``" + getItemDef(ItemID).name + ""));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						} else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - gembux) + "`` Gems short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}
					if (cch.find("action|buy\nitem|worker_jammer") == 0) {
						/*Fast Item Setup*/
						auto Price = 12000;
						auto ItemID = 10430;
						ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
						auto gembux = atoi(content.c_str());
						if (gembux >= Price) {
							if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							gembux -= Price;
							ofstream myfile;
							myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile << gembux;
							myfile.close();
							Player::OnSetBux(peer, gembux, 0);
							bool success = true;
							SaveItemMoreTimes(ItemID, 1, peer, success, "Purchased from store");
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received: ``" + getItemDef(ItemID).name + ""));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						} else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - gembux) + "`` Gems short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}
					if (cch.find("action|buy\nitem|gravity_jammer") == 0) {
						/*Fast Item Setup*/
						auto Price = 7000;
						auto ItemID = 10432;
						ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
						auto gembux = atoi(content.c_str());
						if (gembux >= Price) {
							if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							gembux -= Price;
							ofstream myfile;
							myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile << gembux;
							myfile.close();
							Player::OnSetBux(peer, gembux, 0);
							bool success = true;
							SaveItemMoreTimes(ItemID, 1, peer, success, "Purchased from store");
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received: ``" + getItemDef(ItemID).name + ""));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						} else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - gembux) + "`` Gems short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}
					if (cch.find("action|buy\nitem|event_jammer") == 0) {
						/*Fast Item Setup*/
						auto Price = 1000;
						auto ItemID = 10422;
						ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
						auto gembux = atoi(content.c_str());
						if (gembux >= Price) {
							if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							gembux -= Price;
							ofstream myfile;
							myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile << gembux;
							myfile.close();
							Player::OnSetBux(peer, gembux, 0);
							bool success = true;
							SaveItemMoreTimes(ItemID, 1, peer, success, "Purchased from store");
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received: ``" + getItemDef(ItemID).name + ""));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						} else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - gembux) + "`` Gems short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}
					if (cch.find("action|buy\nitem|signal_jammer") == 0) {
						/*Fast Item Setup*/
						auto Price = 2000;
						auto ItemID = 226;
						ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
						auto gembux = atoi(content.c_str());
						if (gembux >= Price) {
							if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							gembux -= Price;
							ofstream myfile;
							myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile << gembux;
							myfile.close();
							Player::OnSetBux(peer, gembux, 0);
							bool success = true;
							SaveItemMoreTimes(ItemID, 1, peer, success, "Purchased from store");
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received: ``" + getItemDef(ItemID).name + ""));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						} else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - gembux) + "`` Gems short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}
					if (cch.find("action|buy\nitem|small_lock") == 0) {
						/*Fast Item Setup*/
						auto Price = 150;
						auto ItemID = 202;
						ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
						auto gembux = atoi(content.c_str());
						if (gembux >= Price) {
							if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							gembux -= Price;
							ofstream myfile;
							myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile << gembux;
							myfile.close();
							Player::OnSetBux(peer, gembux, 0);
							bool success = true;
							SaveItemMoreTimes(ItemID, 1, peer, success, "Purchased from store");
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received: ``" + getItemDef(ItemID).name + ""));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						} else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - gembux) + "`` Gems short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}
					if (cch.find("action|buy\nitem|world_lock") == 0) {
						/*Fast Item Setup*/
						auto Price = 2000;
						auto ItemID = 242;
						ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
						auto gembux = atoi(content.c_str());
						if (gembux >= Price) {
							if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							gembux -= Price;
							ofstream myfile;
							myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile << gembux;
							myfile.close();
							Player::OnSetBux(peer, gembux, 0);
							bool success = true;
							SaveItemMoreTimes(ItemID, 1, peer, success, "Purchased from store");
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received: ``" + getItemDef(ItemID).name + ""));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						} else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - gembux) + "`` Gems short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}
					if (cch.find("action|buy\nitem|upgrade_backpack") == 0) {
						/*Fast Item Setup*/
						auto Price = 10000;
						ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
						auto gembux = atoi(content.c_str());
						if (gembux >= Price) {
							if (static_cast<PlayerInfo*>(peer->data)->currentInventorySize >= 200) continue;
							gembux -= Price;
							ofstream myfile;
							myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile << gembux;
							myfile.close();
							Player::OnSetBux(peer, gembux, 0);
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							short nextSpace = 0;
							if (static_cast<PlayerInfo*>(peer->data)->currentInventorySize + 10 > 200) {
								nextSpace = 200;
							} else {
								nextSpace = static_cast<PlayerInfo*>(peer->data)->currentInventorySize + 10;
							}
							string q = "UPDATE PlayerDatabase SET inventorysize = '" + to_string(nextSpace) + "' WHERE username = '" + static_cast<PlayerInfo*>(peer->data)->rawName + "' LIMIT 1";
							if (mysql_query(conn, q.c_str())) {
								cout << mysql_error(conn) << endl;							
								enet_peer_disconnect_later(peer, 0);
								continue;
							}
							static_cast<PlayerInfo*>(peer->data)->currentInventorySize += 10;
							SendInventory(peer, static_cast<PlayerInfo*>(peer->data)->inventory);
							const auto p3 = packetEnd(appendFloat(appendIntx(appendFloat(appendFloat(appendFloat(appendString(createPacket(), "OnSetClothing"), (static_cast<PlayerInfo*>(peer->data))->cloth_hair, (static_cast<PlayerInfo*>(peer->data))->cloth_shirt, (static_cast<PlayerInfo*>(peer->data))->cloth_pants), (static_cast<PlayerInfo*>(peer->data))->cloth_feet, (static_cast<PlayerInfo*>(peer->data))->cloth_face, (static_cast<PlayerInfo*>(peer->data))->cloth_hand), (static_cast<PlayerInfo*>(peer->data))->cloth_back, (static_cast<PlayerInfo*>(peer->data))->cloth_mask, (static_cast<PlayerInfo*>(peer->data))->cloth_necklace), (static_cast<PlayerInfo*>(peer->data))->skinColor), (static_cast<PlayerInfo*>(peer->data))->cloth_ances, 0.0f, 0.0f));
							memcpy(p3.data + 8, &((static_cast<PlayerInfo*>(peer->data))->netID), 4);
							const auto packet = enet_packet_create(p3.data, p3.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `0Upgrade Backpack`` (`w10 Slots``) `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received: ``Backpack Upgrade"));
							ENetPacket* packets = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packets);
							delete p.data;
						} else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `0Upgrade Backpack`` (`w10 Slots``)``!  You're `$" + to_string(Price - gembux) + "`` Gems short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}
					if (cch.find("action|buy\nitem|locks") == 0 || cch.find("action|storenavigate\nitem|locks\nselection|upgrade_backpack") == 0) {
						string UpgradeInventoryDialog = "";
						if (static_cast<PlayerInfo*>(peer->data)->currentInventorySize <= 190) {
							UpgradeInventoryDialog = "\nadd_button|upgrade_backpack|`0Upgrade Backpack`` (`w10 Slots``)``|interface/large/store_buttons.rttex|`2You Get:`` 10 Additional Backpack Slots.<CR><CR>`5Description:`` Sewing an extra pocket onto your backpack will allow you to store `$10`` additional item types.  How else are you going to fit all those toilets and doors?|0|1|10000|0||";
						}
						GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStoreRequest"), "set_description_text|`2Locks And Stuff!``  Select the item you'd like more info on, or BACK to go back.|\nadd_button|world_lock|`oWorld Lock``|interface/large/store_buttons.rttex|`2You Get:`` 1 World Lock.<CR><CR>`5Description:`` Become the undisputed ruler of your domain with one of these babies.  It works like a normal lock except it locks the `$entire world``!  Won't work on worlds that other people already have locks on. You can even add additional normal locks to give access to certain areas to friends. `5It's a perma-item, is never lost when destroyed.``  `wRecycles for 200 Gems.``|0|7|2000|0||\nadd_button|small_lock|`oSmall Lock``|interface/large/store_buttons.rttex|`2You Get:`` 1 Small Lock.<CR><CR>`5Description:`` Protect up to `$10`` tiles.  Can add friends to the lock so others can edit that area as well. `5It's a perma-item, is never lost when destroyed.``|1|3|150|0||" + UpgradeInventoryDialog + "\nadd_button|vending_machine|`oVending Machine``|interface/large/store_buttons13.rttex|`2You Get:`` 1 Vending Machine.<CR><CR>`5Description:`` Tired of interacting with human beings? Try a Vending Machine! You can put a stack of items inside it, set a price in World Locks, and people can buy from the machine while you sit back and rake in the profits! `5It's a perma-item, is never lost when destroyed, and it is not available any other way.``|0|6|1500|0||\nadd_button|grows_spray|`o5-pack of Grow Spray Fertilizer``|interface/large/store_buttons.rttex|`2You Get:`` 5 Grow Spray Fertilizers.<CR><CR>`5Description:`` Why wait?!  Treat yourself to a `$5-pack`` of amazing `wGrow Spray Fertilizer`` by GrowTech Corp.  Each bottle instantly ages a tree by `$1 hour``.|0|6|200|0||\nadd_button|deluxe_grow_spray|`oDeluxe Grow Spray``|interface/large/store_buttons11.rttex|`2You Get:`` 1 Deluxe Grow Spray.<CR><CR>`5Description:`` GrowTech's new `$Deluxe`` `wGrow Spray`` instantly ages a tree by `$24 hours`` per bottle! That's somewhere around 25 times as much as regular Grow Spray!|0|2|900|0||\nadd_button|signal_jammer|`oSignal Jammer``|interface/large/store_buttons.rttex|`2You Get:`` 1 Signal Jammer.<CR><CR>`5Description:`` Get off the grid! Install a `$Signal Jammer``! A single punch will cause it to whir to life, tireless hiding your world and its population from pesky snoopers - only those who know the world name will be able to enter. `5It's a perma-item, is never lost when destroyed.``|1|6|2000|0||\nadd_button|punch_jammer|`oPunch Jammer``|interface/large/store_buttons7.rttex|`2You Get:`` 1 Punch Jammer.<CR><CR>`5Description:`` Tired of getting bashed around? Set up a Punch Jammer in your world, and people won't be able to punch each other! Can be turned on and off as needed. `5It's a perma-item, is never lost when destroyed.``|0|4|5000|0||\nadd_button|zombie_jammer|`oZombie Jammer``|interface/large/store_buttons7.rttex|`2You Get:`` 1 Zombie Jammer.<CR><CR>`5Description:`` Got a parkour or race that you don't want slowed down? Turn this on and nobody can be infected by zombie bites in your world. It does not prevent direct infection by the g-Virus itself though. `5It's a perma-item, is never lost when destroyed.``|0|5|5000|0||\nadd_button|gravity_jammer|`oGravity Jammer``|interface/large/store_buttons_iotm.rttex|`2You Get:`` 1 Gravity Jammer.<CR><CR>`5Description:`` Ever wanted to experience something next level? This jammer allows you to simulate physics in your world, they will no longer float in the sky. `5It's a perma-item, is never lost when destroyed.``|0|3|7000|0||\nadd_button|event_jammer|`oEvent Jammer``|interface/large/store_buttons_iotm.rttex|`2You Get:`` 1 Event Jammer.<CR><CR>`5Description:`` Tired of disasters in your world? You should definitely install a `$Event Jammer`` which will prevent disasters happening in your world. `5It's a perma-item, is never lost when destroyed.``|0|2|1000|0||\nadd_button|worker_jammer|`oWorker Jammer``|interface/large/store_buttons_magplants.rttex|`2You Get:`` 1 Worker Jammer.<CR><CR>`5Description:`` This awesome jammer will make your world always active when activated, that means even if you will leave your world special events and all other your world processes will remain going! Useful for making auto farm `5It's a perma-item, is never lost when destroyed.``|0|5|12000|0||\nadd_button|antigravity_generator|`oAntigravity Generator``|interface/large/store_buttons17.rttex|`2You Get:`` 1 Antigravity Generator.<CR><CR>`5Description:`` Disables gravity in your world when activated! Well, it reduces gravity, and lets everybody jump as much as they want! `5It's a perma-item - never lost when destroyed! `4Not available any other way!````|0|3|50000|0||\nadd_button|address_change|`oChange Of Address``|interface/large/store_buttons12.rttex|`2You Get:`` 1 Change Of Address.<CR><CR>`5Description:`` Don't like the name of your world? You can use up one of these to trade your world's name with the name of any other world that you own. You must have a `2World Lock`` in both worlds. Go lock up that empty world with the new name you want and swap away!|0|6|6000|0||\nadd_button|birth_certificate|`oBirth Certificate``|interface/large/store_buttons7.rttex|`2You Get:`` 1 Birth Certificate.<CR><CR>`5Description:`` Tired of being who you are? By forging a new birth certificate, you can change your GrowID! The Birth Certificate will be consumed when used. This item only works if you have a GrowID, and you can only use one every 60 days, so you're not confusing everybody.|0|6|6000|0||\n"));
						ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
						enet_peer_send(peer, 0, packet);
						delete p.data;
					}
					if (cch.find("action|buy\nitem|farmable") == 0) {
						GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStoreRequest"), "set_description_text|`2Farmables!``  All of these awesome blocks and diamonds have ability to spread by theirself, all you have to do place them in your world and wait. Select the item you'd like more info on, or BACK to go back.|\nadd_button|amethyst_block|`oAmethyst Block``|interface/large/store_buttons_farmable.rttex|`2You Get:`` 1 Amethyst Block.<CR><CR>`5Description:`` If you are newbie to GTOS, this choice is perfect for you! Amethyst Blocks will give you up to `$10 ``gems, and a tiny amount of experience.|0|5|15000|0||\nadd_button|onyx_block|`oOnyx Block``|interface/large/store_buttons_farmable.rttex|`2You Get:`` 1 Onyx Block.<CR><CR>`5Description:`` A slightly better choice than `$Amethyst blocks``, Onyx blocks give you up to `$20 ``gems``.|0|7|30000|0||\nadd_button|smaraged_block|`oSmaraged Block``|interface/large/store_buttons_farmable.rttex|`2You Get:`` 1 Smaraged Block.<CR><CR>`5Description:`` Smaraged blocks will definitely lead you to rich future! Those blocks gives you up to `$30 ``gems, and also a chance to obtain `#Rare Emerald Shard``.|0|6|50000|0||\nadd_button|diamond_stone|`oDiamond Stone``|interface/large/store_buttons_farmable.rttex|`2You Get:`` 1 Diamond Stone.<CR><CR>`5Description:`` A heavy and strong diamond, can give you even up to `$40 ``gems, and moderate amount of experience``.|0|4|90000|0||\nadd_button|pink_diamond|`oPink Diamond``|interface/large/store_buttons_farmable.rttex|`2You Get:`` 1 Pink Diamond.<CR><CR>`5Description:`` You have to be rich if you're farming this kind of blocks! Pink diamond can give you even up to `$50 ``gems, and a chance to obtain `#Rare Ruby Shard``.|0|3|200000|0||\nadd_button|citrine_block|`oCitrine Block``|interface/large/store_buttons_farmable.rttex|`2You Get:`` 1 Citrine Block.<CR><CR>`5Description:`` Shiny and expensive! Can give you up to `$60 ``gems``.|0|2|300000|0||\n"));
						ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
						enet_peer_send(peer, 0, packet);
						delete p.data;
					}
					if (cch.find("action|buy\nitem|burrito_farmable") == 0) {
						/*Fast Item Setup*/
						auto Price = 60000;
						auto ItemID = 10392;
						auto count = 1;
						ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
						auto gembux = atoi(content.c_str());
						if (gembux >= Price) {
							if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							gembux -= Price;
							ofstream myfile;
							myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile << gembux;
							myfile.close();
							Player::OnSetBux(peer, gembux, 0);
							bool success = true;
							SaveItemMoreTimes(ItemID, count, peer, success, "Purchased from store");
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received: ``" + to_string(count) + " " + getItemDef(ItemID).name + ""));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						} else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - gembux) + "`` Gems short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}
					if (cch.find("action|buy\nitem|citrine_block") == 0) {
						/*Fast Item Setup*/
						auto Price = 300000;
						auto ItemID = 10028;
						auto count = 1;
						ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
						auto gembux = atoi(content.c_str());
						if (gembux >= Price) {
							if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							gembux -= Price;
							ofstream myfile;
							myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile << gembux;
							myfile.close();
							Player::OnSetBux(peer, gembux, 0);
							bool success = true;
							SaveItemMoreTimes(ItemID, count, peer, success, "Purchased from store");
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received: ``" + to_string(count) + " " + getItemDef(ItemID).name + ""));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						} else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - gembux) + "`` Gems short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}
					if (cch.find("action|buy\nitem|pink_diamond") == 0) {
						/*Fast Item Setup*/
						auto Price = 200000;
						auto ItemID = 10024;
						auto count = 1;
						ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
						auto gembux = atoi(content.c_str());
						if (gembux >= Price) {
							if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							gembux -= Price;
							ofstream myfile;
							myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile << gembux;
							myfile.close();
							Player::OnSetBux(peer, gembux, 0);
							bool success = true;
							SaveItemMoreTimes(ItemID, count, peer, success, "Purchased from store");
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received: ``" + to_string(count) + " " + getItemDef(ItemID).name + ""));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						} else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - gembux) + "`` Gems short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}
					if (cch.find("action|buy\nitem|diamond_stone") == 0) {
						/*Fast Item Setup*/
						auto Price = 90000;
						auto ItemID = 9468;
						auto count = 1;
						ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
						auto gembux = atoi(content.c_str());
						if (gembux >= Price) {
							if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							gembux -= Price;
							ofstream myfile;
							myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile << gembux;
							myfile.close();
							Player::OnSetBux(peer, gembux, 0);
							bool success = true;
							SaveItemMoreTimes(ItemID, count, peer, success, "Purchased from store");
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received: ``" + to_string(count) + " " + getItemDef(ItemID).name + ""));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						} else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - gembux) + "`` Gems short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}
					if (cch.find("action|buy\nitem|smaraged_block") == 0) {
						/*Fast Item Setup*/
						auto Price = 50000;
						auto ItemID = 9460;
						auto count = 1;
						ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
						auto gembux = atoi(content.c_str());
						if (gembux >= Price) {
							if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							gembux -= Price;
							ofstream myfile;
							myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile << gembux;
							myfile.close();
							Player::OnSetBux(peer, gembux, 0);
							bool success = true;
							SaveItemMoreTimes(ItemID, count, peer, success, "Purchased from store");
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received: ``" + to_string(count) + " " + getItemDef(ItemID).name + ""));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						} else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - gembux) + "`` Gems short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}
					if (cch.find("action|buy\nitem|onyx_block") == 0) {
						/*Fast Item Setup*/
						auto Price = 30000;
						auto ItemID = 7382;
						auto count = 1;
						ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
						auto gembux = atoi(content.c_str());
						if (gembux >= Price) {
							if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							gembux -= Price;
							ofstream myfile;
							myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile << gembux;
							myfile.close();
							Player::OnSetBux(peer, gembux, 0);
							bool success = true;
							SaveItemMoreTimes(ItemID, count, peer, success, "Purchased from store");
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received: ``" + to_string(count) + " " + getItemDef(ItemID).name + ""));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						} else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - gembux) + "`` Gems short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}
					if (cch.find("action|buy\nitem|amethyst_block") == 0) {
						/*Fast Item Setup*/
						auto Price = 15000;
						auto ItemID = 4762;
						auto count = 1;
						ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
						auto gembux = atoi(content.c_str());
						if (gembux >= Price) {
							if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							gembux -= Price;
							ofstream myfile;
							myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile << gembux;
							myfile.close();
							Player::OnSetBux(peer, gembux, 0);
							bool success = true;
							SaveItemMoreTimes(ItemID, count, peer, success, "Purchased from store");
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received: ``" + to_string(count) + " " + getItemDef(ItemID).name + ""));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						} else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - gembux) + "`` Gems short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}

					if (cch.find("action|buy\nitem|paintbrush") == 0) {
						ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
						auto gembux = atoi(content.c_str());
						if (gembux >= 30000) {
							if (CheckItemMaxed(peer, 3494, 1) || CheckItemMaxed(peer, 3478, 5) || CheckItemMaxed(peer, 3480, 5) || CheckItemMaxed(peer, 3482, 5) || CheckItemMaxed(peer, 3484, 5) || CheckItemMaxed(peer, 3486, 5) || CheckItemMaxed(peer, 3488, 5) || CheckItemMaxed(peer, 3490, 5) || CheckItemMaxed(peer, 3492, 5) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 9 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							gembux -= 30000;
							ofstream myfile;
							myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile << gembux;
							myfile.close();
							Player::OnSetBux(peer, gembux, 0);
							bool success = true;
							SaveItemMoreTimes(3494, 1, peer, success, "Purchased from store");
							SaveItemMoreTimes(3478, 5, peer, success, "Purchased from store");
							SaveItemMoreTimes(3480, 5, peer, success, "Purchased from store");
							SaveItemMoreTimes(3482, 5, peer, success, "Purchased from store");
							SaveItemMoreTimes(3484, 5, peer, success, "Purchased from store");
							SaveItemMoreTimes(3486, 5, peer, success, "Purchased from store");
							SaveItemMoreTimes(3488, 5, peer, success, "Purchased from store");
							SaveItemMoreTimes(3490, 5, peer, success, "Purchased from store");
							SaveItemMoreTimes(3492, 5, peer, success, "Purchased from store");
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `oPainter's Pack `wfor `$" + to_string(30000) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received: ``Paintbrush`$,`` 5 Paint Bucket - Yellow`$,`` 5 Paint Bucket - Green`$,`` 5 Paint Bucket - Blue`$,`` 5 Paint Bucket - Varnish`$,`` 5 Paint Bucket - Red`$,`` 5 Paint Bucket - Charcoal`$,`` 5 Paint Bucket - Purple`$,`` 5 Paint Bucket - Aqua\n"));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						} else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `oPainter's Pack``!  You're `$" + to_string(30000 - gembux) + "`` Gems short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}

					if (cch.find("action|buy\nitem|vegas_pack") == 0) {
						ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
						auto gembux = atoi(content.c_str());
						if (gembux >= 20000) {
							if (CheckItemMaxed(peer, 740, 10) || CheckItemMaxed(peer, 744, 1) || CheckItemMaxed(peer, 1582, 1) || CheckItemMaxed(peer, 752, 4) || CheckItemMaxed(peer, 456, 1) || CheckItemMaxed(peer, 754, 1) || CheckItemMaxed(peer, 756, 1) || CheckItemMaxed(peer, 758, 1) || CheckItemMaxed(peer, 794, 1) || CheckItemMaxed(peer, 796, 1) || CheckItemMaxed(peer, 798, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 11 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							gembux -= 20000;
							ofstream myfile;
							myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile << gembux;
							myfile.close();
							Player::OnSetBux(peer, gembux, 0);
							bool success = true;
							SaveItemMoreTimes(740, 10, peer, success, "Purchased from store");
							SaveItemMoreTimes(744, 1, peer, success, "Purchased from store");
							SaveItemMoreTimes(1582, 1, peer, success, "Purchased from store");
							SaveItemMoreTimes(752, 4, peer, success, "Purchased from store");
							SaveItemMoreTimes(456, 1, peer, success, "Purchased from store");
							SaveItemMoreTimes(754, 1, peer, success, "Purchased from store");
							SaveItemMoreTimes(756, 1, peer, success, "Purchased from store");
							SaveItemMoreTimes(758, 1, peer, success, "Purchased from store");
							SaveItemMoreTimes(794, 1, peer, success, "Purchased from store");
							SaveItemMoreTimes(796, 1, peer, success, "Purchased from store");
							SaveItemMoreTimes(798, 1, peer, success, "Purchased from store");
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `oVegas Pack `wfor `$" + to_string(20000) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received: ``10 Neon Lights`$,`` Card Block Seed`$,`` Pink Cadillac`$,`` 4 Flipping Coin`$,`` Dice Block`$,`` Gambler's Visor`$,`` Slot Machine`$,`` Roulette Wheel`$,`` Showgirl Headdress`$,`` Showgirl Top`$,`` Showgirl Leggings\n"));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						} else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `oVegas Pack``!  You're `$" + to_string(20000 - gembux) + "`` Gems short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}

					if (cch.find("action|buy\nitem|razorwings") == 0) {
						/*Fast Item Setup*/
						auto Price = 15000;
						auto ItemID = 4534;
						auto count = 1;
						ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
						auto gembux = atoi(content.c_str());
						if (gembux >= Price) {
							if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							gembux -= Price;
							ofstream myfile;
							myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile << gembux;
							myfile.close();
							Player::OnSetBux(peer, gembux, 0);
							bool success = true;
							SaveItemMoreTimes(ItemID, count, peer, success, "Purchased from store");
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received: ``" + to_string(count) + " " + getItemDef(ItemID).name + ""));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						} else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - gembux) + "`` Gems short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}

					if (cch.find("action|buy\nitem|raymanfist") == 0) {
						/*Fast Item Setup*/
						auto Price = 200000;
						auto ItemID = 5480;
						auto count = 1;
						ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
						auto gembux = atoi(content.c_str());
						if (gembux >= Price) {
							if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							gembux -= Price;
							ofstream myfile;
							myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile << gembux;
							myfile.close();
							Player::OnSetBux(peer, gembux, 0);
							bool success = true;
							SaveItemMoreTimes(ItemID, count, peer, success, "Purchased from store");
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received: ``" + to_string(count) + " " + getItemDef(ItemID).name + ""));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						} else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - gembux) + "`` Gems short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}

					if (cch.find("action|buy\nitem|organic") == 0) {
						/*Fast Item Setup*/
						auto Price = 90000;
						auto ItemID = 6954;
						auto count = 1;
						ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
						auto gembux = atoi(content.c_str());
						if (gembux >= Price) {
							if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							gembux -= Price;
							ofstream myfile;
							myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile << gembux;
							myfile.close();
							Player::OnSetBux(peer, gembux, 0);
							bool success = true;
							SaveItemMoreTimes(ItemID, count, peer, success, "Purchased from store");
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received: ``" + to_string(count) + " " + getItemDef(ItemID).name + ""));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						} else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - gembux) + "`` Gems short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}

					if (cch.find("action|buy\nitem|gaiabeacon") == 0) {
						/*Fast Item Setup*/
						auto Price = 100000;
						auto ItemID = 6946;
						auto count = 1;
						ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
						auto gembux = atoi(content.c_str());
						if (gembux >= Price) {
							if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							gembux -= Price;
							ofstream myfile;
							myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile << gembux;
							myfile.close();
							Player::OnSetBux(peer, gembux, 0);
							bool success = true;
							SaveItemMoreTimes(ItemID, count, peer, success, "Purchased from store");
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received: ``" + to_string(count) + " " + getItemDef(ItemID).name + ""));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						} else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - gembux) + "`` Gems short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}

					if (cch.find("action|buy\nitem|manipulator") == 0) {
						/*Fast Item Setup*/
						auto Price = 60000;
						auto ItemID = 6952;
						auto count = 1;
						ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
						auto gembux = atoi(content.c_str());
						if (gembux >= Price) {
							if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							gembux -= Price;
							ofstream myfile;
							myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile << gembux;
							myfile.close();
							Player::OnSetBux(peer, gembux, 0);
							bool success = true;
							SaveItemMoreTimes(ItemID, count, peer, success, "Purchased from store");
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received: ``" + to_string(count) + " " + getItemDef(ItemID).name + ""));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						} else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - gembux) + "`` Gems short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}

					if (cch.find("action|buy\nitem|unstabletesseract") == 0) {
						/*Fast Item Setup*/
						auto Price = 50000;
						auto ItemID = 6948;
						auto count = 1;
						ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
						auto gembux = atoi(content.c_str());
						if (gembux >= Price) {
							if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							gembux -= Price;
							ofstream myfile;
							myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile << gembux;
							myfile.close();
							Player::OnSetBux(peer, gembux, 0);
							bool success = true;
							SaveItemMoreTimes(ItemID, count, peer, success, "Purchased from store");
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received: ``" + to_string(count) + " " + getItemDef(ItemID).name + ""));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						} else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - gembux) + "`` Gems short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}
					
					if (cch.find("action|buy\nitem|magplant5000") == 0) {
						/*Fast Item Setup*/
						auto Price = 150000;
						auto ItemID = 5638;
						auto count = 1;
						ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
						auto gembux = atoi(content.c_str());
						if (gembux >= Price) {
							if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							gembux -= Price;
							ofstream myfile;
							myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile << gembux;
							myfile.close();
							Player::OnSetBux(peer, gembux, 0);
							bool success = true;
							SaveItemMoreTimes(ItemID, count, peer, success, "Purchased from store");
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received: ``" + to_string(count) + " " + getItemDef(ItemID).name + ""));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						} else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - gembux) + "`` Gems short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}

					if (cch.find("action|buy\nitem|tinyblast") == 0) {
						/*Fast Item Setup*/
						auto Price = 1000;
						auto ItemID = 10434;
						auto count = 1;
						ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
						auto gembux = atoi(content.c_str());
						if (gembux >= Price) {
							if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							gembux -= Price;
							ofstream myfile;
							myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile << gembux;
							myfile.close();
							Player::OnSetBux(peer, gembux, 0);
							bool success = true;
							SaveItemMoreTimes(ItemID, count, peer, success, "Purchased from store");
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received: ``" + to_string(count) + " " + getItemDef(ItemID).name + ""));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						} else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - gembux) + "`` Gems short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}

					if (cch.find("action|buy\nitem|largeblast") == 0) {
						/*Fast Item Setup*/
						auto Price = 1000;
						auto ItemID = 10428;
						auto count = 1;
						ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
						auto gembux = atoi(content.c_str());
						if (gembux >= Price) {
							if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							gembux -= Price;
							ofstream myfile;
							myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile << gembux;
							myfile.close();
							Player::OnSetBux(peer, gembux, 0);
							bool success = true;
							SaveItemMoreTimes(ItemID, count, peer, success, "Purchased from store");
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received: ``" + to_string(count) + " " + getItemDef(ItemID).name + ""));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						} else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - gembux) + "`` Gems short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}

					if (cch.find("action|buy\nitem|thermo_blast") == 0) {
						/*Fast Item Setup*/
						auto Price = 3000;
						auto ItemID = 1402;
						auto count = 1;
						ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
						auto gembux = atoi(content.c_str());
						if (gembux >= Price) {
							if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							gembux -= Price;
							ofstream myfile;
							myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile << gembux;
							myfile.close();
							Player::OnSetBux(peer, gembux, 0);
							bool success = true;
							SaveItemMoreTimes(ItemID, count, peer, success, "Purchased from store");
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received: ``" + to_string(count) + " " + getItemDef(ItemID).name + ""));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						} else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - gembux) + "`` Gems short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}

					if (cch.find("action|buy\nitem|seil_magic_orb") == 0) {
						/*Fast Item Setup*/
						auto Price = 15;
						auto ItemID = 820;
						auto count = 1;
						auto contains = false;
						auto KiekTuri = 0;
						for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++) {
							if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 1486 && static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount >= 1) {
								KiekTuri = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
							}
						}
						SearchInventoryItem(peer, 1486, Price, contains);
						if (contains) {
							if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							RemoveInventoryItem(1486, Price, peer, true);			
							bool success = true;
							SaveItemMoreTimes(ItemID, count, peer, success, "Purchased from store");
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(KiekTuri - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + getItemDef(ItemID).name + ""));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						} else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - KiekTuri) + "`` Growtokens short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}

					if (cch.find("action|buy\nitem|atomi_shadow_scythe") == 0) {
						/*Fast Item Setup*/
						auto Price = 10;
						auto ItemID = 1484;
						auto count = 1;
						auto contains = false;
						auto KiekTuri = 0;
						for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++) {
							if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 1486 && static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount >= 1) {
								KiekTuri = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
							}
						}
						SearchInventoryItem(peer, 1486, Price, contains);
						if (contains) {
							if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							RemoveInventoryItem(1486, Price, peer, true);			
							bool success = true;
							SaveItemMoreTimes(ItemID, count, peer, success, "Purchased from store");
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(KiekTuri - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + getItemDef(ItemID).name + ""));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						} else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - KiekTuri) + "`` Growtokens short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}

					if (cch.find("action|buy\nitem|evil_space_helmet") == 0) {
						/*Fast Item Setup*/
						auto Price = 5;
						auto ItemID = 1440;
						auto count = 1;
						auto contains = false;
						auto KiekTuri = 0;
						for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++) {
							if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 1486 && static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount >= 1) {
								KiekTuri = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
							}
						}
						SearchInventoryItem(peer, 1486, Price, contains);
						if (contains) {
							if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							RemoveInventoryItem(1486, Price, peer, true);			
							bool success = true;
							SaveItemMoreTimes(ItemID, count, peer, success, "Purchased from store");
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(KiekTuri - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + getItemDef(ItemID).name + ""));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						} else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - KiekTuri) + "`` Growtokens short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}

					if (cch.find("action|buy\nitem|frosty_hair") == 0) {
						/*Fast Item Setup*/
						auto Price = 10;
						auto ItemID = 1444;
						auto count = 1;
						auto contains = false;
						auto KiekTuri = 0;
						for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++) {
							if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 1486 && static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount >= 1) {
								KiekTuri = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
							}
						}
						SearchInventoryItem(peer, 1486, Price, contains);
						if (contains) {
							if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							RemoveInventoryItem(1486, Price, peer, true);			
							bool success = true;
							SaveItemMoreTimes(ItemID, count, peer, success, "Purchased from store");
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(KiekTuri - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + getItemDef(ItemID).name + ""));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						} else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - KiekTuri) + "`` Growtokens short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}

					if (cch.find("action|buy\nitem|meow_ears") == 0) {
						/*Fast Item Setup*/
						auto Price = 5;
						auto ItemID = 698;
						auto count = 1;
						auto contains = false;
						auto KiekTuri = 0;
						for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++) {
							if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 1486 && static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount >= 1) {
								KiekTuri = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
							}
						}
						SearchInventoryItem(peer, 1486, Price, contains);
						if (contains) {
							if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							RemoveInventoryItem(1486, Price, peer, true);			
							bool success = true;
							SaveItemMoreTimes(ItemID, count, peer, success, "Purchased from store");
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(KiekTuri - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + getItemDef(ItemID).name + ""));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						} else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - KiekTuri) + "`` Growtokens short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}

					if (cch.find("action|buy\nitem|puppy_leash") == 0) {
						/*Fast Item Setup*/
						auto Price = 5;
						auto ItemID = 1742;
						auto count = 1;
						auto contains = false;
						auto KiekTuri = 0;
						for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++) {
							if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 1486 && static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount >= 1) {
								KiekTuri = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
							}
						}
						SearchInventoryItem(peer, 1486, Price, contains);
						if (contains) {
							if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							RemoveInventoryItem(1486, Price, peer, true);			
							bool success = true;
							SaveItemMoreTimes(ItemID, count, peer, success, "Purchased from store");
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(KiekTuri - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + getItemDef(ItemID).name + ""));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						} else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - KiekTuri) + "`` Growtokens short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}

					if (cch.find("action|buy\nitem|golden_pickaxe") == 0) {
						/*Fast Item Setup*/
						auto Price = 15;
						auto ItemID = 1438;
						auto count = 1;
						auto contains = false;
						auto KiekTuri = 0;
						for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++) {
							if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 1486 && static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount >= 1) {
								KiekTuri = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
							}
						}
						SearchInventoryItem(peer, 1486, Price, contains);
						if (contains) {
							if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							RemoveInventoryItem(1486, Price, peer, true);			
							bool success = true;
							SaveItemMoreTimes(ItemID, count, peer, success, "Purchased from store");
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(KiekTuri - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + getItemDef(ItemID).name + ""));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						} else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - KiekTuri) + "`` Growtokens short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}

					if (cch.find("action|buy\nitem|cat_eyes") == 0) {
						/*Fast Item Setup*/
						auto Price = 1;
						auto ItemID = 7106;
						auto count = 1;
						auto contains = false;
						auto KiekTuri = 0;
						for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++) {
							if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 1486 && static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount >= 1) {
								KiekTuri = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
							}
						}
						SearchInventoryItem(peer, 1486, Price, contains);
						if (contains) {
							if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							RemoveInventoryItem(1486, Price, peer, true);			
							bool success = true;
							SaveItemMoreTimes(ItemID, count, peer, success, "Purchased from store");
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(KiekTuri - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + getItemDef(ItemID).name + ""));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						} else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - KiekTuri) + "`` Growtokens short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}
					
					if (cch.find("action|buy\nitem|focused_eyes") == 0) {
						/*Fast Item Setup*/
						auto Price = 10;
						auto ItemID = 1204;
						auto count = 1;
						auto contains = false;
						auto KiekTuri = 0;
						for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++) {
							if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 1486 && static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount >= 1) {
								KiekTuri = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
							}
						}
						SearchInventoryItem(peer, 1486, Price, contains);
						if (contains) {
							if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							RemoveInventoryItem(1486, Price, peer, true);			
							bool success = true;
							SaveItemMoreTimes(ItemID, count, peer, success, "Purchased from store");
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(KiekTuri - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + getItemDef(ItemID).name + ""));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						} else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - KiekTuri) + "`` Growtokens short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}

					if (cch.find("action|buy\nitem|crystal_cape") == 0) {
						/*Fast Item Setup*/
						auto Price = 3;
						auto ItemID = 1738;
						auto count = 1;
						auto contains = false;
						auto KiekTuri = 0;
						for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++) {
							if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 1486 && static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount >= 1) {
								KiekTuri = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
							}
						}
						SearchInventoryItem(peer, 1486, Price, contains);
						if (contains) {
							if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							RemoveInventoryItem(1486, Price, peer, true);			
							bool success = true;
							SaveItemMoreTimes(ItemID, count, peer, success, "Purchased from store");
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(KiekTuri - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + getItemDef(ItemID).name + ""));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						} else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - KiekTuri) + "`` Growtokens short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}

					if (cch.find("action|buy\nitem|digger_spade") == 0) {
						/*Fast Item Setup*/
						auto Price = 10;
						auto ItemID = 2952;
						auto count = 1;
						auto contains = false;
						auto KiekTuri = 0;
						for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++) {
							if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 1486 && static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount >= 1) {
								KiekTuri = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
							}
						}
						SearchInventoryItem(peer, 1486, Price, contains);
						if (contains) {
							if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							RemoveInventoryItem(1486, Price, peer, true);			
							bool success = true;
							SaveItemMoreTimes(ItemID, count, peer, success, "Purchased from store");
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGrowtokens.\nYou have `$" + to_string(KiekTuri - Price) + " `wGrowtokens left.\n\n`5Received: ``" + to_string(count) + " " + getItemDef(ItemID).name + ""));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						} else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - KiekTuri) + "`` Growtokens short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}

					if (cch.find("action|buy\nitem|angelwings") == 0) {
						/*Fast Item Setup*/
						auto Price = 6000;
						auto ItemID = 362;
						auto count = 1;
						ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
						auto gembux = atoi(content.c_str());
						if (gembux >= Price) {
							if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							gembux -= Price;
							ofstream myfile;
							myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile << gembux;
							myfile.close();
							Player::OnSetBux(peer, gembux, 0);
							bool success = true;
							SaveItemMoreTimes(ItemID, count, peer, success, "Purchased from store");
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received: ``" + to_string(count) + " " + getItemDef(ItemID).name + ""));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						} else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - gembux) + "`` Gems short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}

					if (cch.find("action|buy\nitem|rare_seed_pack") == 0) {
						ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
						auto gembux = atoi(content.c_str());
						if (gembux >= 1500) {
							int Seed1 = 0;
							int Seed2 = 0;
							int Seed3 = 0;
							int Seed4 = 0;
							int Seed5 = 0;
							int AVGRarity = rand() % 10 + 10;
							while (Seed1 == 0 || Seed2 == 0 || Seed3 == 0 || Seed4 == 0 || Seed5 == 0) {
								for (int i = 0; i < maxItems; i++) {
									if (i >= 1000) {
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Something went wrong.", 0, true);
										break;
									}
									if (isSeed(i) && getItemDef(i).rarity == AVGRarity || isSeed(i) && getItemDef(i).rarity == AVGRarity + 1) {
										if (Seed1 == 0) Seed1 = i;
										else if (Seed2 == 0) Seed2 = i;
										else if (Seed3 == 0) Seed3 = i;
										else if (Seed4 == 0) Seed4 = i;
										else if (Seed5 == 0) Seed5 = i;
										else break;
										AVGRarity = rand() % 10 + 10;
									} else if (i == maxItems - 1) {
										break;
									}
								}
							}
							if (CheckItemMaxed(peer, Seed1, 1) || CheckItemMaxed(peer, Seed2, 1) || CheckItemMaxed(peer, Seed3, 1) || CheckItemMaxed(peer, Seed4, 75) || CheckItemMaxed(peer, Seed5, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 5 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							gembux -= 1500;
							ofstream myfile;
							myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile << gembux;
							myfile.close();
							Player::OnSetBux(peer, gembux, 0);
							bool success = true;
							SaveItemMoreTimes(Seed1, 1, peer, success, "Purchased from store");
							SaveItemMoreTimes(Seed2, 1, peer, success, "Purchased from store");
							SaveItemMoreTimes(Seed3, 1, peer, success, "Purchased from store");
							SaveItemMoreTimes(Seed4, 1, peer, success, "Purchased from store");
							SaveItemMoreTimes(Seed5, 1, peer, success, "Purchased from store");
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `oRare Seed Pack `wfor `$" + to_string(1500) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received:`` " + getItemDef(Seed1).name + "`$,`` " + getItemDef(Seed2).name + "`$,`` " + getItemDef(Seed3).name + "`$,`` " + getItemDef(Seed4).name + "`$,`` " + getItemDef(Seed5).name + "\n"));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `oRare Seed Pack``!  You're `$" + to_string(1500 - gembux) + "`` Gems short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}

					if (cch.find("action|buy\nitem|geiger") == 0) {
						/*Fast Item Setup*/
						auto Price = 7500;
						auto ItemID = 2204;
						auto count = 1;
						ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
						auto gembux = atoi(content.c_str());
						if (gembux >= Price) {
							if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							gembux -= Price;
							ofstream myfile;
							myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile << gembux;
							myfile.close();
							Player::OnSetBux(peer, gembux, 0);
							bool success = true;
							SaveItemMoreTimes(ItemID, count, peer, success, "Purchased from store");
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received: ``" + to_string(count) + " " + getItemDef(ItemID).name + ""));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						} else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - gembux) + "`` Gems short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}

					if (cch.find("action|buy\nitem|grow_scan") == 0) {
						/*Fast Item Setup*/
						auto Price = 3500;
						auto ItemID = 6016;
						auto count = 1;
						ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
						auto gembux = atoi(content.c_str());
						if (gembux >= Price) {
							if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							gembux -= Price;
							ofstream myfile;
							myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile << gembux;
							myfile.close();
							Player::OnSetBux(peer, gembux, 0);
							bool success = true;
							SaveItemMoreTimes(ItemID, count, peer, success, "Purchased from store");
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received: ``" + to_string(count) + " " + getItemDef(ItemID).name + ""));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						} else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - gembux) + "`` Gems short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}

					if (cch.find("action|buy\nitem|small_seed_pack") == 0) {
						/*Fast Item Setup*/
						auto Price = 500;
						auto ItemID = 5706;
						auto count = 1;
						ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
						auto gembux = atoi(content.c_str());
						if (gembux >= Price) {
							if (CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && CheckItemExists(peer, ItemID) && CheckItemMaxed(peer, ItemID, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 1 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize && !CheckItemExists(peer, ItemID)) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							gembux -= Price;
							ofstream myfile;
							myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile << gembux;
							myfile.close();
							Player::OnSetBux(peer, gembux, 0);
							bool success = true;
							SaveItemMoreTimes(ItemID, count, peer, success, "Purchased from store");
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased " + to_string(count) + " `o" + getItemDef(ItemID).name + " `wfor `$" + to_string(Price) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received: ``" + to_string(count) + " " + getItemDef(ItemID).name + ""));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						} else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `o" + getItemDef(ItemID).name + "``!  You're `$" + to_string(Price - gembux) + "`` Gems short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}

					if (cch.find("action|buy\nitem|farm_pack") == 0) {
						ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
						auto gembux = atoi(content.c_str());
						if (gembux >= 4000) {
							if (CheckItemMaxed(peer, 872, 1) || CheckItemMaxed(peer, 866, 1) || CheckItemMaxed(peer, 102, 100) || CheckItemMaxed(peer, 340, 40) || CheckItemMaxed(peer, 5666, 40) || CheckItemMaxed(peer, 954, 60) || CheckItemMaxed(peer, 4584, 75) || CheckItemMaxed(peer, 898, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 8 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							gembux -= 4000;
							ofstream myfile;
							myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile << gembux;
							myfile.close();
							Player::OnSetBux(peer, gembux, 0);
							bool success = true;
							SaveItemMoreTimes(102, 100, peer, success, "Purchased from store");
							SaveItemMoreTimes(340, 40, peer, success, "Purchased from store");
							SaveItemMoreTimes(5666, 40, peer, success, "Purchased from store");
							SaveItemMoreTimes(954, 60, peer, success, "Purchased from store");
							SaveItemMoreTimes(4584, 75, peer, success, "Purchased from store");
							SaveItemMoreTimes(898, 1, peer, success, "Purchased from store");
							SaveItemMoreTimes(872, 1, peer, success, "Purchased from store");
							SaveItemMoreTimes(866, 1, peer, success, "Purchased from store");
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `oFarm Pack `wfor `$" + to_string(4000) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received:`` 100 Wooden Platforms`$,`` 40 Chandeliers`$,`` 40 Laser Grids`$,`` 60 Sugar Canes`$,`` 75 Pepper Trees`$,`` Dear John Tractor\n"));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `oFarm Pack``!  You're `$" + to_string(4000 - gembux) + "`` Gems short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}

					if (cch.find("action|buy\nitem|west_pack") == 0) {
						ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
						auto gembux = atoi(content.c_str());
						if (gembux >= 8000) {
							if (CheckItemMaxed(peer, 1044, 1) || CheckItemMaxed(peer, 1046, 10) || CheckItemMaxed(peer, 1048, 1) || CheckItemMaxed(peer, 1020, 1) || CheckItemMaxed(peer, 1022, 1) || CheckItemMaxed(peer, 1030, 1) || CheckItemMaxed(peer, 1024, 1) || CheckItemMaxed(peer, 1026, 1) || CheckItemMaxed(peer, 1028, 1) || CheckItemMaxed(peer, 1036, 1) || CheckItemMaxed(peer, 1034, 1) || CheckItemMaxed(peer, 1032, 1) || CheckItemMaxed(peer, 1038, 10) || CheckItemMaxed(peer, 1040, 1) || CheckItemMaxed(peer, 1042, 5) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 15 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							gembux -= 8000;
							ofstream myfile;
							myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile << gembux;
							myfile.close();
							Player::OnSetBux(peer, gembux, 0);			
							bool success = true;
							//Buffalo`$,`` 10 Rustic Fences`$,`` Campfire`$,`` Parasol
							SaveItemMoreTimes(1022, 1, peer, success, "Purchased from store");
							SaveItemMoreTimes(1030, 1, peer, success, "Purchased from store");
							SaveItemMoreTimes(1024, 1, peer, success, "Purchased from store");
							SaveItemMoreTimes(1026, 1, peer, success, "Purchased from store");
							SaveItemMoreTimes(1028, 1, peer, success, "Purchased from store");
							SaveItemMoreTimes(1036, 1, peer, success, "Purchased form store");
							SaveItemMoreTimes(1034, 1, peer, success, "Purchased from store");
							SaveItemMoreTimes(1032, 1, peer, success, "Purchased from store");
							SaveItemMoreTimes(1038, 10, peer, success, "Purchased from store");
							SaveItemMoreTimes(1040, 1, peer, success, "Purchased from store");
							SaveItemMoreTimes(1042, 5, peer, success, "Purchased form store");
							SaveItemMoreTimes(1044, 1, peer, success, "Purchased from store");
							SaveItemMoreTimes(1046, 10, peer, success, "Purchased from store");
							SaveItemMoreTimes(1048, 1, peer, success, "Purchased from store");
							SaveItemMoreTimes(1020, 1, peer, success, "Purchased from store");
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `oWild West Pack `wfor `$" + to_string(8000) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received:`` Cowboy Hat`&,`` Cowboy Boots`$,`` War Paint`$,`` Face Bandana`$,`` Sheriff Vest`$,`` Layer Cake Dress`$,`` Corset`$,`` Kansas Curls`$,`` 10 Western Building`$,`` Saloon Doors`$,`` 5 Western Banners`$,`` Buffalo`$,`` 10 Rustic Fences`$,`` Campfire`$,`` Parasol\n"));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `oWild West Pack``!  You're `$" + to_string(8000 - gembux) + "`` Gems short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}

					if (cch.find("action|buy\nitem|city_pack") == 0) {
						ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
						auto gembux = atoi(content.c_str());
						if (gembux >= 8000) {
							if (CheckItemMaxed(peer, 1008, 1) || CheckItemMaxed(peer, 986, 3) || CheckItemMaxed(peer, 992, 3) || CheckItemMaxed(peer, 990, 10) || CheckItemMaxed(peer, 996, 10) || CheckItemMaxed(peer, 998, 10) || CheckItemMaxed(peer, 988, 3) || CheckItemMaxed(peer, 1004, 10) || CheckItemMaxed(peer, 1006, 1) || CheckItemMaxed(peer, 1002, 1) || CheckItemMaxed(peer, 994, 10) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 11 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							gembux -= 8000;
							ofstream myfile;
							myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile << gembux;
							myfile.close();
							Player::OnSetBux(peer, gembux, 0);
							bool success = true;
							//1 Blue Mailbox`$,`` 1 Fire Hydrant`$,`` 10 Sidewalks
							SaveItemMoreTimes(1008, 1, peer, success, "Purchased from store");
							SaveItemMoreTimes(986, 3, peer, success, "Purchased from store");
							SaveItemMoreTimes(992, 3, peer, success, "Purchased from store");
							SaveItemMoreTimes(990, 10, peer, success, "Purchased from store");
							SaveItemMoreTimes(996, 10, peer, success, "Purchased from store");

							SaveItemMoreTimes(998, 10, peer, success, "Purchased form store");

							SaveItemMoreTimes(988, 3, peer, success, "Purchased from store");

							SaveItemMoreTimes(1004, 10, peer, success, "Purchased from store");

							SaveItemMoreTimes(1006, 1, peer, success, "Purchased from store");

							SaveItemMoreTimes(1002, 1, peer, success, "Purchased from store");
							SaveItemMoreTimes(994, 10, peer, success, "Purchased form store");
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `oCity Pack `wfor `$" + to_string(8000) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received:`` ATM Machine`&,`` 3 Street Signs`$,`` 3 Streetlamps`$,`` 10 Gothic Building tiles`$,`` 10 Tenement Building tiles`$,`` 10 Fire Escapes`$,`` 3 Gargoyles`$,`` 10 Hedges`$,`` 1 Blue Mailbox`$,`` 1 Fire Hydrant`$,`` 10 Sidewalks\n"));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `oCity Pack``!  You're `$" + to_string(8000 - gembux) + "`` Gems short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}

					if (cch.find("action|buy\nitem|science_pack") == 0) {
						ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
						auto gembux = atoi(content.c_str());
						if (gembux >= 5000) {
							if (CheckItemMaxed(peer, 916, 5) || CheckItemMaxed(peer, 914, 10) || CheckItemMaxed(peer, 924, 5) || CheckItemMaxed(peer, 920, 5) || CheckItemMaxed(peer, 918, 5) || CheckItemMaxed(peer, 930, 1) || CheckItemMaxed(peer, 928, 1) || CheckItemMaxed(peer, 912, 1) || CheckItemMaxed(peer, 772, 1) || CheckItemMaxed(peer, 770, 1) || CheckItemMaxed(peer, 904, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 11 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							gembux -= 5000;
							ofstream myfile;
							myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile << gembux;
							myfile.close();
							Player::OnSetBux(peer, gembux, 0);
							bool success = true;
							SaveItemMoreTimes(930, 1, peer, success, "Purchased from store");
							SaveItemMoreTimes(928, 1, peer, success, "Purchased from store");
							SaveItemMoreTimes(912, 1, peer, success, "Purchased from store");
							SaveItemMoreTimes(772, 1, peer, success, "Purchased from store");
							SaveItemMoreTimes(770, 1, peer, success, "Purchased from store");
							SaveItemMoreTimes(904, 1, peer, success, "Purchased form store");
							SaveItemMoreTimes(916, 5, peer, success, "Purchased from store");
							SaveItemMoreTimes(914, 10, peer, success, "Purchased from store");
							SaveItemMoreTimes(924, 5, peer, success, "Purchased from store");
							SaveItemMoreTimes(920, 5, peer, success, "Purchased from store");
							SaveItemMoreTimes(918, 5, peer, success, "Purchased form store");
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `oMad Science Kit `wfor `$" + to_string(5000) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received:`` Death Ray`&,`` Science Station`$,`` Laboratory`$,`` LabCoat`$,`` Combover Hair`$,`` Goggles`$,`` 5 Chemical R`$,`` 10 Chemical G`$,`` 5 Chemical Y`$,`` 5 Chemical B`$,`` 5 Chemical P\n"));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `oMad Science Kit``!  You're `$" + to_string(5000 - gembux) + "`` Gems short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}

					if (cch.find("action|buy\nitem|fishin_pack") == 0) {
						ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
						auto gembux = atoi(content.c_str());
						if (gembux >= 6000) {
							if (CheckItemMaxed(peer, 3044, 1) || CheckItemMaxed(peer, 2914, 5) || CheckItemMaxed(peer, 5522, 1) || CheckItemMaxed(peer, 5524, 1) || CheckItemMaxed(peer, 2912, 1) || CheckItemMaxed(peer, 3004, 10) || CheckItemMaxed(peer, 3002, 1) || CheckItemMaxed(peer, 822, 5) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 8 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							gembux -= 6000;
							ofstream myfile;
							myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile << gembux;
							myfile.close();
							Player::OnSetBux(peer, gembux, 0);
							bool success = true;
							SaveItemMoreTimes(3044, 1, peer, success, "Purchased from store");
							SaveItemMoreTimes(2914, 5, peer, success, "Purchased from store");
							SaveItemMoreTimes(5522, 1, peer, success, "Purchased from store");
							SaveItemMoreTimes(5524, 1, peer, success, "Purchased from store");
							SaveItemMoreTimes(2912, 1, peer, success, "Purchased from store");
							SaveItemMoreTimes(3004, 10, peer, success, "Purchased from store");
							SaveItemMoreTimes(3002, 1, peer, success, "Purchased from store");
							SaveItemMoreTimes(822, 5, peer, success);
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `oFishin' Pack `wfor `$" + to_string(6000) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received:`` Tackle Box`$,`` 5 Wiggly Worms`$,`` Hand Drill`$,`` Nuclear Detonator`$,`` Fishing Rod`$,`` 10 Fish Tanks`$,`` Fish Tank Port`$,`` 5 Water Buckets\n"));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
						else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `oFishin' Pack``!  You're `$" + to_string(6000 - gembux) + "`` Gems short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}
					if (cch.find("action|buy\nitem|firefighter") == 0) {
						ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
						auto gembux = atoi(content.c_str());
						if (gembux >= 3600) {
							if (CheckItemMaxed(peer, 3048, 1) || CheckItemMaxed(peer, 3056, 1) || CheckItemMaxed(peer, 3060, 1) || CheckItemMaxed(peer, 3052, 1) || CheckItemMaxed(peer, 3066, 1) || CheckItemMaxed(peer, 3072, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 6 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							gembux -= 3600;
							ofstream myfile;
							myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile << gembux;
							myfile.close();
							Player::OnSetBux(peer, gembux, 0);
							bool success = true;
							SaveItemMoreTimes(3048, 1, peer, success);
							SaveItemMoreTimes(3056, 1, peer, success);
							SaveItemMoreTimes(3060, 1, peer, success);
							SaveItemMoreTimes(3052, 1, peer, success);
							SaveItemMoreTimes(3066, 1, peer, success);
							SaveItemMoreTimes(3072, 1, peer, success);
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `oFirefighter Pack `wfor `$" + to_string(3600) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received:`` Firefighter Helmet - Yellow`$,`` Firefighter Pants - Yellow`$,`` Firefighter Jacket - Yellow`$,`` Firefighter Boots`$,`` Fire Hose`$,`` Firehouse\n"));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						} else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `oFirefighter Pack``!  You're `$" + to_string(3600 - gembux) + "`` Gems short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}
					if (cch.find("action|buy\nitem|paleo_pack") == 0) {
						ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
						string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
						auto gembux = atoi(content.c_str());
						if (gembux >= 7500) {
							if (CheckItemMaxed(peer, 4132, 5) || CheckItemMaxed(peer, 3932, 1) || CheckItemMaxed(peer, 3934, 1) || CheckItemMaxed(peer, 3938, 1) || CheckItemMaxed(peer, 4128, 1) || static_cast<PlayerInfo*>(peer->data)->inventory.items.size() + 5 >= static_cast<PlayerInfo*>(peer->data)->currentInventorySize) {
								Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You don't have enough space in your inventory that. You may be carrying to many of one of the items you are trying to purchase or you don't have enough free spaces to fit them all in your backpack!"));
								ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
								continue;
							}
							gembux -= 7500;
							ofstream myfile;
							myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							myfile << gembux;
							myfile.close();
							Player::OnSetBux(peer, gembux, 0);
							bool success = true;
							SaveItemMoreTimes(4132, 5, peer, success, "Purchased from store");
							SaveItemMoreTimes(3932, 1, peer, success, "Purchased from store");
							SaveItemMoreTimes(3934, 1, peer, success, "Purchased from store");
							SaveItemMoreTimes(3938, 1, peer, success, "Purchased from store");
							SaveItemMoreTimes(4128, 1, peer, success, "Purchased from store");
							Player::PlayAudio(peer, "audio/piano_nice.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You've purchased `oPaleontologist's Kit `wfor `$" + to_string(7500) + " `wGems.\nYou have `$" + to_string(gembux) + " `wGems left.\n\n`5Received:`` Fossil Prep Station`$,`` 5 Fossil Brushes`$,`` Rock Hammer`$,`` Rock Chisel`$,`` Blue Hardhat\n"));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						} else {
							Player::PlayAudio(peer, "audio/bleep_fail.wav", 0);
							GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStorePurchaseResult"), "You can't afford `oPaleontologist's Kit``!  You're `$" + to_string(7500 - gembux) + "`` Gems short."));
							ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							delete p.data;
						}
					}
					if (cch.find("action|buy\nitem|itempack") == 0) {
						GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStoreRequest"), "set_description_text|`2Item Packs!``  Select the item you'd like more info on, or BACK to go back.|\nadd_button|small_seed_pack|`oSmall Seed Pack``|interface/large/store_buttons.rttex|`2You Get:`` 1 Small Seed Pack.<CR><CR>`5Description:`` Contains one Small Seed Pack. Open it for `$5`` randomly chosen seeds, including 1 rare seed! Who knows what you'll get?!|1|4|500|0||\nadd_button|rare_seed_pack|`oRare Seed Pack``|interface/large/store_buttons.rttex|`2You Get:`` 5 Randomly Chosen Rare Seeds.<CR><CR>`5Description:`` Expect some wondrous crops with these!|1|7|1500|0||\nadd_button|paintbrush|`oPainter's Pack``|interface/large/store_buttons15.rttex|`2You Get:`` 1 `#Rare Paintbrush`` and 5 of each Colored Paint Buckets.<CR><CR>`5Description:`` Want to paint your world? This pack includes 5 of each paint bucket colors! You can paint any block in your world different colors to personalize it.|0|1|30000|0||\nadd_button|paleo_pack|`oPaleontologist's Kit``|interface/large/store_buttons16.rttex|`2You Get:`` 5 Fossil Brushes, 1 Rock Hammer, 1 Rock Chisel, 1 Blue Hardhat and 1 `#Rare Fossil Prep Station``.<CR><CR>`5Description:`` If you want to dig up fossils or elemental rocks, this is the kit for you! Includes everything you need! Use the prepstation to get your fossils ready for display.|0|0|7500|0||\nadd_button|vegas_pack|`oVegas Pack``|interface/large/store_buttons4.rttex|`2You Get:`` 10 Neon Lights, 1 Card Block Seed, 1 `#Rare Pink Cadillac`` 4 Flipping Coins, 1 Dice Block, 1 Gamblers Visor, 1 Slot Machine, 1 Roulette Wheel and 1 Showgirl Hat, 1 Showgirl top and 1 Showgirl Leggins.<CR><CR>`5Description:`` What happens in Growtopia stays in Growtopia!|0|5|20000|0||\nadd_button|farm_pack|`oFarm Pack``|interface/large/store_buttons5.rttex|`2You Get:`` 100 Wooden Platforms, 40 Chandeliers, 40 Laser Grids, 60 Sugar Canes, 75 Pepper Trees, Chicken, Cow and 1 `#Rare Dear John Tractor``.<CR><CR>`5Description:`` Most important pack for each single farmer!|0|0|4000|0||\nadd_button|science_pack|`oMad Science Kit``|interface/large/store_buttons5.rttex|`2You Get:`` 1 Science Station, 1 Laboratory, 1 LabCoat, 1 Combover Hair, 1 Goggles, 5 Chemical 5, 10 Chemical G, 5 Chemical Y, 5 Chemical B, 5 Chemical P and 1 `#Rare`` `2Death Ray``.<CR><CR>`5Description:`` It's SCIENCE! Defy the natural order with a Science Station that produces chemicals, a Laboratory in which to mix them and a full outfit to do so safely! You'll also get a starter pack of assorted chemicals. Mix them up! Special bonus: A `#Rare`` `2Death Ray`` to make your science truly mad!|0|3|5000|0||\nadd_button|west_pack|`oWild West Pack``|interface/large/store_buttons6.rttex|`2You Get:`` 1 Cowboy Hat, 1 Cowboy Boots, 1 War Paint, 1 Face Bandana, 1 Sheriff Vest, 1 Layer Cake Dress,  1 Corset, 1 Kansas Curls, 10 Western Building 1 Saloon Doors, 5 Western Banners, 1 Buffalo, 10 Rustic Fences, 1 Campfire and 1 Parasol.<CR><CR>`5Description:`` Yippee-kai-yay! This pack includes everything you need to have wild time in the wild west! The Campfire plays cowboy music, and the `#Parasol`` lets you drift down slowly. Special bonus: A `#Rare`` `2Six Shooter`` to blast criminals with!|0|2|8000|0||\nadd_button|city_pack|`oCity Pack``|interface/large/store_buttons6.rttex|`2You Get:`` 10 Sidewalks, 3 Street Signs, 3 Streetlamps, 10 Gothic Building tiles, 10 Tenement Building tiles, 10 Fire Escapes, 3 Gargoyles, 10 Hedges, 1 Blue Mailbox, 1 Fire Hydrant and A `#Rare`` `2ATM Machine``.<CR><CR>`5Description:`` Life in the big city is rough but a `#Rare`` `2ATM Machine`` that dishes out gems once a day is very nice!|0|0|8000|0||\nadd_button|fishin_pack|`oFishin' Pack``|interface/large/store_buttons14.rttex|`2You Get:`` 1 Fishing Rod, 5 Wiggly Worms, 1 Hand Drill, 1 Nuclear Detonator,  1 `#Rare Tackle Box``, 10 Fish Tanks, 5 Water Buckets and 1 `#Rare Fish Tank Port``.<CR><CR>`5Description:`` Relax and sit by the shore... this pack includes a Fishing Rod, Wiggly Worms for bait, Hand Drill, Nuclear Detonator, and a `#Rare`` Tackle Box which provides you with more free bait every two days, Fish Tanks, Water Buckets and a `#Rare`` Fish Tank Port to put the fish you catch into your fish tank!|0|0|6000|0||\nadd_button|firefighter|`oFirefighter Pack``|interface/large/store_buttons14.rttex|`2You Get:`` 1 Yellow Helmet, 1 Yellow Jacket, 1 Yellow Pants, 1 Firemans Boots, 1 Fire Hose, and 1 `#Rare Firehouse`` .<CR><CR>`5Description:`` Rescue Growtopians from the fire! Includes a full Yellow Firefighter Outfit, Fire Hose and a `#Rare Firehouse``, which will protect your own world from fires.|0|1|3600|0||\n"));
						ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
						enet_peer_send(peer, 0, packet);
						delete p.data;
					}
					if (cch.find("action|buy\nitem|token") == 0) {
						auto KiekTuri = 0;
						for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++) {
							if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 1486 && static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount >= 1) {
								KiekTuri = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
							}
						}
						GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStoreRequest"), "set_description_text|`2Spend your Growtokens!`` (You have `5" + to_string(KiekTuri) +"``) You earn Growtokens from Role Rewards or Level UP Rewards. Select the item you'd like more info on, or BACK to go back.|\nadd_button|digger_spade|`oDigger's Spade``|interface/large/store_buttons13.rttex|`2You Get:`` 1 Digger's Spade.<CR><CR>`5Description:`` This may appear to be a humble shovel, but in fact it is enchanted with the greatest magic in Growtopia. It can smash all kind of blocks in a single hit! Note: The spade is `#UNTRADEABLE``.|0|7|-10|0||\nadd_button|crystal_cape|`oCrystal Cape``|interface/large/store_buttons11.rttex|`2You Get:`` 1 Crystal Cape.<CR><CR>`5Description:`` This cape is woven of pure crystal, which makes it pretty uncomfortable. But it also makes it magical! It lets you double-jump off of an imaginary Crystal Block in mid-air. Sponsored by Edvoid20, HemeTems, and Aboge.|0|5|-3|0||\nadd_button|focused_eyes|`oFocused Eyes``|interface/large/store_buttons9.rttex|`2You Get:`` 1 Focused Eyes.<CR><CR>`5Description:`` This `#Untradeable`` item lets you shoot electricity from your eyes! Wear them with pride, and creepiness.|0|4|-10|0||\nadd_button|cat_eyes|`oCat Eyes``|interface/large/store_buttons23.rttex|`2You Get:`` 1 Cat Eyes.<CR><CR>`5Description:`` Wow, pawesome! These new eyes are the cat's meow, and the purrfect addition to any style.|0|5|-1|0||\nadd_button|golden_pickaxe|`oGolden Pickaxe``|interface/large/store_buttons9.rttex|`2You Get:`` 1 Golden Pickaxe.<CR><CR>`5Description:`` Get your own sparkly pickaxe! This `#Untradeable`` item is a status symbol! Oh sure, it isn't any more effective than a normal pickaxe, but it sparkles!|0|1|-15|0||\nadd_button|puppy_leash|`oPuppy Leash``|interface/large/store_buttons11.rttex|`2You Get:`` 1 Puppy Leash.<CR><CR>`5Description:`` Get your own pet puppy! This little dog will follow you around forever, never wavering in her loyalty, thus making her `#Untradeable``.|0|4|-5|0||\nadd_button|meow_ears|`oMeow Ears``|interface/large/store_buttons22.rttex|`2You Get:`` 1 Meow Ears.<CR><CR>`5Description:`` Meow's super special ears that everyone can now get! Note: These ears are `#UNTRADEABLE``.|0|0|-5|0||\nadd_button|frosty_hair|`oFrosty Hair``|interface/large/store_buttons23.rttex|`2You Get:`` 1 Frosty Hair.<CR><CR>`5Description:`` Coldplay is cold, but you can be freezing! Note: The frosty hair is `#UNTRADEABLE``.|0|0|-10|0||\nadd_button|evil_space_helmet|`oEvil Space Helmet``|interface/large/store_buttons21.rttex|`2You Get:`` 1 Evil Space Helmet.<CR><CR>`5Description:`` Zerkon commands a starship too small to actually board - pah, time to rule the galaxy properly! Note: The evil space helmet is `#UNTRADEABLE``.|0|6|-5|0||\nadd_button|atomi_shadow_scythe|`oAtomic Shadow Scythe``|interface/large/store_buttons21.rttex|`2You Get:`` 1 Atomic Shadow Scythe.<CR><CR>`5Description:`` AtomicShadow might actually be evil, now you can try it out! Note: The shadow scythe is `#UNTRADEABLE``.|0|5|-10|0||\nadd_button|seil_magic_orb|`oSeil's Magic Orbs``|interface/large/store_buttons21.rttex|`2You Get:`` 1 Seil's Magic Orbs.<CR><CR>`5Description:`` Seil is some kind of evil wizard, now you can be too! Note: These magic orbs are `#UNTRADEABLE``.|0|7|-15|0||\n"));
						ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
						enet_peer_send(peer, 0, packet);
						delete p.data;
					}
					if (cch.find("action|buy\nitem|bigitems") == 0) {
						GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStoreRequest"), "set_description_text|`2Awesome Items!``  Select the item you'd like more info on, or BACK to go back.|\nadd_button|magplant5000|`oMAGPLANT 5000``|interface/large/store_buttons_iotm.rttex|`2You Get:`` 1 MAGPLANT 5000.<CR><CR>`5Description:`` Tired of picking things up with your puny human hands only to put them down later? With the awesome power of MAGNETS, these woes will be a thing of the past! GrowTech inv. proudly presents the MagPlant 5000, an all-in-one item-collecting and planting masterpiece. Simply target the machine to the seed or block of your choosing, and it will collect and store any that drop in your world! Only collects items from breaking blocks, harvesting and dropping! `5it's a perma-item, is never lost when destroyed.|0|0|150000|0||\nadd_button|unstabletesseract|`oUnstable Tesseract``|interface/large/store_buttons_magplants.rttex|`2You Get:`` 1 Unstable Tesseract.<CR><CR>`5Description:`` A spatial vortex is a dangerous thing, but this one... can be controlled! Place this techno hazard to start summoning blocks! Simply target this tear to the block of your choosing, and it will collect and store any that drop in your world! Only collects blocks from breaking blocks and harvesting! `5it's a perma-item, is never lost when destroyed.|0|1|50000|0||\nadd_button|manipulator|`oTesseract Manipulator``|interface/large/store_buttons_magplants.rttex|`2You Get:`` 1 Tesseract Manipulator.<CR><CR>`5Description:`` Tired at smashing blocks on your own? Perhaps it's time we meddled in the darker side of science and made our lives easier! Fuel this advanced machinery with enough Gems, tell it to target any block of your choosing, and it will break them AUTOMATICALLY! `5it's a perma-item, is never lost when destroyed.|0|0|60000|0||\nadd_button|gaiabeacon|`oGaia's Beacon``|interface/large/store_buttons_magplants.rttex|`2You Get:`` 1 Gaia's Beacon.<CR><CR>`5Description:`` The pulse of nature calls to its own! Place this beacon to start summoning seeds! Simply tune this bioform to the seed of your choosing, and it will collect and store any that drop in your world! Only collects seeds from breaking blocks and harvesting! `5it's a perma-item, is never lost when destroyed.|0|2|100000|0||\nadd_button|organic|`oTechno-Organic Engine``|interface/large/store_buttons_magplants.rttex|`2You Get:`` 1 Techno-Organic Engine.<CR><CR>`5Description:`` What has science DONE?! By fusing the verdant powers of nature and the chaotic energies of the void, you've managed to create a device capable of placing blocks and using your other Magplants storages for placing blocks, also has itself 5000 capacity!|0|4|90000|0||\nadd_button|grow_scan|`oGrowScan 9000``|interface/large/store_buttons_magplants.rttex|`2You Get:`` 1 GrowScan 9000.<CR><CR>`5Description:`` Bewildered by blocks? Mystified by machines? Well, struggle no more! The GrowScan 9000 is here to help! Wrench this incredible invention and you'll instantly learn about every last block in your world - Check stats, find items and more with a flip of the wrench! Wow!`5It's a perma-item, is never lost when destroyed.``|0|6|3500|0||\nadd_button|raymanfist|`oRayman's Fist``|interface/large/store_buttons_iotm.rttex|`2You Get:`` 1 Rayman's Fist.<CR><CR>`5Description:`` The perfect punch! Ever wanted to send a disembodie fist flying across the land like Rayman? Well, now you can! Land a blow like none other with this furious fist. It even comes with a friend: Globox!|0|1|200000|0||\nadd_button|razorwings|`oRazor Wings``|interface/large/store_buttons_iotm.rttex|`2You Get:`` 1 Razor Wings.<CR><CR>`5Description:`` Slice through the air with the greatest of ease! And double jump.|0|4|15000|0||\nadd_button|largeblast|`oLarge Blast``|interface/large/store_buttons_iotm.rttex|`2You Get:`` 1 Large Blast.<CR><CR>`5Description:`` This supervillainous device will blast you to a new world that is almost twice larger than regular one! Remember: When using this, you are creating a NEW world by typing in a new name. It would be irresponsible to let you blow up an entire existing world.|0|5|1000|0||\nadd_button|tinyblast|`oTiny Blast``|interface/large/store_buttons_iotm.rttex|`2You Get:`` 1 Tiny Blast.<CR><CR>`5Description:`` This supervillainous device will blast you to a new world that is almost twice tinier than regular one! Remember: When using this, you are creating a NEW world by typing in a new name. It would be irresponsible to let you blow up an entire existing world.|0|6|1000|0||\nadd_button|thermo_blast|`oThermonuclear Blast``|interface/large/store_buttons8.rttex|`2You Get:`` 1 Thermonuclear Blast.<CR><CR>`5Description:`` This supervillainous device will blast you to a new world that has been scoured completely empty - it contains nothing but Bedrock and a White Door. Remember: When using this, you are creating a NEW world by typing in a new name. It would be irresponsible to let you blow up an entire existing world.|0|5|3000|0||\nadd_button|geiger|`oGeiger Counter``|interface/large/store_buttons12.rttex|`2You Get:`` 1 Geiger Counter.<CR><CR>`5Description:`` With this fantabulous device, you can detect radiation around you. It bleeps red, then yellow, then green as you get closer to the source. Who knows what you might find? `4Not available any other way!``|0|1|7500|0||\n"));
						ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
						enet_peer_send(peer, 0, packet);
						delete p.data;
					}
					if (cch.find("action|store\nlocation|gem") == 0) {
						if (!static_cast<PlayerInfo*>(peer->data)->haveGrowId) {
							SendRegisterDialog(peer); 
							continue;
						}
						GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnStoreRequest"), "set_description_text|Welcome to the `2GTOS Store``! Select the item you'd like more info on. `wWant to get `5Supporter`` status? Any Gem purchase (or `57,000`` Gems earned with free `5Tapjoy`` offers) will make you one. You'll get new skin colors, the `5Recycle`` tool to convert unwanted items into Gems, and more bonuses!\nadd_button|farmable_menu|Farmable Blocks|interface/large/store_buttons_farmable.rttex|This is a key to everything! Farmable blocks will gain you goods depending on their rarity.|0|1|0|0||\nadd_button|locks_menu|Locks And Stuff|interface/large/store_buttons3.rttex||0|4|0|0||\nadd_button|itempack_menu|Item Packs|interface/large/store_buttons3.rttex||0|3|0|0||\nadd_button|bigitems_menu|Awesome Items|interface/large/store_buttons4.rttex||0|6|0|0||\nadd_button|token_menu|Growtoken Items|interface/large/store_buttons9.rttex||0|0|0|0||\nadd_button|angelwings|`oAngel Wings``|interface/large/store_buttons_iotm.rttex|`2You Get:`` 1 Angel Wings.<CR><CR>`5Description:`` First ever `$Item Of The Week`` In the GTOS history.|0|7|6000|0||\n"));
						ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
						enet_peer_send(peer, 0, packet);
						delete p.data;
					}
					if (cch.find("action|info") == 0) {
						std::stringstream ss(cch);
						std::string to;
						int id = -1;
						int count = -1;
						while (std::getline(ss, to, '\n')) {
							vector<string> infoDat = explode("|", to);
							if (infoDat.size() == 3) {
								if (infoDat[1] == "itemID") id = atoi(infoDat[2].c_str());
								if (infoDat[1] == "count") count = atoi(infoDat[2].c_str());
							}
						}
						if (id == -1 || count == -1 || itemDefs.size() < id || id < 0) continue;
						string properties = "\nadd_textbox|";
						ItemDefinition itemDef = getItemDef(id);
						if (itemDef.properties & Property_Untradable) properties += "<CR>`1This item cannot be dropped or traded.`` ";
						if (itemDef.properties & Property_Wrenchable) properties += "<CR>`1This item has special properties you can adjust with the Wrench.`` ";
						if (itemDef.properties & Property_NoSeed) properties += "<CR>`1This item never drops any seeds.`` ";
						if (itemDef.properties & Property_Permanent) properties += "<CR>`1This item can't be destroyed - smashing it will return it to your backpack if you have room!`` ";
						if (properties != "\nadd_textbox|") properties += "|left|";
						else properties = "";
						Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_ele_icon|big|`wAbout " + itemDef.name + "``|left|" + std::to_string(id) + "|3|\nadd_spacer|small|\nadd_textbox|" + itemDef.description + "|left|" + properties + "|\nend_dialog|continue||OK|");
					}
					if (cch.find("action|dialog_return") == 0) {
						if (static_cast<PlayerInfo*>(peer->data)->isIn == false || static_cast<PlayerInfo*>(peer->data)->wrenchsession < 0 || static_cast<PlayerInfo*>(peer->data)->wrenchsession > 6000 || world == nullptr || static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT" || serverIsFrozen) break;
						if (static_cast<PlayerInfo*>(peer->data)->wrenchsession == 0) {
							if (static_cast<PlayerInfo*>(peer->data)->lastPunchX < 0 || static_cast<PlayerInfo*>(peer->data)->lastPunchY < 0 || static_cast<PlayerInfo*>(peer->data)->lastPunchX > 6000 || static_cast<PlayerInfo*>(peer->data)->lastPunchY > 10000) {
								if (static_cast<PlayerInfo*>(peer->data)->lastPunchX != -1 && static_cast<PlayerInfo*>(peer->data)->lastPunchY != -1) {
									SendConsole("Invalid structure handler, x was " + to_string(static_cast<PlayerInfo*>(peer->data)->lastPunchX) + " and y was " + to_string(static_cast<PlayerInfo*>(peer->data)->lastPunchY), "INVALID");
									break;
								}
							}
						} else if (static_cast<PlayerInfo*>(peer->data)->wrenchsession < 0 || static_cast<PlayerInfo*>(peer->data)->wrenchsession > 6000) {
							SendConsole("Invalid session handler, wrenchsession was " + to_string(static_cast<PlayerInfo*>(peer->data)->wrenchsession) + "", "INVALID");
							break;
						}
						std::stringstream ss(cch);
						std::string to;
						int givesafeitemItemIDInt = 0;
						int givesafeitemCountInt = 0;
						int safe_withdrawConfirmCountInt = 0;
						int safe_withdrawConfirmAposInt = 0;
						int givedonationboxitemCountInt = 0;
						int givedonationboxitemItemIDInt = 0;
						int setprice = 0;
						int chk_peritem = 0;
						string per_item = "0";
						string vverify = "0";
						string vbuycount = "0";
						string vexpectprice = "0";
						string vexpectitem = "0";
						string itemFind = "";
						string strButItemByRarityCount = "";
						int chk_perlock = 0;
						int stockitem = 0;
						int buyprice = 0;
						bool isPassDoorDialog = false;
						bool isGuildDialog = false;
						bool isRegisterDialog = false;
						bool isDropDialog = false;
						bool isBuyItemByRarityDialog = false;
						bool isAutoBreakDialog = false;
						bool isGrowScanDialog = false;
						bool isAutoPlaceDialog = false;
						bool isFindDialog = false;
						bool isMannequinEdit = false;
						bool isTrashDialog = false;
						bool isStuffDialog = false;
						bool isMagDialog = false;
						bool isMagCheckDialog = false;
						bool isLockDialog = false;
						bool isEntranceDialog = false;
						bool MagUpdateDialog = false;
						bool isLargeDialog = false;
						bool isThermoDialog = false;
						bool isTinyDialog = false;
						bool isTeleDialog = false;
						bool isEditDoorDialog = false;
						bool isSongDialog = false;
						bool worldcategoryDialog = false;
						bool signEditor = false;
						bool isgivedonationboxitemConfirm = false;
						bool isWrenchDialog = false;
						bool isRolesDialog = false;
						bool isaddItemToDonationBox = false;
						bool isboxlvl1AddItemDialog = false;
						bool isboxlvl2AddItemDialog = false;
						bool isboxlvl3AddItemDialog = false;
						bool isSafeAddItemDialog = false;
						bool issafedepositconfirmDialog = false;
						bool issafewithdrawConfirmDialog = false;
						bool notebook_edit = false;
						bool title_save = false;
						bool vending = false;
						bool vending_buy = false;
						bool SurgeryDialog = false;
						string guild_name;
						string guild_statement;
						string guild_mascot_bg;
						string guild_mascot_fg;
						string addItemToDonationBox = "";
						string stuffitem = "";
						string magplantitem = "";
						string emeraldbfg = "";
						string gravitystr = "";
						string btn = "";
						string register_username = "", register_password = "", register_password_verify = "", register_email = "";
						string dropitemcount = "";
						string trashitemcount = "";
						string door_destination_world = "", door_destination_id = "", door_name = "", door_id = "";
						string entranceresult = "";
						string playerNetId = "";
						string muted = "";
						string publicremote = "";
						string telefonas = "";
						string uranusnames = "";
						string tinynames = "";
						string largenames = "";
						string thermonames = "";
						string message321 = "";
						string givedonationboxitemCount = "";
						string boxlvl1AddItemDialog = "";
						string boxlvl2AddItemDialog = "";
						string boxlvl3AddItemDialog = "";
						string SafeAddItemDialog = "";
						string safedepositcount = "";
						string safedepositcoord = "";
						string safedeposititemID = "";
						string MyTradeItem = "";
						string safe_withdrawConfirmCount = "";
						string safe_withdrawConfirmApos = "";
						string worldpublic = "";
						string safe_withdrawConfirmCoord = "";
						string givedonationboxitemCoord = "";
						string givedonationboxitemItemID = "";
						string givedonationboxitem = "";
						string pass_door_password = "";
						string givedonationboxitemNote = "";
						string title_name = "";
						string personal_note = "";
						while (std::getline(ss, to, '\n')) {
							vector<string> infoDat = explode("|", to);
							if (infoDat.size() == 2) {
								if (infoDat[0] == "buttonClicked") btn = infoDat[1];
								if (static_cast<PlayerInfo*>(peer->data)->haveGrowId == false && infoDat[0] == "dialog_name" && infoDat[1] != "register") break;
								if (static_cast<PlayerInfo*>(peer->data)->haveGrowId == false && btn != "") break;
								if (infoDat[0] == "dialog_name" && infoDat[1] == "worldcategory") worldcategoryDialog = true;
								if (infoDat[0] == "dialog_name" && infoDat[1] == "vending") vending = true;
								if (infoDat[0] == "dialog_name" && infoDat[1] == "vending_buy") vending_buy = true;
								if (infoDat[0] == "dialog_name" && infoDat[1] == "findid") isFindDialog = true;
								if (infoDat[0] == "dialog_name" && infoDat[1] == "givedonationboxitemConfirm") isgivedonationboxitemConfirm = true;
								if (infoDat[0] == "dialog_name" && infoDat[1] == "notebook_edit") notebook_edit = true;
								if (infoDat[0] == "dialog_name" && infoDat[1] == "title_save") title_save = true;
								if (infoDat[0] == "dialog_name" && infoDat[1] == "gateway_edit") isEntranceDialog = true;
								if (infoDat[0] == "dialog_name" && infoDat[1] == "editsign") signEditor = true;
								if (infoDat[0] == "dialog_name" && infoDat[1] == "lock_edit") isLockDialog = true;
								if (infoDat[0] == "dialog_name" && infoDat[1] == "magplantcheck") isMagCheckDialog = true;
								if (infoDat[0] == "dialog_name" && infoDat[1] == "magplantupdate") MagUpdateDialog = true;
								if (infoDat[0] == "dialog_name" && infoDat[1] == "safe_withdrawConfirm") issafewithdrawConfirmDialog = true;
								if (infoDat[0] == "dialog_name" && infoDat[1] == "safedepositconfirm") issafedepositconfirmDialog = true;
								if (infoDat[0] == "dialog_name" && infoDat[1] == "surge") SurgeryDialog = true;
								if (infoDat[0].substr(0, 16) == "addDonationItem_") isaddItemToDonationBox = true;
								if (infoDat[0].substr(0, 12) == "safedeposit_") isSafeAddItemDialog = true;
								if (infoDat[0].substr(0, 15) == "boxlvl1deposit_") isboxlvl1AddItemDialog = true;
								if (infoDat[0].substr(0, 15) == "boxlvl2deposit_") isboxlvl2AddItemDialog = true;
								if (infoDat[0].substr(0, 15) == "boxlvl3deposit_") isboxlvl3AddItemDialog = true;
								if (infoDat[0] == "stuffitem") isStuffDialog = true;
								if (infoDat[0] == "dialog_name" && infoDat[1] == "buyitembyrarity") isBuyItemByRarityDialog = true;
								if (infoDat[0] == "magplantitem") isMagDialog = true;
								if (infoDat[0] == "dialog_name" && infoDat[1] == "mainwrenchpage") isWrenchDialog = true;
								if (infoDat[0] == "dialog_name" && infoDat[1] == "roleRewardsPage") isRolesDialog = true;
								if (infoDat[0] == "dialog_name" && infoDat[1] == "dropdialog") isDropDialog = true;
								if (infoDat[0] == "dialog_name" && infoDat[1] == "autobreak") isAutoBreakDialog = true;
								if (infoDat[0] == "dialog_name" && infoDat[1] == "autoplace") isAutoPlaceDialog = true;
								if (infoDat[0] == "dialog_name" && infoDat[1] == "trashdialog") isTrashDialog = true;
								if (infoDat[0] == "dialog_name" && infoDat[1] == "guildconfirm") isGuildDialog = true;
								if (infoDat[0] == "dialog_name" && infoDat[1] == "door_edit") isEditDoorDialog = true;
								if (infoDat[0] == "dialog_name" && infoDat[1] == "register") isRegisterDialog = true;
								if (infoDat[0] == "dialog_name" && infoDat[1] == "song_edit") isSongDialog = true;
								if (infoDat[0] == "dialog_name" && infoDat[1] == "mannequin_edit") isMannequinEdit = true;
								if (infoDat[0] == "dialog_name" && infoDat[1] == "uselargeblast") isLargeDialog = true;
								if (infoDat[0] == "dialog_name" && infoDat[1] == "usethermoblast") isThermoDialog = true;
								if (infoDat[0] == "dialog_name" && infoDat[1] == "usetinyblast") isTinyDialog = true;
								if (infoDat[0] == "dialog_name" && infoDat[1] == "usetelephone") isTeleDialog = true;
								if (infoDat[0] == "dialog_name" && infoDat[1] == "password_reply") isPassDoorDialog = true;
								if (infoDat[0] == "dialog_name" && infoDat[1] == "statsblock") isGrowScanDialog = true;
								if (isMannequinEdit) {
									if (infoDat[0] == "sign_textas") {
										if (infoDat[1].size() > 128) break;
										int x = static_cast<PlayerInfo*>(peer->data)->wrenchedBlockLocation % world->width;
										int y = static_cast<PlayerInfo*>(peer->data)->wrenchedBlockLocation / world->width;
										if (x < 0 || y < 0) break;
										world->items[static_cast<PlayerInfo*>(peer->data)->wrenchedBlockLocation].sign = infoDat[1];
										auto ismannequin = std::experimental::filesystem::exists("mannequin/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + std::to_string(static_cast<PlayerInfo*>(peer->data)->wrenchedBlockLocation) + ".json");
										if (ismannequin) {
											json j;
											ifstream fs("mannequin/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + std::to_string(static_cast<PlayerInfo*>(peer->data)->wrenchedBlockLocation) + ".json");
											fs >> j;
											fs.close();
											cout << world->items[static_cast<PlayerInfo*>(peer->data)->wrenchedBlockLocation].sign << endl;
											updateMannequin(peer, world->items[static_cast<PlayerInfo*>(peer->data)->wrenchedBlockLocation].foreground, x, y, world->items[static_cast<PlayerInfo*>(peer->data)->wrenchedBlockLocation].background, world->items[static_cast<PlayerInfo*>(peer->data)->wrenchedBlockLocation].sign, atoi(j["clothHair"].get<string>().c_str()), atoi(j["clothHead"].get<string>().c_str()), atoi(j["clothMask"].get<string>().c_str()), atoi(j["clothHand"].get<string>().c_str()), atoi(j["clothNeck"].get<string>().c_str()), atoi(j["clothShirt"].get<string>().c_str()), atoi(j["clothPants"].get<string>().c_str()), atoi(j["clothFeet"].get<string>().c_str()), atoi(j["clothBack"].get<string>().c_str()), true, 0);
										}						
									}
								}
								if (isFindDialog) {
									if (infoDat[0] == "item") itemFind = infoDat[1];
								}
								if (isBuyItemByRarityDialog)
								{
									if (world == nullptr || world->name == "EXIT" || serverIsFrozen) break;
									if (infoDat[0].substr(0, 18) == "buyitembyrarityid_")
									{
										strButItemByRarityCount = infoDat[1];
										string id = infoDat[0].substr(infoDat[0].find("_") + 1);

										if (strButItemByRarityCount == "")
										{
											Player::OnTextOverlay(peer, "`4Quantity should be more than 0 and lower than 201.");
											break;
										}
										if (strButItemByRarityCount.length() > 5)
										{
											Player::OnTextOverlay(peer, "`4Quantity should be more than 0 and lower than 201.");
											break;
										}
										bool contains_non_int2 = !std::regex_match(strButItemByRarityCount, std::regex("^[0-9]+$"));
										if (contains_non_int2 == true)
										{
											Player::OnTextOverlay(peer, "`4Quantity should be more than 0 and lower than 201.");
											break;
										}
										if (strButItemByRarityCount.size() > 3 || strButItemByRarityCount.size() <= 0)
										{
											break;
										}
										if (strButItemByRarityCount.size() > 3) break;
										int converted_count = stoi(strButItemByRarityCount);
										if (converted_count < 1 || converted_count > 200)
										{
											Player::OnTextOverlay(peer, "`4Quantity should be more than 0 and lower than 201.");
											break;
										}

										int realPrice = 0;
										if (id.size() > 5 || id.size() <= 0) break;
										if (realPrice <= 0)
										{
											realPrice = 1;
										}
										bool contains_non_int4 = !std::regex_match(id, std::regex("^[0-9]+$"));
										if (contains_non_int4 == true)
										{
											autoBan(peer, false, 24 * 7, "Proxy detect! when buying item by rarity from /buy. item id was: " + id);
											break;
										}
										int itemID = stoi(id);
										int itemid = stoi(id);
										if (getItemDef(itemID).name.find("Mooncake") != string::npos || getItemDef(itemID).name.find("Harvest") != string::npos && itemID != 1830 || getItemDef(itemID).name.find("Autumn") != string::npos || itemID == 1056 || itemID == 1804 || getItemDef(itemID).blockType == BlockTypes::COMPONENT || getItemDef(itemID).properties & Property_Chemical || itemID == 6920 || itemID == 6922 || itemID == 1874 || itemID == 1876 || itemID == 1904 || itemID == 1932 || itemID == 1900 || itemID == 1986 || itemID == 1996 || itemID == 2970 || itemID == 3140 || itemID == 3174 || itemID == 6028 || itemID == 6846 || itemID == 8962 || itemID == 2408 || itemID == 4428 || itemID == 5086 || itemID == 9240 || itemID == 9306 || itemID == 9290 || itemID == 7328 || itemID == 9416 || itemID == 10386 || itemID == 9410 || itemID == 1458 || itemID == 9408 || itemID == 9360 || itemID == 6866 || itemID == 6868 || itemID == 6870 || itemID == 6872 || itemID == 6874 || itemID == 6876 || itemID == 6878 || itemID == 2480 || itemID == 8452 || itemID == 5132 || itemID == 7166 || itemID == 5126 || itemID == 5128 || itemID == 5130 || itemID == 5144 || itemID == 5146 || itemID == 5148 || itemID == 5150 || itemID == 5162 || itemID == 5164 || itemID == 5166 || itemID == 5168 || itemID == 5180 || itemID == 5182 || itemID == 5184 || itemID == 5186 || itemID == 7168 || itemID == 7170 || itemID == 7172 || itemID == 7174 || itemID == 8834 || itemID == 7912 || itemID == 9212 || itemID == 5134 || itemID == 5152 || itemID == 5170 || itemID == 5188 || itemID == 980 || itemID == 9448 || itemID == 9310 || itemID == 10034 || itemID == 10036 || itemID == 8470 || itemID == 8286 || itemID == 6026 || itemID == 1970 || itemID == 1784 || itemID == 9356 || itemID == 10022 || itemID == 902 || itemID == 10032 || itemID == 834 || itemID == 6 || itemID == 5640 || itemID == 9492 || itemID == 1782 || itemID == 9288 || itemID == 1780 || itemID == 8306 || itemID == 202 || itemID == 204 || itemID == 206 || itemID == 2950 || itemID == 4802 || itemID == 4994 || itemID == 5260 || itemID == 5814 || itemID == 5980 || itemID == 7734 || itemID == 2592 || itemID == 2242 || itemID == 1794 || itemID == 1792 || itemID == 778 || itemID == 9510 || itemID == 8774 || itemID == 2568 || itemID == 9512 || itemID == 9502 || itemID == 9482 || itemID == 2250 || itemID == 2248 || itemID == 2244 || itemID == 2246 || itemID == 2286 || itemID == 9508 || itemID == 9504 || itemID == 9506 || itemID == 274 || itemID == 276 || itemID == 9476 || itemID == 1486 || itemID == 9498 || itemID == 4426 || itemID == 9496 || itemID == 278 || itemID == 9490 || itemID == 2410 || itemID == 9488 || itemID == 9452 || itemID == 9454 || itemID == 9472 || itemID == 9456 || itemID == 732 || itemID == 9458 || itemID == 6336 || itemID == 112 || itemID == 8 || itemID == 3760 || getItemDef(itemID).blockType == BlockTypes::FISH || itemID == 7372 || itemID == 9438 || itemID == 9462 || itemID == 9440 || itemID == 9442 || itemID == 9444 || itemID == 7960 || itemID == 7628 || itemID == 8552) break;
										if (itemid == 4296 || itemid == 6212 || itemid == 1212 || itemid == 1190 || itemid == 1206 || itemid == 1166 || itemid == 1964 || itemid == 1976 || itemid == 1998 || itemid == 1946 || itemid == 2002 || itemid == 1958 || itemid == 1952 || itemid == 2030 || itemid == 3104 || itemid == 3112 || itemid == 3120 || itemid == 3092 || itemid == 3094 || itemid == 3096 || itemid == 4184 || itemid == 4178 || itemid == 4174 || itemid == 4180 || itemid == 4170 || itemid == 4168 || itemid == 4150 || itemid == 1180 || itemid == 1224 || itemid == 5226 || itemid == 5228 || itemid == 5230 || itemid == 5212 || itemid == 5246 || itemid == 5242 || itemid == 5234 || itemid == 7134 || itemid == 7118 || itemid == 7132 || itemid == 7120 || itemid == 7098 || itemid == 9018 || itemid == 9038 || itemid == 9026 || itemid == 9066 || itemid == 9058 || itemid == 9044 || itemid == 9024 || itemid == 9032 || itemid == 9036 || itemid == 9028 || itemid == 9030 || itemid == 9110 || itemid == 9112 || itemid == 10386 || itemid == 10326 || itemid == 10324 || itemid == 10322 || itemid == 10328 || itemid == 10316 || itemid == 1198 || itemid == 1208 || itemid == 1222 || itemid == 1200 || itemid == 1220 || itemid == 1202 || itemid == 1238 || itemid == 1168 || itemid == 1172 || itemid == 1230 || itemid == 1194 || itemid == 1192 || itemid == 1226 || itemid == 1196 || itemid == 1236 || itemid == 1182 || itemid == 1184 || itemid == 1186 || itemid == 1188 || itemid == 1170 || itemid == 1212 || itemid == 1214 || itemid == 1232 || itemid == 1178 || itemid == 1234 || itemid == 1250 || itemid == 1956 || itemid == 1990 || itemid == 1968 || itemid == 1960 || itemid == 1948 || itemid == 1966 || itemid == 3114 || itemid == 3118 || itemid == 3100 || itemid == 3122 || itemid == 3124 || itemid == 3126 || itemid == 3108 || itemid == 3098 || itemid == 1962 || itemid == 2000 || itemid == 1970 || itemid == 4186 || itemid == 4188 || itemid == 4246 || itemid == 4248 || itemid == 4192 || itemid == 4156 || itemid == 4136 || itemid == 4152 || itemid == 4166 || itemid == 4190 || itemid == 4172 || itemid == 4182 || itemid == 4144 || itemid == 4146 || itemid == 4148 || itemid == 4140 || itemid == 4138 || itemid == 4142 || itemid == 5256 || itemid == 5208 || itemid == 5216 || itemid == 5218 || itemid == 5220 || itemid == 5214 || itemid == 5210 || itemid == 5254 || itemid == 5250 || itemid == 5252 || itemid == 5244 || itemid == 5236 || itemid == 7104 || itemid == 7124 || itemid == 7122 || itemid == 7102 || itemid == 7100 || itemid == 7126 || itemid == 7104 || itemid == 7124 || itemid == 7122 || itemid == 7102 || itemid == 7100 || itemid == 9048 || itemid == 9056 || itemid == 9114 || itemid == 9034 || itemid == 1210 || itemid == 1216 || itemid == 1218 || itemid == 1992 || itemid == 1982 || itemid == 1994 || itemid == 1972 || itemid == 1980 || itemid == 1988 || itemid == 1984 || itemid == 3116 || itemid == 3102 || itemid == 3106 || itemid == 3110 || itemid == 4160 || itemid == 4162 || itemid == 4164 || itemid == 4154 || itemid == 4158 || itemid == 5224 || itemid == 5222 || itemid == 5232 || itemid == 5240 || itemid == 5248 || itemid == 5238 || itemid == 5256 || itemid == 7116 || itemid == 7108 || itemid == 7110 || itemid == 7128 || itemid == 7112 || itemid == 7114 || itemid == 7130) break;
										if (itemid == 242 || itemid == 1796 || itemid == 7188 || itemid == 9460 || itemid == 9468 || itemid == 10024 || itemid == 10028 || itemid == 7382 || itemid == 4762 || itemid == 6398 || itemid == 6426 || itemid == 6340 || itemid == 6342 || itemid == 6350 || itemid == 6818 || itemid == 8244 || itemid == 8242 || itemid == 8240 || itemid == 8452 || itemid == 8454 || itemid == 8488 || itemid == 8498 || itemid == 8474 || itemid == 8476 || itemid == 8492 || itemid == 1498 || itemid == 1500 || itemid == 2804 || itemid == 2806 || itemid == 8270 || itemid == 8272 || itemid == 8274 || itemid == 3172 || itemid == 8478 || itemid == 8480 || itemid == 8486 || itemid == 8484 || itemid == 8482 || itemid == 8468 || itemid == 8494 || itemid == 8466 || itemid == 8490 || itemid == 8456 || itemid == 8458 || itemid == 8496 || itemid == 8472 || itemid == 5482 || itemid == 2240 || itemid == 3204 || itemid == 6114 || itemid == 4328 || itemid == 4326 || itemid == 4330 || itemid == 4324 || itemid == 4334 || itemid == 1242 || itemid == 1244 || itemid == 1246 || itemid == 1248 || itemid == 1282 || itemid == 1284 || itemid == 1286 || itemid == 1290 || itemid == 1288 || itemid == 1292 || itemid == 1294 || itemid == 1256 || itemid == 2586 || itemid == 782 || itemid == 3536 || itemid == 764 || itemid == 4176 || itemid == 4322 || itemid == 4080 || itemid == 2992 || itemid == 2976 || itemid == 3790 || itemid == 4990 || itemid == 1506 || itemid == 1274 || itemid == 9000 || itemid == 1252 || itemid == 8284 || itemid == 8954 || itemid == 8534 || itemid == 1460 || itemid == 1462 || itemid == 1466 || itemid == 1464 || itemid == 2386 || itemid == 2392 || itemid == 2394 || itemid == 4414 || itemid == 4420 || itemid == 4428 || itemid == 4426 || itemid == 5662 || itemid == 5642 || itemid == 5654 || itemid == 5646 || itemid == 5650 || itemid == 7828 || itemid == 7832 || itemid == 7834 || itemid == 9322 || itemid == 9344 || itemid == 9326 || itemid == 9316 || itemid == 9318 || itemid == 362 || itemid == 3398 || itemid == 386 || itemid == 4422 || itemid == 364 || itemid == 9340 || itemid == 9342 || itemid == 9332 || itemid == 9334 || itemid == 9336 || itemid == 9338 || itemid == 366 || itemid == 2388 || itemid == 7808 || itemid == 7810 || itemid == 4416 || itemid == 7818 || itemid == 7820 || itemid == 5652 || itemid == 7822 || itemid == 7824 || itemid == 5644 || itemid == 390 || itemid == 7826 || itemid == 7830 || itemid == 9324 || itemid == 5658 || itemid == 3396 || itemid == 2384 || itemid == 5660 || itemid == 3400 || itemid == 4418 || itemid == 4412 || itemid == 388 || itemid == 3408 || itemid == 1470 || itemid == 3404 || itemid == 3406 || itemid == 2390 || itemid == 5656 || itemid == 5648 || itemid == 2396 || itemid == 384 || itemid == 5664 || itemid == 4424 || itemid == 4400 || itemid == 362 || itemid == 3398 || itemid == 386 || itemid == 392 || itemid == 4422 || itemid == 364 || itemid == 9340 || itemid == 9342 || itemid == 9332 || itemid == 9334 || itemid == 9336 || itemid == 9338 || itemid == 366 || itemid == 2388 || itemid == 7808 || itemid == 7810 || itemid == 4416 || itemid == 7818 || itemid == 7820 || itemid == 5652 || itemid == 7822 || itemid == 7824 || itemid == 5644 || itemid == 390 || itemid == 7826 || itemid == 7830 || itemid == 9324 || itemid == 5658 || itemid == 3396 || itemid == 2384 || itemid == 5660 || itemid == 3400 || itemid == 4418 || itemid == 4412 || itemid == 388 || itemid == 3408 || itemid == 1470 || itemid == 3404 || itemid == 3406 || itemid == 2390 || itemid == 5656 || itemid == 5648 || itemid == 2396 || itemid == 384 || itemid == 5664 || itemid == 4424 || itemid == 4400 || itemid == 1458 || itemid == 362 || itemid == 3398 || itemid == 386 || itemid == 4422 || itemid == 364 || itemid == 9340 || itemid == 9342 || itemid == 9332 || itemid == 9334 || itemid == 9336 || itemid == 9338 || itemid == 366 || itemid == 2388 || itemid == 7808 || itemid == 7810 || itemid == 4416 || itemid == 7818 || itemid == 7820 || itemid == 5652 || itemid == 7822 || itemid == 7824 || itemid == 5644 || itemid == 390 || itemid == 7826 || itemid == 7830 || itemid == 9324 || itemid == 5658 || itemid == 3396 || itemid == 2384 || itemid == 5660 || itemid == 3400 || itemid == 4418 || itemid == 4412 || itemid == 388 || itemid == 3408 || itemid == 1470 || itemid == 3404 || itemid == 3406 || itemid == 2390 || itemid == 5656 || itemid == 5648 || itemid == 2396 || itemid == 384 || itemid == 5664 || itemid == 4424 || itemid == 4400 || itemid == 1458 || itemid == 5040 || itemid == 5042 || itemid == 5044 || itemid == 3402 || itemid == 5032 || itemid == 5034 || itemid == 5036 || itemid == 5038 || itemid == 5018 || itemid == 5022 || itemid == 5060 || itemid == 5054 || itemid == 5058 || itemid == 5056 || itemid == 5050 || itemid == 5046 || itemid == 5052 || itemid == 5048 || itemid == 5070 || itemid == 5072 || itemid == 5074 || itemid == 5076 || itemid == 5066 || itemid == 5062 || itemid == 5068 || itemid == 5064 || itemid == 5080 || itemid == 5082 || itemid == 5084 || itemid == 5078 || itemid == 10236 || itemid == 10232 || itemid == 10194 || itemid == 10206 || itemid == 10184 || itemid == 10192 || itemid == 10190 || itemid == 10186 || itemid == 10212 || itemid == 10214 || itemid == 10216 || itemid == 10220 || itemid == 10222 || itemid == 10224 || itemid == 10226 || itemid == 10208 || itemid == 10210 || itemid == 10218 || itemid == 10196 || itemid == 10198 || itemid == 10200 || itemid == 10202 || itemid == 10204) break;

										ItemDefinition itemDef = getItemDef(itemID);
										if (getItemDef(itemID).blockType == BlockTypes::FOREGROUND || getItemDef(itemID).blockType == BlockTypes::BACKGROUND || getItemDef(itemID).blockType == BlockTypes::GROUND_BLOCK)
										{
											if (getItemDef(itemID).rarity <= 10)
											{
												realPrice = round(static_cast<float>(1 * converted_count) / 10);
											}
											else if (getItemDef(itemID).rarity <= 20)
											{
												realPrice = round(static_cast<float>(5 * converted_count) / 10);
											}
											else if (getItemDef(itemID).rarity <= 40)
											{
												realPrice = round(static_cast<float>(15 * converted_count) / 10);
											}
											else if (getItemDef(itemID).rarity <= 60)
											{
												realPrice = round(static_cast<float>(20 * converted_count) / 10);
											}
											else if (getItemDef(itemID).rarity <= 80)
											{
												realPrice = round(static_cast<float>(25 * converted_count) / 10);
											}
											else if (getItemDef(itemID).rarity <= 100)
											{
												realPrice = round(static_cast<float>(30 * converted_count) / 10);
											}
											else
											{
												realPrice = round(static_cast<float>(35 * converted_count) / 10);
											}
										}
										else if (getItemDef(itemID).rarity == 999 && getItemDef(itemID).name.find("Golden") != string::npos)
										{
											realPrice = 9000 * converted_count;
										}
										else if (getItemDef(itemID).rarity == 999 && getItemDef(itemID).name.find("Phoenix") != string::npos)
										{
											realPrice = 5000 * converted_count;
										}
										else if (getItemDef(itemID).rarity == 999 && getItemDef(itemID).name.find("Nightmare") != string::npos)
										{
											realPrice = 4000 * converted_count;
										}
										else if (itemDef.properties & Property_Untradable)
										{
											realPrice = 3000 * converted_count;
										}
										else if (getItemDef(itemID).blockType == BlockTypes::CLOTHING)
										{
											ifstream infile("pricedata.txt");
											for (string line; getline(infile, line);)
											{
												if (line.length() > 3 && line[0] != '/' && line[1] != '/')
												{
													auto ex = explode("|", line);
													if (ex[0] == to_string(itemID))
													{
														realPrice = atoi(ex[1].c_str()) * converted_count;
														break;
													}
												}
											}
										}
										else if (getItemDef(itemID).clothType == ClothTypes::BACK && getItemDef(itemID).rarity == 999)
										{
											realPrice = 900 * converted_count;
										}
										else if (getItemDef(itemID).rarity == 999)
										{
											realPrice = 600 * converted_count;
										}
										else
										{
											realPrice = round(static_cast<float>(round(static_cast<float>(getItemDef(itemID).rarity) * 5) * converted_count) / 10);
										}
										if (realPrice <= 0)
										{
											realPrice = 1;
											//Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`1You can't buy below the minimum!", 0, true);
											//break;
										}
										if (CheckItemMaxed(peer, itemID, converted_count))
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`1(Item maxed)", 0, true);
											break;
										}
										if (CheckItemExists(peer, itemID) == false)
										{
											if (static_cast<PlayerInfo*>(peer->data)->inventory.items.size() == static_cast<PlayerInfo*>(peer->data)->currentInventorySize)
											{
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`1(Inventory is full)", 0, true);
												break;
											}
										}

										if (itemID == 9644)
										{
											ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
											string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
											int b = atoi(content.c_str());
											if (b > 25000 * converted_count)
											{
												bool success = true;
												SaveItemMoreTimes(9644, converted_count, peer, success);
												if (!success)break;
												int gemcalc10k = b - 25000 * converted_count;
												ofstream myfile2;
												myfile2.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
												myfile2 << std::to_string(gemcalc10k);
												myfile2.close();
												ifstream ifszi("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
												string contentx((std::istreambuf_iterator<char>(ifszi)), (std::istreambuf_iterator<char>()));
												int updgem = atoi(contentx.c_str());
												Player::OnSetBux(peer, updgem, 0);
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`oYou have bought `$" + to_string(converted_count) + " " + getItemDef(itemID).name + " `ofor `$" + to_string(25000 * converted_count) + " Gems`o!", 0, true);
												ENetPeer* currentPeer;
												for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer)
												{
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
													if (isHere(peer, currentPeer))
													{
														SendTradeEffect(currentPeer, itemID, static_cast<PlayerInfo*>(peer->data)->netID, static_cast<PlayerInfo*>(peer->data)->netID, 150);
														Player::PlayAudio(currentPeer, "audio/cash_register.wav", 0);
													}
												}
											}
											else Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "You can't afford that many!", 0, true);
											break;
										}
										if (itemID == 9644) break; /*svarbu!*/

										if (itemID == 2204)
										{
											ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
											string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
											int b = atoi(content.c_str());
											if (b > 60000 * converted_count)
											{
												bool success = true;
												SaveItemMoreTimes(2204, converted_count, peer, success);
												if (!success)break;
												int gemcalc10k = b - 60000 * converted_count;
												ofstream myfile2;
												myfile2.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
												myfile2 << std::to_string(gemcalc10k);
												myfile2.close();
												ifstream ifszi("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
												string contentx((std::istreambuf_iterator<char>(ifszi)), (std::istreambuf_iterator<char>()));
												int updgem = atoi(contentx.c_str());
												Player::OnSetBux(peer, updgem, 0);
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`oYou have bought `$" + to_string(converted_count) + " " + getItemDef(itemID).name + " `ofor `$" + to_string(60000 * converted_count) + " Gems`o!", 0, true);
												ENetPeer* currentPeer;
												for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer)
												{
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
													if (isHere(peer, currentPeer))
													{
														SendTradeEffect(currentPeer, itemID, static_cast<PlayerInfo*>(peer->data)->netID, static_cast<PlayerInfo*>(peer->data)->netID, 150);
														Player::PlayAudio(currentPeer, "audio/cash_register.wav", 0);
													}
												}
											}
											else Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "You can't afford that many!", 0, true);
											break;
										}
										if (itemID == 2204) break; /*svarbu!*/

										if (CheckItemExists(peer, 242) == false && CheckItemExists(peer, 1796) == false)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`1You don't have wls and dls", 0, true);
											break;
										}

										auto worldlocks = 0;
										auto diamondlocks = 0;
										auto locks = 0;
										for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++)
										{
											if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 242)
											{
												worldlocks = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
											}
											if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 1796)
											{
												diamondlocks = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
											}
										}
										if (diamondlocks > 0)
										{
											locks = diamondlocks * 100;
										}
										locks += worldlocks;
										if (realPrice > locks)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "You can't afford that many!", 0, true);
											break;
										}
										else
										{
											float worldlockskaina = 0;
											int diamondlockkiek = 0;
											int worldlockkiek = 0;
											if (realPrice > 0) worldlockkiek = realPrice;
											int grazinti_wl = 0;
											if (worldlockkiek != 0)
											{
												auto iscontainseas = false;
												SearchInventoryItem(peer, 242, worldlockkiek, iscontainseas);
												if (!iscontainseas)
												{
													//cout << "nera wl " + to_string(worldlockkiek) << endl;
													diamondlockkiek += 1;
													grazinti_wl = 100 - worldlockkiek;
													while (grazinti_wl < 0)
													{
														if (grazinti_wl < 0)
														{
															//cout << "grazinti_wl buvo " + to_string(grazinti_wl) << endl;
															diamondlockkiek += 1;
															grazinti_wl = 100 + grazinti_wl;
														}
														else break;
													}
													worldlockkiek = 0;
												}
											}
											if (diamondlockkiek != 0)
											{
												auto iscontainseas3 = false;
												SearchInventoryItem(peer, 1796, diamondlockkiek, iscontainseas3);
												if (!iscontainseas3)
												{
													//cout << "nera dl " + to_string(diamondlockkiek) << endl;
													diamondlockkiek -= 1;
													worldlockkiek += 100;
												}
											}
											if (worldlockkiek == 0 && diamondlockkiek == 0)
											{
												if (realPrice == worldlocks)
												{
													worldlockkiek = worldlocks;
												}
											}
											auto iscontainseas = false;
											SearchInventoryItem(peer, 242, worldlockkiek, iscontainseas);
											if (!iscontainseas)
											{
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Uhm something went wrong...", 0, true);
												break;
											}
											if (worldlockkiek < 0 || diamondlockkiek < 0 || grazinti_wl < 0)
											{
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Uhm something went wrong...", 0, true);
												break;
											}
											if (worldlockkiek == 0 && diamondlockkiek == 0) break;
											//cout << "duoda wl: " + to_string(worldlockkiek) << endl;
											//cout << "duoda dl: " + to_string(diamondlockkiek) << endl;
											//cout << "grazina wl: " + to_string(grazinti_wl) << endl;
											bool success = true;
											if (worldlockkiek != 0)
											{
												RemoveInventoryItem(242, worldlockkiek, peer, true);
											}
											if (diamondlockkiek != 0)
											{
												RemoveInventoryItem(1796, diamondlockkiek, peer, true);
											}
											if (grazinti_wl != 0)
											{
												if (CheckItemMaxed(peer, 242, grazinti_wl))
												{
													if (grazinti_wl >= 100 && !CheckItemMaxed(peer, 1796, 1))
													{
														SaveItemMoreTimes(1796, 1, peer, success);
													}
												}
												else
												{
													SaveItemMoreTimes(242, grazinti_wl, peer, success);
												}
											}
											SaveItemMoreTimes(itemID, converted_count, peer, success);
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`oYou have bought `$" + to_string(converted_count) + " " + getItemDef(itemID).name + " `ofor `$" + to_string(realPrice) + " World Locks`o!", 0, true);
											ENetPeer* currentPeer;
											for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer)
											{
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
												if (isHere(peer, currentPeer))
												{
													SendTradeEffect(currentPeer, itemID, static_cast<PlayerInfo*>(peer->data)->netID, static_cast<PlayerInfo*>(peer->data)->netID, 150);
													Player::PlayAudio(currentPeer, "audio/cash_register.wav", 0);
												}
											}
										}

									}
								}
								if (vending_buy) {
									string v_buycount = static_cast<PlayerInfo*>(peer->data)->lastvendbuycount;
									static_cast<PlayerInfo*>(peer->data)->lastvendbuycount = "";
									if (v_buycount.size() > 3) break;
									int buy_count = atoi(v_buycount.c_str());
									int x = static_cast<PlayerInfo*>(peer->data)->lastPunchX;
									int y = static_cast<PlayerInfo*>(peer->data)->lastPunchY;
									if (world->items[x + (y * world->width)].foreground != 2978) break;
									auto realprice = world->items[x + (y * world->width)].vprice;
									auto kiekmoketi = buy_count * realprice;
									auto worldlocks = 0;
									auto diamondlocks = 0;
									auto locks = 0;
									for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++) {
										if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 242) {
											worldlocks = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
										}
										if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 1796) {
											diamondlocks = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
										}
									}
									if (diamondlocks > 0) locks = diamondlocks * 100;
									locks += worldlocks;
									if (kiekmoketi > locks && !world->items[x + (y * world->width)].opened) {
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "You can't afford that many!", 0, true);
										break;
									} else {
										if (CheckItemMaxed(peer, world->items[x + (y * world->width)].vid, buy_count) || buy_count > 250) {
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "That wouldnt fit into my inventory!", 0, true);
											break;
										}
										int yracount = world->items[x + (y * world->width)].vcount;
										int yrawithdraw = world->items[x + (y * world->width)].vdraw;
										if (yracount < buy_count || buy_count <= 0) {
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Out of order", 0, true);
											break;
										}
										if (world->items[x + (y * world->width)].opened) {
											if (buy_count < world->items[x + (y * world->width)].vprice) {
												Player::OnConsoleMessage(peer, "You have to buy at least 1 World Lock's worth.");
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "You have to buy at least 1 World Lock's worth.", 0, true);
												break;
											}
											int oldbuyprice = buyprice;
											buy_count = round(((double)buy_count / world->items[x + (y * world->width)].vprice));
											kiekmoketi = buy_count;
											buy_count *= world->items[x + (y * world->width)].vprice;
											if (buy_count > world->items[x + (y * world->width)].vcount) {
												buy_count = round(oldbuyprice / world->items[x + (y * world->width)].vprice);
												kiekmoketi = buy_count;
												buy_count *= world->items[x + (y * world->width)].vprice;
											}
											if (kiekmoketi > locks) {
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "You can't afford that many!", 0, true);
												break;
											}
										} 
										int diamond_lock = 0, world_lock = 0, grazinti_wl = 0;
										int is_viso_worldlock = kiekmoketi;
										while (is_viso_worldlock >= 100) {
											is_viso_worldlock -= 100;
											diamond_lock++;
										}
										world_lock = is_viso_worldlock;
										int turi_world_lock = atoi(GetItemCount(peer, 242).c_str());
										int turi_diamond_lock = atoi(GetItemCount(peer, 1796).c_str());
										while (diamond_lock > turi_diamond_lock && turi_world_lock >= 100) {
											turi_diamond_lock++;
											turi_world_lock -= 100;
										} if (diamond_lock > turi_diamond_lock) {
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "You can't afford that many!", 0, true);
											break;
										} while (world_lock > turi_world_lock && turi_diamond_lock >= 1) {
											turi_diamond_lock--;
											turi_world_lock += 100;
										} if (world_lock > turi_world_lock) {
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "You can't afford that many!", 0, true);
											break;
										}
										turi_world_lock -= world_lock;
										turi_diamond_lock -= diamond_lock;
										RemoveInventoryItem(242, atoi(GetItemCount(peer, 242).c_str()), peer, true);
										RemoveInventoryItem(1796, atoi(GetItemCount(peer, 1796).c_str()), peer, true);
										auto success = true;
										SaveItemMoreTimes(242, turi_world_lock, peer, success);
										SaveItemMoreTimes(1796, turi_diamond_lock, peer, success);
										world->items[x + (y * world->width)].vcount = world->items[x + (y * world->width)].vcount - buy_count;
										int buy_id = world->items[x + (y * world->width)].vid;
										if (world->items[x + (y * world->width)].vcount <= 0) {
											world->items[x + (y * world->width)].vcount = 0;
											world->items[x + (y * world->width)].vid = 0;
										}
										world->items[x + (y * world->width)].vdraw = world->items[x + (y * world->width)].vdraw + kiekmoketi;
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
											if (isHere(peer, currentPeer)) {
												Player::OnConsoleMessage(currentPeer, "`7[`9" + static_cast<PlayerInfo*>(peer->data)->displayName + " `9bought " + to_string(buy_count) + " " + getItemDef(buy_id).name + " for " + to_string(kiekmoketi) + " World Locks.`7]");
												SendTradeEffect(currentPeer, buy_id, static_cast<PlayerInfo*>(peer->data)->netID, static_cast<PlayerInfo*>(peer->data)->netID, 150);
												if (world->items[x + (y * world->width)].opened && world->items[x + (y * world->width)].vcount < world->items[x + (y * world->width)].vprice) {
													UpdateVend(currentPeer, x, y, 0, true, world->items[x + (y * world->width)].vprice, world->items[x + (y * world->width)].background, world->items[x + (y * world->width)].opened);
												}
												else UpdateVend(currentPeer, x, y, world->items[x + (y * world->width)].vid, true, world->items[x + (y * world->width)].vprice, world->items[x + (y * world->width)].background, world->items[x + (y * world->width)].opened);
												Player::PlayAudio(currentPeer, "audio/cash_register.wav", 0);
											}
										}
										SaveItemMoreTimes(buy_id, buy_count, peer, success);
									}
									break;
								}
								if (isGrowScanDialog) {
									if (infoDat[0] == "isStatsWorldBlockUsableByPublic") {
										int x = static_cast<PlayerInfo*>(peer->data)->lastPunchX;
										int y = static_cast<PlayerInfo*>(peer->data)->lastPunchY;
										if (infoDat[1] == "1") {
											world->items[x + (y * world->width)].opened = true;
										} else if (infoDat[1] == "0") {
											world->items[x + (y * world->width)].opened = false;
										}
									} if (infoDat[0] == "isStatsFloatingItemsUsableByPublic") {
										int x = static_cast<PlayerInfo*>(peer->data)->lastPunchX;
										int y = static_cast<PlayerInfo*>(peer->data)->lastPunchY;
										if (infoDat[1] == "1") {
											world->items[x + (y * world->width)].rm = true;
										} else if (infoDat[1] == "0") {
											world->items[x + (y * world->width)].rm = false;
										}
									} if (btn.substr(0, 9) == "findTile_") {
										sendArrow(peer, atoi(btn.substr(9, btn.length() - 9).c_str()), false);
									} if (btn.substr(0, 11) == "findObject_") {
										sendArrow(peer, atoi(btn.substr(11, btn.length() - 11).c_str()), true);
									} if (infoDat[1] == "backToStatsBlock") {
										SendGScan(peer, world, static_cast<PlayerInfo*>(peer->data)->lastPunchX, static_cast<PlayerInfo*>(peer->data)->lastPunchY);
									} if (infoDat[1] == "worldBlocks" || infoDat[1] == "backToWorldBlocks") {
										int total_blocks = 0;
										int total_backgrounds = 0;
										int total_untradeable = 0;
										int total_rare = 0;
										int total_rarity = 0;
										int total_fire = 0;
										int total_water = 0;
										int total_earth = 0;
										int total_air = 0;
										for (int i = 0; i < world->width * world->height; i++) {
											if (world->items[i].foreground != 0) total_blocks++;
											if (world->items[i].background != 0 && world->items[i].background != 6864) total_backgrounds++;
											if (world->items[i].foreground != 0 && getItemDef(world->items[i].foreground).properties & Property_Untradable || world->items[i].background != 0 && world->items[i].background != 6864 && getItemDef(world->items[i].background).properties & Property_Untradable) total_untradeable++;
											if (world->items[i].foreground != 0 && getItemDef(world->items[i].foreground).rarity == 999 || world->items[i].background != 0 && world->items[i].background != 6864 && getItemDef(world->items[i].background).rarity == 999) total_rare++;
											if (world->items[i].foreground != 0 && getItemDef(world->items[i].foreground).rarity != 999) total_rarity += getItemDef(world->items[i].foreground).rarity;
											if (world->items[i].foreground != 0 && getItemDef(world->items[i].foreground).blockType == BlockTypes::PAIN_BLOCK) total_fire++;
											else if (world->items[i].foreground != 0 && world->items[i].foreground == 5034 || world->items[i].foreground == 5048 || world->items[i].foreground == 7520 || world->items[i].foreground == 7522 || world->items[i].foreground == 7772 || world->items[i].foreground == 7774 || world->items[i].foreground == 8240 || world->items[i].foreground == 3506 || world->items[i].foreground == 3584) total_water++;
											else if (world->items[i].foreground != 0 && getItemDef(world->items[i].foreground).blockType == BlockTypes::FOREGROUND && world->items[i].foreground != 5034 && world->items[i].foreground != 5048 && world->items[i].foreground != 7520 && world->items[i].foreground != 7522 && world->items[i].foreground != 7772 && world->items[i].foreground != 7774 && world->items[i].foreground != 2794 || world->items[i].foreground != 2796 || world->items[i].foreground != 2810 && world->items[i].foreground != 8240 && world->items[i].foreground != 3506 && world->items[i].foreground != 3584) total_earth++;
											else if (world->items[i].foreground != 0 && world->items[i].foreground == 2794 || world->items[i].foreground == 2796 || world->items[i].foreground == 2810) total_air++;
										}
										Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wWorld Blocks``|left|6016|\nadd_spacer|small|\nadd_label|small|`wThis world contains|left\nadd_textbox|`wBlocks: " + to_string(total_blocks) + "``|\nadd_textbox|`wBackgrounds: " + to_string(total_backgrounds) + "``|\nadd_textbox|`wUntradeable blocks: " + to_string(total_untradeable) + "``|left|\nadd_textbox|`wSuper rare items: " + to_string(total_rare) + "|left|\nadd_textbox|`wTotal block rarity: " + to_string(total_rarity) + "``|left|\nadd_label_with_icon|small|`wFire: " + to_string(total_fire) + "|left|6020|\nadd_label_with_icon|small|`wWater: " + to_string(total_water) + "|left|6024|\nadd_label_with_icon|small|`wEarth: " + to_string(total_earth) + "|left|6018|\nadd_label_with_icon|small|`wAir: " + to_string(total_air) + "|left|6022|\nadd_spacer|small|\nadd_text_input|searchName|Search by Name||100|\nadd_button|searchInWorldBlocks|Search All|noflags|0|0|\nadd_smalltext|`5Or filter search by type``|left|\nadd_button|blockInWorldBlocks|Search Blocks|noflags|0|0|\nadd_button|backgroundInWorldBlocks|Search Backgrounds|noflags|0|0|\nadd_button|untradableInWorldBlocks|Search Untradeable|noflags|0|0|\nadd_spacer|small|\nadd_button|backToStatsBlock|Back|noflags|0|0|\nend_dialog|statsblock|||");
										break;
									} if (infoDat[1] == "untradableInWorldBlocks") {
										string additems = "";
										vector<string> scanned_items;
										for (int i = 0; i < world->width * world->height; i++) {
											if (world->items[i].foreground != 0) {
												if (scanned_items.size() != 0) {
													if (find(scanned_items.begin(), scanned_items.end(), to_string(world->items[i].foreground)) != scanned_items.end()) continue;
												}
												if (getItemDef(world->items[i].foreground).properties & Property_Untradable) {
													scanned_items.push_back(to_string(world->items[i].foreground));
													int count = 0;
													for (int iss = 0; iss < world->width * world->height; iss++) {
														if (world->items[iss].foreground == world->items[i].foreground) count++;
													}
													additems += "" + to_string(world->items[i].foreground) + "," + to_string(count) + ",";
												}
											} 
										}
										if (additems == "") Player::OnDialogRequest(peer, "\nset_default_color|`o\nadd_label_with_icon|big|`wWorld Blocks``|left|6016|\nadd_spacer|small|\nadd_textbox|No blocks found.|left|\nadd_spacer|small|\nadd_button|backToWorldBlocks|Back|noflags|0|0|\nend_dialog|statsblock|||");
										else Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wWorld Blocks``|left|6016|\nadd_spacer|small|\nadd_textbox|Press on the icon to be directed to the location of the item.|left|\nadd_spacer|small|\nadd_label_with_icon_button_list|small|`w%s : %s|left|findTile_|itemIDseed2tree_itemAmount|" + additems + "\nadd_spacer|small|\nadd_button|backToWorldBlocks|Back|noflags|0|0|\nend_dialog|statsblock|||");
									} if (infoDat[1] == "backgroundInWorldBlocks") {
										string additems = "";
										vector<string> scanned_items;
										for (int i = 0; i < world->width * world->height; i++) {
											if (world->items[i].background != 0 && world->items[i].background != 6864) {
												if (scanned_items.size() != 0) {
													if (find(scanned_items.begin(), scanned_items.end(), to_string(world->items[i].background)) != scanned_items.end()) continue;
												}
												scanned_items.push_back(to_string(world->items[i].background));
												int count = 0;
												for (int iss = 0; iss < world->width * world->height; iss++) {
													if (world->items[iss].background == world->items[i].background) count++;
												}
												additems += "" + to_string(world->items[i].background) + "," + to_string(count) + ",";
											} 
										}
										if (additems == "") Player::OnDialogRequest(peer, "\nset_default_color|`o\nadd_label_with_icon|big|`wWorld Blocks``|left|6016|\nadd_spacer|small|\nadd_textbox|No blocks found.|left|\nadd_spacer|small|\nadd_button|backToWorldBlocks|Back|noflags|0|0|\nend_dialog|statsblock|||");
										else Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wWorld Blocks``|left|6016|\nadd_spacer|small|\nadd_textbox|Press on the icon to be directed to the location of the item.|left|\nadd_spacer|small|\nadd_label_with_icon_button_list|small|`w%s : %s|left|findTile_|itemIDseed2tree_itemAmount|" + additems + "\nadd_spacer|small|\nadd_button|backToWorldBlocks|Back|noflags|0|0|\nend_dialog|statsblock|||");
									} if (infoDat[1] == "blockInWorldBlocks") {
										string additems = "";
										vector<string> scanned_items;
										for (int i = 0; i < world->width * world->height; i++) {
											if (world->items[i].foreground != 0) {
												if (scanned_items.size() != 0) {
													if (find(scanned_items.begin(), scanned_items.end(), to_string(world->items[i].foreground)) != scanned_items.end()) continue;
												}
												if (getItemDef(world->items[i].foreground).blockType == BlockTypes::FOREGROUND || getItemDef(world->items[i].foreground).blockType == BlockTypes::BACKGROUND || getItemDef(world->items[i].foreground).blockType == BlockTypes::SFX_FOREGROUND || getItemDef(world->items[i].foreground).blockType == BlockTypes::BEDROCK || getItemDef(world->items[i].foreground).blockType == BlockTypes::PAIN_BLOCK) {
													scanned_items.push_back(to_string(world->items[i].foreground));
													int count = 0;
													for (int iss = 0; iss < world->width * world->height; iss++) {
														if (world->items[iss].foreground == world->items[i].foreground) count++;
													}
													additems += "" + to_string(world->items[i].foreground) + "," + to_string(count) + ",";
												}
											} 
										}
										if (additems == "") Player::OnDialogRequest(peer, "\nset_default_color|`o\nadd_label_with_icon|big|`wWorld Blocks``|left|6016|\nadd_spacer|small|\nadd_textbox|No blocks found.|left|\nadd_spacer|small|\nadd_button|backToWorldBlocks|Back|noflags|0|0|\nend_dialog|statsblock|||");
										else Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wWorld Blocks``|left|6016|\nadd_spacer|small|\nadd_textbox|Press on the icon to be directed to the location of the item.|left|\nadd_spacer|small|\nadd_label_with_icon_button_list|small|`w%s : %s|left|findTile_|itemIDseed2tree_itemAmount|" + additems + "\nadd_spacer|small|\nadd_button|backToWorldBlocks|Back|noflags|0|0|\nend_dialog|statsblock|||");
									} if (infoDat[1] == "searchInWorldBlocks") {
										string additems = "";
										vector<string> scanned_items;
										for (int i = 0; i < world->width * world->height; i++) {
											if (world->items[i].foreground != 0) {
												if (scanned_items.size() != 0) {
													if (find(scanned_items.begin(), scanned_items.end(), to_string(world->items[i].foreground)) != scanned_items.end()) continue;
												}
												scanned_items.push_back(to_string(world->items[i].foreground));
												int count = 0;
												for (int iss = 0; iss < world->width * world->height; iss++) {
													if (world->items[iss].foreground == world->items[i].foreground) count++;
												}
												additems += "" + to_string(world->items[i].foreground) + "," + to_string(count) + ",";
											} 
											if (world->items[i].background != 0 && world->items[i].background != 6864) {
												if (scanned_items.size() != 0) {
													if (find(scanned_items.begin(), scanned_items.end(), to_string(world->items[i].background)) != scanned_items.end()) continue;
												}
												scanned_items.push_back(to_string(world->items[i].background));
												int count = 0;
												for (int iss = 0; iss < world->width * world->height; iss++) {
													if (world->items[iss].background == world->items[i].background) count++;
												}
												additems += "" + to_string(world->items[i].background) + "," + to_string(count) + ",";
											} 
										}
										if (additems == "") Player::OnDialogRequest(peer, "\nset_default_color|`o\nadd_label_with_icon|big|`wWorld Blocks``|left|6016|\nadd_spacer|small|\nadd_textbox|No blocks found.|left|\nadd_spacer|small|\nadd_button|backToWorldBlocks|Back|noflags|0|0|\nend_dialog|statsblock|||");
										else Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wWorld Blocks``|left|6016|\nadd_spacer|small|\nadd_textbox|Press on the icon to be directed to the location of the item.|left|\nadd_spacer|small|\nadd_label_with_icon_button_list|small|`w%s : %s|left|findTile_|itemIDseed2tree_itemAmount|" + additems + "\nadd_spacer|small|\nadd_button|backToWorldBlocks|Back|noflags|0|0|\nend_dialog|statsblock|||");
									} if (infoDat[1] == "floatingItems" || infoDat[1] == "backToFloatingItems") {
										int totalitems_withcount = 0;
										int totalitems_rarity = 0;
										int totalitems_super = 0;
										int total_gems = 0;
										vector<string> scanned_items;
										for (int i = 0; i < world->droppedItems.size(); i++) {
											int id = world->droppedItems.at(i).id;
											if (scanned_items.size() != 0) {
												if (find(scanned_items.begin(), scanned_items.end(), to_string(id)) != scanned_items.end()) continue;
											}
											scanned_items.push_back(to_string(id));
											int count = 0;
											for (int is = 0; is < world->droppedItems.size(); is++) {
												if (world->droppedItems.at(is).id == id) {
													if (world->droppedItems.at(is).id == 112) total_gems += world->droppedItems.at(is).count;
													count += world->droppedItems.at(is).count;
													totalitems_withcount +=	world->droppedItems.at(is).count;
													if (getItemDef(world->droppedItems.at(is).id).rarity != 999) totalitems_rarity += getItemDef(world->droppedItems.at(is).id).rarity * world->droppedItems.at(is).count;
													if (getItemDef(world->droppedItems.at(is).id).rarity == 999 && world->droppedItems.at(is).id != 112) {
														totalitems_super += world->droppedItems.at(is).count;
													}
												}
											}
										}
										Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wFloating Items``|left|6016|\nadd_spacer|small|\nadd_textbox|`wTotal number in world: " + to_string(totalitems_withcount) + "|left\nadd_textbox|`wTotal floating item rarity: " + to_string(totalitems_rarity) + "|left|\nadd_textbox|`wTotal super rare items: " + to_string(totalitems_super) + "|left|\nadd_textbox|`wTotal gems: " + to_string(total_gems) + "|left|\nadd_spacer|small|\nadd_text_input|searchName|Search by Name||100|\nadd_button|searchInFloatingItems|Search All|noflags|0|0|\nadd_smalltext|`5Or filter search by type``|left|\nadd_button|filterByClothingInFloatingItems|Search Clothing|noflags|0|0|\nadd_button|filterByConsumablesInFloatingItems|Search Consumables|noflags|0|0|\nadd_button|filterByBlocksInFloatingItems|Search Blocks and Backgrounds|noflags|0|0|\nadd_button|filterBySeedsInFloatingItems|Search Seeds|noflags|0|0|\nadd_button|filterByLocksInFloatingItems|Search Locks|noflags|0|0|\nadd_button|filterByOthersInFloatingItems|Search Others|noflags|0|0|\nadd_spacer|small|\nadd_button|backToStatsBlock|Back|noflags|0|0|\nend_dialog|statsblock|||");
										break;
									} if (infoDat[1] == "filterByOthersInFloatingItems") {
										string additems = "";
										int totalfloatinggems = 0;
										vector<string> scanned_items;
										for (int i = 0; i < world->droppedItems.size(); i++) {
											int id = world->droppedItems.at(i).id;
											if (getItemDef(id).blockType != BlockTypes::CONSUMABLE && getItemDef(id).blockType != BlockTypes::CLOTHING && getItemDef(id).blockType != BlockTypes::LOCK && getItemDef(id).blockType != BlockTypes::SEED && getItemDef(id).blockType != BlockTypes::FOREGROUND && getItemDef(id).blockType != BlockTypes::BACKGROUND && getItemDef(id).blockType != BlockTypes::SFX_FOREGROUND && getItemDef(id).blockType != BlockTypes::BEDROCK && getItemDef(id).blockType != BlockTypes::PAIN_BLOCK) {
												if (scanned_items.size() != 0) {
													if (find(scanned_items.begin(), scanned_items.end(), to_string(id)) != scanned_items.end()) continue;
												}
												scanned_items.push_back(to_string(id));
												int count = 0;
												for (int is = 0; is < world->droppedItems.size(); is++) {
													if (world->droppedItems.at(is).id == id) {
														count += world->droppedItems.at(is).count;
													}
												}
												additems += "" + to_string(id) + "," + to_string(count) + ",";
											}
										}
										if (additems == "") Player::OnDialogRequest(peer, "\nset_default_color|`o\nadd_label_with_icon|big|`wFloating Items``|left|6016|\nadd_spacer|small|\nadd_textbox|No items found.|left|\nadd_spacer|small|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nend_dialog|statsblock|||");
										else Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wFloating Items``|left|6016|\nadd_spacer|small|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nadd_quick_exit|\nadd_textbox|`wItem List(" + to_string(scanned_items.size()) + "):|left|\nadd_textbox|Press on the icon to be directed to the location of the item.|left|\nadd_spacer|small|\nadd_label_with_icon_button_list|small|`w%s : %s|left|findObject_|itemID_itemAmount|" + additems + "\nadd_spacer|small|\nadd_textbox|`wItem List(" + to_string(scanned_items.size()) + "):|left|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nend_dialog|statsblock|||");
										break;
									} if (infoDat[1] == "filterByLocksInFloatingItems") {
										string additems = "";
										int totalfloatinggems = 0;
										vector<string> scanned_items;
										for (int i = 0; i < world->droppedItems.size(); i++) {
											int id = world->droppedItems.at(i).id;
											if (getItemDef(id).blockType == BlockTypes::LOCK) {
												if (scanned_items.size() != 0) {
													if (find(scanned_items.begin(), scanned_items.end(), to_string(id)) != scanned_items.end()) continue;
												}
												scanned_items.push_back(to_string(id));
												int count = 0;
												for (int is = 0; is < world->droppedItems.size(); is++) {
													if (world->droppedItems.at(is).id == id) {
														count += world->droppedItems.at(is).count;
													}
												}
												additems += "" + to_string(id) + "," + to_string(count) + ",";
											}
										}
										if (additems == "") Player::OnDialogRequest(peer, "\nset_default_color|`o\nadd_label_with_icon|big|`wFloating Items``|left|6016|\nadd_spacer|small|\nadd_textbox|No items found.|left|\nadd_spacer|small|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nend_dialog|statsblock|||");
										else Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wFloating Items``|left|6016|\nadd_spacer|small|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nadd_quick_exit|\nadd_textbox|`wItem List(" + to_string(scanned_items.size()) + "):|left|\nadd_textbox|Press on the icon to be directed to the location of the item.|left|\nadd_spacer|small|\nadd_label_with_icon_button_list|small|`w%s : %s|left|findObject_|itemID_itemAmount|" + additems + "\nadd_spacer|small|\nadd_textbox|`wItem List(" + to_string(scanned_items.size()) + "):|left|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nend_dialog|statsblock|||");
										break;
									} if (infoDat[1] == "filterBySeedsInFloatingItems") {
										string additems = "";
										int totalfloatinggems = 0;
										vector<string> scanned_items;
										for (int i = 0; i < world->droppedItems.size(); i++) {
											int id = world->droppedItems.at(i).id;
											if (getItemDef(id).blockType == BlockTypes::SEED) {
												if (scanned_items.size() != 0) {
													if (find(scanned_items.begin(), scanned_items.end(), to_string(id)) != scanned_items.end()) continue;
												}
												scanned_items.push_back(to_string(id));
												int count = 0;
												for (int is = 0; is < world->droppedItems.size(); is++) {
													if (world->droppedItems.at(is).id == id) {
														count += world->droppedItems.at(is).count;
													}
												}
												additems += "" + to_string(id) + "," + to_string(count) + ",";
											}
										}
										if (additems == "") Player::OnDialogRequest(peer, "\nset_default_color|`o\nadd_label_with_icon|big|`wFloating Items``|left|6016|\nadd_spacer|small|\nadd_textbox|No items found.|left|\nadd_spacer|small|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nend_dialog|statsblock|||");
										else Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wFloating Items``|left|6016|\nadd_spacer|small|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nadd_quick_exit|\nadd_textbox|`wItem List(" + to_string(scanned_items.size()) + "):|left|\nadd_textbox|Press on the icon to be directed to the location of the item.|left|\nadd_spacer|small|\nadd_label_with_icon_button_list|small|`w%s : %s|left|findObject_|itemID_itemAmount|" + additems + "\nadd_spacer|small|\nadd_textbox|`wItem List(" + to_string(scanned_items.size()) + "):|left|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nend_dialog|statsblock|||");
										break;
									} if (infoDat[1] == "filterByBlocksInFloatingItems") {
										string additems = "";
										int totalfloatinggems = 0;
										vector<string> scanned_items;
										for (int i = 0; i < world->droppedItems.size(); i++) {
											int id = world->droppedItems.at(i).id;
											if (getItemDef(id).blockType == BlockTypes::FOREGROUND || getItemDef(id).blockType == BlockTypes::BACKGROUND || getItemDef(id).blockType == BlockTypes::SFX_FOREGROUND || getItemDef(id).blockType == BlockTypes::BEDROCK || getItemDef(id).blockType == BlockTypes::PAIN_BLOCK) {
												if (scanned_items.size() != 0) {
													if (find(scanned_items.begin(), scanned_items.end(), to_string(id)) != scanned_items.end()) continue;
												}
												scanned_items.push_back(to_string(id));
												int count = 0;
												for (int is = 0; is < world->droppedItems.size(); is++) {
													if (world->droppedItems.at(is).id == id) {
														count += world->droppedItems.at(is).count;
													}
												}
												additems += "" + to_string(id) + "," + to_string(count) + ",";
											}
										}
										if (additems == "") Player::OnDialogRequest(peer, "\nset_default_color|`o\nadd_label_with_icon|big|`wFloating Items``|left|6016|\nadd_spacer|small|\nadd_textbox|No items found.|left|\nadd_spacer|small|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nend_dialog|statsblock|||");
										else Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wFloating Items``|left|6016|\nadd_spacer|small|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nadd_quick_exit|\nadd_textbox|`wItem List(" + to_string(scanned_items.size()) + "):|left|\nadd_textbox|Press on the icon to be directed to the location of the item.|left|\nadd_spacer|small|\nadd_label_with_icon_button_list|small|`w%s : %s|left|findObject_|itemID_itemAmount|" + additems + "\nadd_spacer|small|\nadd_textbox|`wItem List(" + to_string(scanned_items.size()) + "):|left|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nend_dialog|statsblock|||");
										break;
									} if (infoDat[1] == "filterByClothingInFloatingItems") {
										string additems = "";
										int totalfloatinggems = 0;
										vector<string> scanned_items;
										for (int i = 0; i < world->droppedItems.size(); i++) {
											int id = world->droppedItems.at(i).id;
											if (getItemDef(id).blockType == BlockTypes::CLOTHING) {
												if (scanned_items.size() != 0) {
													if (find(scanned_items.begin(), scanned_items.end(), to_string(id)) != scanned_items.end()) continue;
												}
												scanned_items.push_back(to_string(id));
												int count = 0;
												for (int is = 0; is < world->droppedItems.size(); is++) {
													if (world->droppedItems.at(is).id == id) {
														count += world->droppedItems.at(is).count;
													}
												}
												additems += "" + to_string(id) + "," + to_string(count) + ",";
											}
										}
										if (additems == "") Player::OnDialogRequest(peer, "\nset_default_color|`o\nadd_label_with_icon|big|`wFloating Items``|left|6016|\nadd_spacer|small|\nadd_textbox|No items found.|left|\nadd_spacer|small|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nend_dialog|statsblock|||");
										else Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wFloating Items``|left|6016|\nadd_spacer|small|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nadd_quick_exit|\nadd_textbox|`wItem List(" + to_string(scanned_items.size()) + "):|left|\nadd_textbox|Press on the icon to be directed to the location of the item.|left|\nadd_spacer|small|\nadd_label_with_icon_button_list|small|`w%s : %s|left|findObject_|itemID_itemAmount|" + additems + "\nadd_spacer|small|\nadd_textbox|`wItem List(" + to_string(scanned_items.size()) + "):|left|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nend_dialog|statsblock|||");
										break;
									} if (infoDat[1] == "filterByConsumablesInFloatingItems") {
										string additems = "";
										int totalfloatinggems = 0;
										vector<string> scanned_items;
										for (int i = 0; i < world->droppedItems.size(); i++) {
											int id = world->droppedItems.at(i).id;
											if (getItemDef(id).blockType == BlockTypes::CONSUMABLE) {
												if (scanned_items.size() != 0) {
													if (find(scanned_items.begin(), scanned_items.end(), to_string(id)) != scanned_items.end()) continue;
												}
												scanned_items.push_back(to_string(id));
												int count = 0;
												for (int is = 0; is < world->droppedItems.size(); is++) {
													if (world->droppedItems.at(is).id == id) {
														count += world->droppedItems.at(is).count;
													}
												}
												additems += "" + to_string(id) + "," + to_string(count) + ",";
											}
										}
										if (additems == "") Player::OnDialogRequest(peer, "\nset_default_color|`o\nadd_label_with_icon|big|`wFloating Items``|left|6016|\nadd_spacer|small|\nadd_textbox|No items found.|left|\nadd_spacer|small|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nend_dialog|statsblock|||");
										else Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wFloating Items``|left|6016|\nadd_spacer|small|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nadd_quick_exit|\nadd_textbox|`wItem List(" + to_string(scanned_items.size()) + "):|left|\nadd_textbox|Press on the icon to be directed to the location of the item.|left|\nadd_spacer|small|\nadd_label_with_icon_button_list|small|`w%s : %s|left|findObject_|itemID_itemAmount|" + additems + "\nadd_spacer|small|\nadd_textbox|`wItem List(" + to_string(scanned_items.size()) + "):|left|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nend_dialog|statsblock|||");
										break;
									} if (infoDat[1] == "searchInFloatingItems") {
										string additems = "";
										int totalfloatinggems = 0;
										vector<string> scanned_items;
										for (int i = 0; i < world->droppedItems.size(); i++) {
											int id = world->droppedItems.at(i).id;
											if (scanned_items.size() != 0) {
												if (find(scanned_items.begin(), scanned_items.end(), to_string(id)) != scanned_items.end()) continue;
											}
											scanned_items.push_back(to_string(id));
											int count = 0;
											for (int is = 0; is < world->droppedItems.size(); is++) {
												if (world->droppedItems.at(is).id == id) {
													count += world->droppedItems.at(is).count;
												}
											}
											additems += "" + to_string(id) + "," + to_string(count) + ",";
										}
										if (additems == "") Player::OnDialogRequest(peer, "\nset_default_color|`o\nadd_label_with_icon|big|`wFloating Items``|left|6016|\nadd_spacer|small|\nadd_textbox|No items found.|left|\nadd_spacer|small|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nend_dialog|statsblock|||");
										else Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wFloating Items``|left|6016|\nadd_spacer|small|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nadd_quick_exit|\nadd_textbox|`wItem List(" + to_string(scanned_items.size()) + "):|left|\nadd_textbox|Press on the icon to be directed to the location of the item.|left|\nadd_spacer|small|\nadd_label_with_icon_button_list|small|`w%s : %s|left|findObject_|itemID_itemAmount|" + additems + "\nadd_spacer|small|\nadd_textbox|`wItem List(" + to_string(scanned_items.size()) + "):|left|\nadd_button|backToFloatingItems|Back|noflags|0|0|\nend_dialog|statsblock|||");
										break;
									}
								}
								if (isSongDialog) {
									if (infoDat[0] == "checkbox_ahrix") {
										if (infoDat[1] == "1") {
											Player::OnConsoleMessage(peer, "Playing now `$Ahrix Nova");
											Player::PlayAudio(peer, "audio/ogg/ahrix_nova.ogg", 0);
											break;
										}
									} if (infoDat[0] == "checkbox_phut") {
										if (infoDat[1] == "1") {
											Player::OnConsoleMessage(peer, "Playing now `$Phut Hon");
											Player::PlayAudio(peer, "audio/ogg/phut_hon.ogg", 0);
											break;
										}
									} if (infoDat[0] == "checkbox_stopme") {
										if (infoDat[1] == "1") {
											Player::OnConsoleMessage(peer, "Playing now `$Dont't stop me now");
											Player::PlayAudio(peer, "audio/ogg/dont_stop_me_now.ogg", 0);
											break;
										}
									} if (infoDat[0] == "checkbox_feelit") {
										if (infoDat[1] == "1") {
											Player::OnConsoleMessage(peer, "Playing now `$Can you feel it");
											Player::PlayAudio(peer, "audio/ogg/feel_it.ogg", 0);
											break;
										}
									} if (infoDat[0] == "checkbox_sayso") {
										if (infoDat[1] == "1") {
											Player::OnConsoleMessage(peer, "Playing now `$Say so");
											Player::PlayAudio(peer, "audio/ogg/say_so.ogg", 0);
											break;
										}
									} if (infoDat[0] == "checkbox_bealone") {
										if (infoDat[1] == "1") {
											Player::OnConsoleMessage(peer, "Playing now `$Never be alone");
											Player::PlayAudio(peer, "audio/ogg/be_alone.ogg", 0);
											break;
										}
									}
								}
								if (isRolesDialog) {
									if (infoDat[1] == "back") {
										int firefighterxp = 1500;
										if (static_cast<PlayerInfo*>(peer->data)->firefighterlevel > 0) firefighterxp = firefighterxp * static_cast<PlayerInfo*>(peer->data)->firefighterlevel;
										if (static_cast<PlayerInfo*>(peer->data)->firefighterlevel == 0) firefighterxp = 750;
										int providerxp = 1300;
										if (static_cast<PlayerInfo*>(peer->data)->providerlevel > 0) providerxp = providerxp * static_cast<PlayerInfo*>(peer->data)->providerlevel;
										if (static_cast<PlayerInfo*>(peer->data)->providerlevel == 0) providerxp = 600;
										int geigerxp = 600;
										if (static_cast<PlayerInfo*>(peer->data)->geigerlevel > 0) geigerxp = geigerxp * static_cast<PlayerInfo*>(peer->data)->geigerlevel;
										if (static_cast<PlayerInfo*>(peer->data)->geigerlevel == 0) geigerxp = 350;
										int fishermanxp = 1600;
										if (static_cast<PlayerInfo*>(peer->data)->fishermanlevel > 0) fishermanxp = fishermanxp * static_cast<PlayerInfo*>(peer->data)->fishermanlevel;
										if (static_cast<PlayerInfo*>(peer->data)->fishermanlevel == 0) fishermanxp = 900;
										Player::OnDialogRequest(peer, "add_label_with_icon|big|`wRole Stats``|left|982|\nadd_spacer|small|\nadd_textbox|`9What prizes and powers have you unlocked in your Roles and what's left to discover? Find out here!``|left|\nadd_spacer|small|\nadd_player_info|Firefighter|" + to_string(static_cast<PlayerInfo*>(peer->data)->firefighterlevel) + "|" + to_string(static_cast<PlayerInfo*>(peer->data)->firefighterxp) + "|" + to_string(firefighterxp) + "|\nadd_spacer|small|\nadd_button|viewFirefighter|`0View Firefighter Rewards``|noflags|0|0|\nadd_spacer|small|\nadd_player_info|Provider|" + to_string(static_cast<PlayerInfo*>(peer->data)->providerlevel) + "|" + to_string(static_cast<PlayerInfo*>(peer->data)->providerxp) + "|" + to_string(providerxp) + "|\nadd_spacer|small|\nadd_button|viewProvider|`0View Provider Rewards``|noflags|0|0|\nadd_spacer|small|\nadd_player_info|Geiger Hunter|" + to_string(static_cast<PlayerInfo*>(peer->data)->geigerlevel) + "|" + to_string(static_cast<PlayerInfo*>(peer->data)->geigerxp) + "|" + to_string(geigerxp) + "|\nadd_spacer|small|\nadd_button|viewGeiger|`0View Geiger Hunter Rewards``|noflags|0|0|\nadd_spacer|small|\nadd_player_info|Fisherman|" + to_string(static_cast<PlayerInfo*>(peer->data)->fishermanlevel) + "|" + to_string(static_cast<PlayerInfo*>(peer->data)->fishermanxp) + "|" + to_string(fishermanxp) + "|\nadd_spacer|small|\nadd_button|viewFisherman|`0View Fisherman Rewards``|noflags|0|0|\nadd_spacer|small|\nadd_button|back|Back|noflags|0|0|\nend_dialog|mainwrenchpage|||\nadd_quick_exit|");
										break;
									}
								}
								if (isWrenchDialog) {
									if (infoDat[1] == "back") {
										if (static_cast<PlayerInfo*>(peer->data)->haveGrowId == true) {
											string buffs;
											if (isPickaxe(peer))
											{
												buffs += "|\nadd_label_with_icon|small|`wEnchanced Digging``|left|" + to_string(static_cast<PlayerInfo*>(peer->data)->cloth_hand) + "|";
											}
											if (static_cast<PlayerInfo*>(peer->data)->SurgeryCooldown)
											{
												buffs += "|\nadd_label_with_icon|small|`wMalpractice`` (`w" + OutputBanTime(calcBanDuration(static_cast<PlayerInfo*>(peer->data)->SurgeryTime)) + " left`o)|left|1260|";
											}
											if (static_cast<PlayerInfo*>(peer->data)->Subscriber)
											{
												buffs += "|\nadd_label_with_icon|small|`wPremium Benefits `o(`w" + to_string(static_cast<PlayerInfo*>(peer->data)->SubscribtionEndDay) + " days `oleft)``|left|6862|";
											}
											if (static_cast<PlayerInfo*>(peer->data)->cantsay)
											{
												buffs += "|\nadd_label_with_icon|small|`wDuct tape covered your mouth!``|left|408|";
											}
											if (static_cast<PlayerInfo*>(peer->data)->blueBerry)
											{
												buffs += "|\nadd_label_with_icon|small|`wBlueberry``|left|196|";
											}
											if (static_cast<PlayerInfo*>(peer->data)->LuckyClover || isRedAnces(peer) || FarmingEvent)
											{
												buffs += "|\nadd_label_with_icon|small|`wExtra Gem Drop``|left|528|";
											}
											if (isBlueAnces(peer) || FarmingEvent)
											{
												buffs += "|\nadd_label_with_icon|small|`wExtra Block Drop``|left|2|";
											}
											if (isYellowAnces(peer) || FarmingEvent)
											{
												buffs += "|\nadd_label_with_icon|small|`wExtra XP Buff``|left|1488|";
											}
											if (static_cast<PlayerInfo*>(peer->data)->PunchPotion)
											{
												buffs += "|\nadd_label_with_icon|small|`wOne HIT!``|left|6918|";
											}
											if (static_cast<PlayerInfo*>(peer->data)->PlacePotion)
											{
												buffs += "|\nadd_label_with_icon|small|`wTriple Place!``|left|6924|";
											}
											if (static_cast<PlayerInfo*>(peer->data)->cloth_hand == 6840)
											{
												buffs += "|\nadd_label_with_icon|small|`wHarvester!``|left|" + to_string(static_cast<PlayerInfo*>(peer->data)->cloth_hand) + "|";
											}
											if (static_cast<PlayerInfo*>(peer->data)->cloth_back == 10418 || static_cast<PlayerInfo*>(peer->data)->cloth_back == 10420) {
												buffs += "|\nadd_label_with_icon|small|`wFlying and Double jump``|left|" + to_string(static_cast<PlayerInfo*>(peer->data)->cloth_back) + "|";
											}
											else if (static_cast<PlayerInfo*>(peer->data)->canDoubleJump)
											{
												buffs += "|\nadd_label_with_icon|small|`wDouble jump``|left|" + to_string(static_cast<PlayerInfo*>(peer->data)->cloth_back) + "|";
											}
											if (static_cast<PlayerInfo*>(peer->data)->canWalkInBlocks)
											{
												buffs += "|\nadd_label_with_icon|small|`wI can walk in blocks. (Ghost)``|left|3106|";
											}
											if (static_cast<PlayerInfo*>(peer->data)->isinv)
											{
												buffs += "|\nadd_label_with_icon|small|`wNinja, invisible to all!``|left|290|";
											}
											if (buffs == "")
											{
												buffs += "|\nadd_label_with_icon|small|`wYou don't have any active effects!``|left|18|";
											}
											int levels = static_cast<PlayerInfo*>(peer->data)->level;
											int xp = static_cast<PlayerInfo*>(peer->data)->xp;
											string currentworld = static_cast<PlayerInfo*>(peer->data)->currentWorld;
											int xxx = static_cast<PlayerInfo*>(peer->data)->x / 32;
											int yyy = static_cast<PlayerInfo*>(peer->data)->y / 32;
											string joinguilddialog = "";
											string name = static_cast<PlayerInfo*>(peer->data)->displayName;
											if (static_cast<PlayerInfo*>(peer->data)->isinvited == true)
											{
												joinguilddialog = "\nadd_button|joinguild|`2Join Guild " + static_cast<PlayerInfo*>(peer->data)->guildlast + "!|";
											}
											Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_player_info|" + name + "|" + std::to_string(levels) + "|" + std::to_string(xp) + "|" + to_string(static_cast<PlayerInfo*>(peer->data)->level * 1500) + "|\nadd_spacer|small|" + joinguilddialog + "|\nadd_button|manage_title|`$Title``|\nadd_button|manage_audio|`$Audio``|\nadd_button|notebook_edit|`$Notebook``|\nadd_button|goals|`$Goals & Quests``|noflags|0|0|\nadd_button|worlds_view|`$My Worlds``|\nadd_spacer|small|\nadd_textbox|`wActive effects:``|left|" + buffs + "|\nadd_spacer|small|\nadd_textbox|`oYou have `w" + to_string(static_cast<PlayerInfo*>(peer->data)->currentInventorySize) + "`` `obackpack slots.``|left|\nadd_spacer|small|\nadd_textbox|`oCurrent world: `w" + currentworld + " `o(`w" + std::to_string(xxx) + "`o, `w" + std::to_string(yyy) + "`o)|left|\nadd_spacer|small|\nadd_button|chc0|`wContinue|noflags|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
										}
										else
										{
											SendRegisterDialog(peer);
											enet_host_flush(server);
										}
										break;
									}
								}
								if (isPassDoorDialog) {
									if (infoDat[0] == "password") {
										toUpperCase(infoDat[1]);
										if (infoDat[1] != world->items[static_cast<PlayerInfo*>(peer->data)->wrenchsession].password) {
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Wrong password!", 0, false);
											break;
										} else {
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`2The door opens!", 0, false);
											DoEnterDoor(peer, world, static_cast<PlayerInfo*>(peer->data)->lastPunchX, static_cast<PlayerInfo*>(peer->data)->lastPunchY, false);
											break;
										}
									}
								}
								if (worldcategoryDialog) {
									if (infoDat[1] != "worldcategory") {
										if (world->category == infoDat[1]) {
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Your world is already in that category!", 0, false);
										} else {
											if (infoDat[1] != "Mining" && infoDat[1] != "Adventure" && infoDat[1] != "Art" && infoDat[1] != "Farm" &&infoDat[1] != "Game" &&infoDat[1] != "Information" && infoDat[1] != "Music" && infoDat[1] != "Parkour" && infoDat[1] != "Puzzle" && infoDat[1] != "Roleplay" && infoDat[1] != "Shop" && infoDat[1] != "Social" && infoDat[1] != "Storage" && infoDat[1] != "Story" && infoDat[1] != "Trade") break;
											world->category = infoDat[1];
											Player::OnConsoleMessage(peer, "This world has been moved to the '" + infoDat[1] + "' category! Everyone, please type `2/rate`` to rate it from 1-5 stars.");
										}
										break;
									}
								}
								if (isAutoPlaceDialog) {
									if (infoDat[0] == "autoplaceitem") {
										int x = static_cast<PlayerInfo*>(peer->data)->lastPunchX;
										int y = static_cast<PlayerInfo*>(peer->data)->lastPunchY;
										if (world->items[x + (y * world->width)].mid == atoi(infoDat[1].c_str())) break;
										if (world->items[x + (y * world->width)].mc != 0) {
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Empty the machine first!", 0, true);
											break;
										}
										auto contains = false;
										SearchInventoryItem(peer, atoi(infoDat[1].c_str()), 1, contains);
										if (!contains) break;
										if (getItemDef(atoi(infoDat[1].c_str())).blockType == BlockTypes::FOREGROUND || isSeed(atoi(infoDat[1].c_str())) || getItemDef(atoi(infoDat[1].c_str())).blockType == BlockTypes::SFX_FOREGROUND) {
											world->items[x + (y * world->width)].mid = atoi(infoDat[1].c_str());
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
												if (isHere(peer, currentPeer)) {
													SendItemSucker(currentPeer, 6954, x, y, world->items[x + (y * world->width)].mid, -1, true, true, world->items[x + (y * world->width)].background);
												}
											}
										} else {
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "You cannot use this item in Techno-Organic Engine!", 0, true);
										}
									}
									if (infoDat[0] == "autoplaceidentityitem") {
										int x = static_cast<PlayerInfo*>(peer->data)->lastPunchX;
										int y = static_cast<PlayerInfo*>(peer->data)->lastPunchY;
										if (world->items[x + (y * world->width)].vid == atoi(infoDat[1].c_str())) break;
										auto contains = false;
										SearchInventoryItem(peer, atoi(infoDat[1].c_str()), 1, contains);
										if (!contains) break;
										if (getItemDef(atoi(infoDat[1].c_str())).blockType == BlockTypes::FOREGROUND || getItemDef(atoi(infoDat[1].c_str())).blockType == BlockTypes::PLATFORM || getItemDef(atoi(infoDat[1].c_str())).blockType == BlockTypes::SFX_FOREGROUND) {
											world->items[x + (y * world->width)].vid = atoi(infoDat[1].c_str());
										} else {
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "You cannot use this item as identification block in Techno-Organic Engine!", 0, true);
										}								
									}
									if (infoDat[0] == "checkbox_publicremote") {
										int x = static_cast<PlayerInfo*>(peer->data)->lastPunchX;
										int y = static_cast<PlayerInfo*>(peer->data)->lastPunchY;
										if (infoDat[1] == "1") world->items[x + (y * world->width)].rm = true;
										else if (infoDat[1] == "0") world->items[x + (y * world->width)].rm = false;
									}
								}
								if (isAutoBreakDialog) {
									if (infoDat[0] == "autobreakitem") {
										int x = static_cast<PlayerInfo*>(peer->data)->lastPunchX;
										int y = static_cast<PlayerInfo*>(peer->data)->lastPunchY;	
										if (world->items[x + (y * world->width)].mid == atoi(infoDat[1].c_str())) break;
										auto contains = false;
										SearchInventoryItem(peer, atoi(infoDat[1].c_str()), 1, contains);
										if (!contains) break;
										if (isSeed(atoi(infoDat[1].c_str())) && !world->items[x + (y * world->width)].rm) {
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "You will need to enable auto harvest trees mode, before selecting the seed!", 0, true);
											break;
										}
										if (getItemDef(atoi(infoDat[1].c_str())).blockType == BlockTypes::FOREGROUND || isSeed(atoi(infoDat[1].c_str())) || getItemDef(atoi(infoDat[1].c_str())).blockType == BlockTypes::PLATFORM || getItemDef(atoi(infoDat[1].c_str())).blockType == BlockTypes::BACKGROUND || getItemDef(atoi(infoDat[1].c_str())).blockType == BlockTypes::SFX_FOREGROUND) {
											world->items[x + (y * world->width)].mid = atoi(infoDat[1].c_str());
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
												if (isHere(peer, currentPeer)) {
													SendItemSucker(currentPeer, 6952, x, y, world->items[x + (y * world->width)].mid, 0, false, false, world->items[x + (y * world->width)].background);
												}
											}
										} else {
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "You cannot use this item in Tesseract Manipulator!", 0, true);
										}
										break;
									}
									if (infoDat[0] == "checkbox_autoharvest") {
										int x = static_cast<PlayerInfo*>(peer->data)->lastPunchX;
										int y = static_cast<PlayerInfo*>(peer->data)->lastPunchY;
										if (world->items[x + (y * world->width)].rm && infoDat[1] == "1") break;
										if (!world->items[x + (y * world->width)].rm && infoDat[1] == "0") break;
										if (world->items[x + (y * world->width)].rm && isSeed(world->items[x + (y * world->width)].mid)) {
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "You will need to stop the machine before disabling auto harvest mode!", 0, true);
											break;
										}
										if (infoDat[1] == "1") world->items[x + (y * world->width)].rm = true;
										else if (infoDat[1] == "0") world->items[x + (y * world->width)].rm = false;	
									}
								}
								if (vending) {
									if (infoDat[1] == "pullstock") break;
									if (infoDat[0] == "chk_peritem") {
										per_item = infoDat[1];
									}
									if (infoDat[0] == "chk_perlock") {
										if (world->owner != "" && !isWorldOwner(peer, world) && !isMod(peer)) break;
										int x = static_cast<PlayerInfo*>(peer->data)->lastPunchX;
										int y = static_cast<PlayerInfo*>(peer->data)->lastPunchY;
										if (world->items[x + (y * world->width)].foreground != 2978) break;
										bool Changedmh = false;
										if (per_item == "1" && infoDat[1] == "1") {
											Player::OnConsoleMessage(peer, "You can't have it both ways.");
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "You can't have it both ways.", 0, true);
											break;
										}
										if (!world->items[x + (y * world->width)].opened && per_item == "0" && world->items[x + (y * world->width)].rm && infoDat[1] != "1") {
											Player::OnConsoleMessage(peer, "You need to pick a pricing method.");
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "You need to pick a pricing method.", 0, true);
											break;
										}
										if (per_item == "0" && world->items[x + (y * world->width)].rm && world->items[x + (y * world->width)].vprice > world->items[x + (y * world->width)].vcount && world->items[x + (y * world->width)].vid != 0) {
											Player::OnConsoleMessage(peer, "You don't have enough in there for anyone to buy at that price!");
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "You don't have enough in there for anyone to buy at that price!", 0, true);
											break;
										}
										if (per_item == "1" && !world->items[x + (y * world->width)].rm) {
											Changedmh = true;
											world->items[x + (y * world->width)].rm = true;
											auto islocks = false;
											if (world->items[x + (y * world->width)].vdraw >= 1) islocks = true;
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
												if (isHere(peer, currentPeer)) {
													if (world->items[x + (y * world->width)].opened && world->items[x + (y * world->width)].vcount < world->items[x + (y * world->width)].vprice) {
														UpdateVend(currentPeer, x, y, 0, islocks, world->items[x + (y * world->width)].vprice, world->items[x + (y * world->width)].background, world->items[x + (y * world->width)].opened);
													}
													else UpdateVend(currentPeer, x, y, world->items[x + (y * world->width)].vid, islocks, world->items[x + (y * world->width)].vprice, world->items[x + (y * world->width)].background, world->items[x + (y * world->width)].opened);
												}
											}
										}
										else if (per_item == "0" && world->items[x + (y * world->width)].rm) {
											Changedmh = true;
											world->items[x + (y * world->width)].rm = false;
											auto islocks = false;
											if (world->items[x + (y * world->width)].vdraw >= 1) islocks = true;	
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
												if (isHere(peer, currentPeer)) {
													//cout << "say2" << endl;
													//Player::OnConsoleMessage(currentPeer, "`7[`o" + static_cast<PlayerInfo*>(peer->data)->displayName + " `ochanged the price of `2" + getItemDef(world->items[x + (y * world->width)].vid).name + "`o to `6" + to_string(world->items[x + (y * world->width)].vprice) + " per World lock.`7]");
													//Player::OnTalkBubble(currentPeer, static_cast<PlayerInfo*>(peer->data)->netID, "`7[`w" + static_cast<PlayerInfo*>(peer->data)->displayName + " `wchanged the price of `2" + getItemDef(world->items[x + (y * world->width)].vid).name + "`w to `6" + to_string(world->items[x + (y * world->width)].vprice) + " per World lock.`7]", 0, true);
													if (world->items[x + (y * world->width)].opened && world->items[x + (y * world->width)].vcount < world->items[x + (y * world->width)].vprice) {
														UpdateVend(currentPeer, x, y, 0, islocks, world->items[x + (y * world->width)].vprice, world->items[x + (y * world->width)].background, world->items[x + (y * world->width)].opened);
													}
													else UpdateVend(currentPeer, x, y, world->items[x + (y * world->width)].vid, islocks, world->items[x + (y * world->width)].vprice, world->items[x + (y * world->width)].background, world->items[x + (y * world->width)].opened);
													//Player::OnParticleEffect(currentPeer, 44, x * 32, y * 32, 0);
												}
											}
										}
										if (!world->items[x + (y * world->width)].rm && infoDat[1] == "0" && world->items[x + (y * world->width)].opened) {
											Player::OnConsoleMessage(peer, "You need to pick a pricing method.");
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "You need to pick a pricing method.", 0, true);
											break;
										}
										if (infoDat[1] == "1" && !world->items[x + (y * world->width)].opened) {
											Changedmh = true;
											world->items[x + (y * world->width)].opened = true;
											auto islocks = false;
											if (world->items[x + (y * world->width)].vdraw >= 1) islocks = true;
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
												if (isHere(peer, currentPeer)) {
													//cout << "say3" << endl;
													//Player::OnConsoleMessage(currentPeer, "`7[`o" + static_cast<PlayerInfo*>(peer->data)->displayName + " `ochanged the price of `2" + getItemDef(world->items[x + (y * world->width)].vid).name + "`o to `6" + to_string(world->items[x + (y * world->width)].vprice) + " per World lock.`7]");
													//Player::OnTalkBubble(currentPeer, static_cast<PlayerInfo*>(peer->data)->netID, "`7[`w" + static_cast<PlayerInfo*>(peer->data)->displayName + " `wchanged the price of `2" + getItemDef(world->items[x + (y * world->width)].vid).name + "`w to `6" + to_string(world->items[x + (y * world->width)].vprice) + " per World lock.`7]", 0, true);
													if (world->items[x + (y * world->width)].opened && world->items[x + (y * world->width)].vcount < world->items[x + (y * world->width)].vprice) {
														UpdateVend(currentPeer, x, y, 0, islocks, world->items[x + (y * world->width)].vprice, world->items[x + (y * world->width)].background, world->items[x + (y * world->width)].opened);
													}
													else UpdateVend(currentPeer, x, y, world->items[x + (y * world->width)].vid, islocks, world->items[x + (y * world->width)].vprice, world->items[x + (y * world->width)].background, world->items[x + (y * world->width)].opened);
													//Player::OnParticleEffect(currentPeer, 44, x * 32, y * 32, 0);
												}
											}
										}
										else if (infoDat[1] == "0" && world->items[x + (y * world->width)].opened) {
											Changedmh = true;
											world->items[x + (y * world->width)].opened = false;
											auto islocks = false;
											if (world->items[x + (y * world->width)].vdraw >= 1) islocks = true;
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
												if (isHere(peer, currentPeer)) {
													//cout << "say4" << endl;
													//Player::OnConsoleMessage(currentPeer, "`7[`o" + static_cast<PlayerInfo*>(peer->data)->displayName + " `ochanged the price of `2" + getItemDef(world->items[x + (y * world->width)].vid).name + "`o to `5" + to_string(world->items[x + (y * world->width)].vprice) + " World Locks each.`7]");
													//Player::OnTalkBubble(currentPeer, static_cast<PlayerInfo*>(peer->data)->netID, "`7[`w" + static_cast<PlayerInfo*>(peer->data)->displayName + " `wchanged the price of `2" + getItemDef(world->items[x + (y * world->width)].vid).name + "`w to `5" + to_string(world->items[x + (y * world->width)].vprice) + " World Locks each.`7]", 0, true);
													if (world->items[x + (y * world->width)].opened && world->items[x + (y * world->width)].vcount < world->items[x + (y * world->width)].vprice) {
														UpdateVend(currentPeer, x, y, 0, islocks, world->items[x + (y * world->width)].vprice, world->items[x + (y * world->width)].background, world->items[x + (y * world->width)].opened);
													}
													else UpdateVend(currentPeer, x, y, world->items[x + (y * world->width)].vid, islocks, world->items[x + (y * world->width)].vprice, world->items[x + (y * world->width)].background, world->items[x + (y * world->width)].opened);
													//Player::OnParticleEffect(currentPeer, 44, x * 32, y * 32, 0);
												}
											}
										}
										if (Changedmh) {
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
												if (isHere(peer, currentPeer)) {
													if (world->items[x + (y * world->width)].opened) {
														Player::OnConsoleMessage(currentPeer, "`7[`o" + static_cast<PlayerInfo*>(peer->data)->displayName + " `ochanged the price of `2" + getItemDef(world->items[x + (y * world->width)].vid).name + "`o to `6" + to_string(setprice) + " per World lock.`7]");
														Player::OnTalkBubble(currentPeer, static_cast<PlayerInfo*>(peer->data)->netID, "`7[`w" + static_cast<PlayerInfo*>(peer->data)->displayName + " `wchanged the price of `2" + getItemDef(world->items[x + (y * world->width)].vid).name + "`w to `6" + to_string(setprice) + " per World lock.`7]", 0, true);
													} else {
														Player::OnConsoleMessage(currentPeer, "`7[`o" + static_cast<PlayerInfo*>(peer->data)->displayName + " `ochanged the price of `2" + getItemDef(world->items[x + (y * world->width)].vid).name + "`o to `5" + to_string(setprice) + " World Locks each.`7]");
														Player::OnTalkBubble(currentPeer, static_cast<PlayerInfo*>(peer->data)->netID, "`7[`w" + static_cast<PlayerInfo*>(peer->data)->displayName + " `wchanged the price of `2" + getItemDef(world->items[x + (y * world->width)].vid).name + "`w to `5" + to_string(setprice) + " World Locks each.`7]", 0, true);
													}
													Player::OnParticleEffect(currentPeer, 44, x * 32, y * 32, 0);
												}
											}
										}
									}
									if (infoDat[0] == "stockitem") {
										if (world->owner != "" && !isWorldOwner(peer, world) && !isMod(peer)) break;
										string stockitemstr = infoDat[1];
										if (stockitemstr.size() > 5 || stockitemstr.size() <= 0) break;
										stockitem = atoi(stockitemstr.c_str());
										if (stockitem < 0 || stockitem > maxItems) break;
										if (stockitem == 18 || stockitem == 32 || stockitem == 6336 || getItemDef(stockitem).blockType == BlockTypes::LOCK || getItemDef(stockitem).properties & Property_Untradable || getItemDef(stockitem).blockType == BlockTypes::FISH || stockitem == 8552 || stockitem == 9472 || stockitem == 9482 || stockitem == 9356 || stockitem == 9492 || stockitem == 9498 || stockitem == 8774 || stockitem == 1790 || stockitem == 2592 || stockitem == 1784 || stockitem == 1792 || stockitem == 1794 || stockitem == 7734 || stockitem == 8306 || stockitem == 9458) {
											Player::OnConsoleMessage(peer, "`oCan't put that in a Vending Machine.");
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wCan't put that in a Vending Machine.", 0, true);
											break;
										}
										int count = 1;
										for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++) {
											if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == stockitem) {
												count = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
												break;
											}
										}
										if (stockitem == 0 || count == 0) break;
										auto contains = false;
										SearchInventoryItem(peer, stockitem, count, contains);
										if (!contains) break;
										RemoveInventoryItem(stockitem, count, peer, true);
										updateplayerset(peer, stockitem);
										int x = static_cast<PlayerInfo*>(peer->data)->lastPunchX;
										int y = static_cast<PlayerInfo*>(peer->data)->lastPunchY;
										if (world->items[x + (y * world->width)].foreground != 2978) break;									
										world->items[x + (y * world->width)].vprice = setprice;
										world->items[x + (y * world->width)].vid = stockitem;
										world->items[x + (y * world->width)].vcount = count;
										auto islocks = false;
										if (world->items[x + (y * world->width)].vdraw >= 1) islocks = true;
										ENetPeer* currentPeer;
										for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
											if (isHere(peer, currentPeer)) {
												//cout << "say5" << endl;
												Player::OnConsoleMessage(currentPeer, "`7[`o" + static_cast<PlayerInfo*>(peer->data)->displayName + " `oput `2" + getItemDef(stockitem).name + " `oin the Vending Machine.`7]");
												Player::OnTalkBubble(currentPeer, static_cast<PlayerInfo*>(peer->data)->netID, "`7[`w" + static_cast<PlayerInfo*>(peer->data)->displayName + " `wput `2" + getItemDef(stockitem).name + "`w in the Vending Machine.`7]", 0, false);
												if (world->items[x + (y * world->width)].opened && world->items[x + (y * world->width)].vcount < world->items[x + (y * world->width)].vprice) {
													UpdateVend(currentPeer, x, y, 0, islocks, setprice, world->items[x + (y * world->width)].background, world->items[x + (y * world->width)].opened);
												}
												else UpdateVend(currentPeer, x, y, stockitem, islocks, setprice, world->items[x + (y * world->width)].background, world->items[x + (y * world->width)].opened);
												Player::OnParticleEffect(currentPeer, 44, x * 32, y * 32, 0);
											}
										}
										SendVendDialog(peer, world);
										break;
									}
									if (infoDat[0] == "setprice") {
										if (world->owner != "" && !isWorldOwner(peer, world) && !isMod(peer)) break;
										string setpricestr = infoDat[1];
										if (setpricestr.size() > 5 || setpricestr.size() <= 0) break;
										setprice = atoi(setpricestr.c_str());
										if (setprice <= 0) continue;
										if (setprice > 20000) {
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Well, that's a silly price.", 0, true);
											break;
										}
										int x = static_cast<PlayerInfo*>(peer->data)->lastPunchX;
										int y = static_cast<PlayerInfo*>(peer->data)->lastPunchY;
										if (world->items[x + (y * world->width)].foreground != 2978) break;
										if (world->items[x + (y * world->width)].opened && setprice > world->items[x + (y * world->width)].vcount && world->items[x + (y * world->width)].vid != 0) {
											Player::OnConsoleMessage(peer, "You don't have enough in there for anyone to buy at that price!");
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "You don't have enough in there for anyone to buy at that price!", 0, true);
											break;
										}
										if (world->items[x + (y * world->width)].opened && setprice > 250 && world->items[x + (y * world->width)].vid != 0) {
											Player::OnConsoleMessage(peer, "That price is so low, nobody can carry a World Lock worth of items!");
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "That price is so low, nobody can carry a World Lock worth of items!", 0, true);
											break;
										}
										if (setprice == world->items[x + (y * world->width)].vprice) continue;
										world->items[x + (y * world->width)].vprice = setprice;
										auto islocks = false;
										if (world->items[x + (y * world->width)].vdraw >= 1) islocks = true;
										if (isMod(peer) && !isWorldOwner(peer, world) && world->items[x + (y * world->width)].opened) LogAccountActivity(peer, "Changed " + getItemDef(world->items[x + (y * world->width)].vid).name + " price to " + to_string(setprice) + " per World Lock in " + getItemDef(world->items[x + (y * world->width)].foreground).name + " (" + world->name + ")");
										else if (isMod(peer) && !isWorldOwner(peer, world)) LogAccountActivity(peer, "Changed " + getItemDef(world->items[x + (y * world->width)].vid).name + " price to " + to_string(setprice) + " World Locks each in " + getItemDef(world->items[x + (y * world->width)].foreground).name + " (" + world->name + ")");
										ENetPeer* currentPeer;
										for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
											if (isHere(peer, currentPeer)) {
												//cout << "say6" << endl;
												if (world->items[x + (y * world->width)].opened) {
													Player::OnConsoleMessage(currentPeer, "`7[`o" + static_cast<PlayerInfo*>(peer->data)->displayName + " `ochanged the price of `2" + getItemDef(world->items[x + (y * world->width)].vid).name + "`o to `6" + to_string(setprice) + " per World lock.`7]");
													Player::OnTalkBubble(currentPeer, static_cast<PlayerInfo*>(peer->data)->netID, "`7[`w" + static_cast<PlayerInfo*>(peer->data)->displayName + " `wchanged the price of `2" + getItemDef(world->items[x + (y * world->width)].vid).name + "`w to `6" + to_string(setprice) + " per World lock.`7]", 0, true);
												} else {
													Player::OnConsoleMessage(currentPeer, "`7[`o" + static_cast<PlayerInfo*>(peer->data)->displayName + " `ochanged the price of `2" + getItemDef(world->items[x + (y * world->width)].vid).name + "`o to `5" + to_string(setprice) + " World Locks each.`7]");
													Player::OnTalkBubble(currentPeer, static_cast<PlayerInfo*>(peer->data)->netID, "`7[`w" + static_cast<PlayerInfo*>(peer->data)->displayName + " `wchanged the price of `2" + getItemDef(world->items[x + (y * world->width)].vid).name + "`w to `5" + to_string(setprice) + " World Locks each.`7]", 0, true);
												}
												Player::OnParticleEffect(currentPeer, 44, x * 32, y * 32, 0);
												if (world->items[x + (y * world->width)].opened && world->items[x + (y * world->width)].vcount < world->items[x + (y * world->width)].vprice) {
													UpdateVend(currentPeer, x, y, 0, islocks, setprice, world->items[x + (y * world->width)].background, world->items[x + (y * world->width)].opened);
												}
												else UpdateVend(currentPeer, x, y, world->items[x + (y * world->width)].vid, islocks, setprice, world->items[x + (y * world->width)].background, world->items[x + (y * world->width)].opened);
											}
										}
										break;
									}
									/*Buyerio Puse*/
									if (infoDat[0] == "buycount") {
										string buycountstr = infoDat[1];
										if (buycountstr.size() > 3 || buycountstr.size() <= 0) break;
										buyprice = atoi(buycountstr.c_str());
										if (buyprice <= 0) break;
										int x = static_cast<PlayerInfo*>(peer->data)->lastPunchX;
										int y = static_cast<PlayerInfo*>(peer->data)->lastPunchY;
										if (world->items[x + (y * world->width)].foreground != 2978) break;
										auto realprice = world->items[x + (y * world->width)].vprice;
										auto kiekmoketi = buyprice * realprice; 
										auto worldlocks = 0;
										auto diamondlocks = 0;
										auto locks = 0;
										for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++) {
											if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 242) {
												worldlocks = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
											}
											if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 1796) {
												diamondlocks = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
											}
										}
										if (diamondlocks > 0) locks = diamondlocks * 100;
										locks += worldlocks;
										if (kiekmoketi > locks && !world->items[x + (y * world->width)].opened) {
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "You can't afford that many!", 0, true);
											break;
										} 
										if (CheckItemMaxed(peer, world->items[x + (y * world->width)].vid, buyprice)) {
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "That wouldnt fit into my inventory!", 0, true);
											break;
										}
										int yracount = world->items[x + (y * world->width)].vcount;
										int yrawithdraw = world->items[x + (y * world->width)].vdraw;
										if (yracount < buyprice) {
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Out of order", 0, true);
											break;
										}
										if (world->items[x + (y * world->width)].opened) {
											if (buyprice < world->items[x + (y * world->width)].vprice) {
												Player::OnConsoleMessage(peer, "You have to buy at least 1 World Lock's worth.");
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "You have to buy at least 1 World Lock's worth.", 0, true);
												break;
											}
											int oldbuyprice = buyprice;
											buyprice = round(((double)buyprice / world->items[x + (y * world->width)].vprice));
											kiekmoketi = buyprice;
											buyprice *= world->items[x + (y * world->width)].vprice;
											if (buyprice > world->items[x + (y * world->width)].vcount) {
												buyprice = round(oldbuyprice / world->items[x + (y * world->width)].vprice);
												kiekmoketi = buyprice;
												buyprice *= world->items[x + (y * world->width)].vprice;
											} 
										}
										if (kiekmoketi > locks) {
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "You can't afford that many!", 0, true);
											break;
										}
										static_cast<PlayerInfo*>(peer->data)->lastvendbuycount = to_string(buyprice);
										Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wPurchase Confirmation``|left|1366|\nadd_spacer|small|\nadd_spacer|small|\nadd_textbox|`4You'll give:``|left|\nadd_spacer|small|\nadd_label_with_icon|small|(`w" + to_string(kiekmoketi) + "``) `8World Locks``|left|242|\nadd_spacer|small|\nadd_textbox|`2You'll get:``|left|\nadd_spacer|small|\nadd_label_with_icon|small|(`w" + to_string(buyprice) + "``) `2" + getItemDef(world->items[x + (y * world->width)].vid).name + "``|left|" + to_string(world->items[x + (y * world->width)].vid) + "|\nadd_spacer|small|\nadd_spacer|small|\nadd_textbox|Are you sure you want to make this purchase?|left|\nend_dialog|vending_buy|Cancel|OK|");
										break;
									}
								}
								if (isDropDialog) {
									if (world == nullptr || static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT" || serverIsFrozen) break;
									if (infoDat[0] == "dropitemcount") {
										dropitemcount = infoDat[1];
										if (dropitemcount.size() > 3 || dropitemcount.size() <= 0) break;
										if (world->DisableDrop && static_cast<PlayerInfo*>(peer->data)->rawName != world->owner && !isMod(peer)) {
											Player::OnTextOverlay(peer, "Dropping is disabled here!");
											break;
										}
										auto x = atoi(dropitemcount.c_str());
										short int currentItemCount = 0;
										for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++) {
											if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == static_cast<PlayerInfo*>(peer->data)->lastdropitem) {
												currentItemCount = static_cast<unsigned int>(static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount);
											}
										}
										if (x <= 0 || x > currentItemCount) break;
										else {
											auto iscontainseas = false;
											SearchInventoryItem(peer, static_cast<PlayerInfo*>(peer->data)->lastdropitem, 1, iscontainseas);
											if (!iscontainseas) break;
											else {
												if (getItemDef(static_cast<PlayerInfo*>(peer->data)->lastdropitem).properties & Property_Untradable || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 18 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 32 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 6336 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 8552 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 9472 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 9482 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 9356 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 9492 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 9498 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 8774 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 1790 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 2592 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 1784 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 1792 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 1794 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 7734 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 8306 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 9458 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 5640) {
													Player::OnTextOverlay(peer, "You can't drop that.");
													break;
												}
												if (getItemDef(static_cast<PlayerInfo*>(peer->data)->lastdropitem).blockType == BlockTypes::FISH && x != currentItemCount) break;
												if (isMod(peer)) {
													MYSQL_ROW row;
													string qss = "SELECT * FROM PlayerDatabase WHERE username = '" + static_cast<PlayerInfo*>(peer->data)->rawName + "' LIMIT 1";
													string account_history;
													mysql_query(conn, qss.c_str());
													res = mysql_store_result(conn);
													while (row = mysql_fetch_row(res)) {
														account_history = row[68];
													}
													time_t currentTime;
													time(&currentTime);
													const auto localTime = localtime(&currentTime);
													const auto Hour = localTime->tm_hour;
													const auto Min = localTime->tm_min;
													const auto Sec = localTime->tm_sec;
													const auto Year = localTime->tm_year + 1900;
													const auto Day = localTime->tm_mday;
													const auto Month = localTime->tm_mon + 1;
													account_history += "" + to_string(Month) + "/" + to_string(Day) + "/" + to_string(Year) + " " + to_string(Hour) + ":" + to_string(Min) + ":" + to_string(Sec) + ": " + static_cast<PlayerInfo*>(peer->data)->rawName + " - >> Drop " + getItemDef(static_cast<PlayerInfo*>(peer->data)->lastdropitem).name + " (" + world->name + ")|";
													string stringsa = "UPDATE PlayerDatabase SET accountnotes = '" + account_history + "' WHERE username = '" + static_cast<PlayerInfo*>(peer->data)->rawName + "' LIMIT 1";
													mysql_query(conn, stringsa.c_str());
												}
												auto xx = static_cast<PlayerInfo*>(peer->data)->x + (32 * (static_cast<PlayerInfo*>(peer->data)->isRotatedLeft ? -1 : 1));
												auto yy = static_cast<PlayerInfo*>(peer->data)->y;
												RemoveInventoryItem(static_cast<PlayerInfo*>(peer->data)->lastdropitem, x, peer, true);
												updateplayerset(peer, static_cast<PlayerInfo*>(peer->data)->lastdropitem);
												if (world->name == "GROWGANOTH" && GrowganothEvent && yy / 32 == 15 && static_cast<PlayerInfo*>(peer->data)->x / 32 >= 48 && static_cast<PlayerInfo*>(peer->data)->x / 32 <= 51) {
													SendSacrifice(world, peer, static_cast<PlayerInfo*>(peer->data)->lastdropitem, x);
													continue;
												}
												if (world->name != "EXIT" && static_cast<PlayerInfo*>(peer->data)->isIn) {
													DropItem(peer, -1, xx, yy + (rand() % 16), static_cast<PlayerInfo*>(peer->data)->lastdropitem, x, 0);
												}
											}
										}
									}
								}
								if (isTrashDialog) {
									if (world == nullptr || static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT" || serverIsFrozen) break;
									if (infoDat[0] == "trashitemcount") {
										trashitemcount = infoDat[1];
										if (trashitemcount.size() > 3 || trashitemcount.size() <= 0) break;
										auto gemtrashcount = 0;
										auto x = atoi(trashitemcount.c_str());
										short int currentItemCount = 0;
										for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++) {
											if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == static_cast<PlayerInfo*>(peer->data)->lasttrashitem) {
												currentItemCount = static_cast<unsigned int>(static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount);
											}
										}
										if (x <= 0 || x > currentItemCount) break;
										else {
											if (!isDev(peer)) {
												auto iscontainseas = false;
												SearchInventoryItem(peer, static_cast<PlayerInfo*>(peer->data)->lasttrashitem, 1, iscontainseas);
												if (!iscontainseas) break;
											}
											if (getItemDef(static_cast<PlayerInfo*>(peer->data)->lasttrashitem).blockType == BlockTypes::FISH && x != currentItemCount) break;
											static_cast<PlayerInfo*>(peer->data)->lasttrashitemcount = x;
											if (static_cast<PlayerInfo*>(peer->data)->lasttrashitem == 242) {
												gemtrashcount = (rand() % 1999 + 1) * static_cast<PlayerInfo*>(peer->data)->lasttrashitemcount;
											} if (static_cast<PlayerInfo*>(peer->data)->lasttrashitem == 1796) {
												gemtrashcount = (rand() % 199999 + 1) * static_cast<PlayerInfo*>(peer->data)->lasttrashitemcount;
											} if (static_cast<PlayerInfo*>(peer->data)->lasttrashitem == 7188) {
												gemtrashcount = (rand() % 19999999 + 1) * static_cast<PlayerInfo*>(peer->data)->lasttrashitemcount;
											} if (getItemDef(static_cast<PlayerInfo*>(peer->data)->lasttrashitem).blockType == BlockTypes::FISH) {
												gemtrashcount = (rand() % 4 + 1) * static_cast<PlayerInfo*>(peer->data)->lasttrashitemcount;
											}
											Player::OnConsoleMessage(peer, "`w" + std::to_string(static_cast<PlayerInfo*>(peer->data)->lasttrashitemcount) + " " + getItemDef(static_cast<PlayerInfo*>(peer->data)->lasttrashitem).name + " `orecycled, `w" + std::to_string(gemtrashcount) + " `ogems earned.");
											RemoveInventoryItem(static_cast<PlayerInfo*>(peer->data)->lasttrashitem, x, peer, true);
											sendSound(peer, "trash.wav");
											updateplayerset(peer, static_cast<PlayerInfo*>(peer->data)->lasttrashitem);
											std::ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
											std::string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
											auto gembux = atoi(content.c_str());
											auto fingembux = gembux + gemtrashcount;
											ofstream myfile;
											myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
											myfile << fingembux;
											myfile.close();
											int gemcalc = gembux + gemtrashcount;
											static_cast<PlayerInfo*>(peer->data)->eikiscia = gemcalc;
										}
										Player::OnSetBux(peer, static_cast<PlayerInfo*>(peer->data)->eikiscia, 0);
									}
								}
								if (SurgeryDialog)
								{
									if (world == nullptr || static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT" || static_cast<PlayerInfo*>(peer->data)->SurgeryCooldown) break;
									bool HardToSeeWork = static_cast<PlayerInfo*>(peer->data)->HardToSee;
									bool PatientLosingBlood = static_cast<PlayerInfo*>(peer->data)->PatientLosingBlood;
									string WorkSee = "";
									string LosingBlood = "";
									if (infoDat[1] == "Surgical Anesthetic" || infoDat[1] == "Surgical Antiseptic" || infoDat[1] == "Surgical Stitches" || infoDat[1] == "Surgical Pins" || infoDat[1] == "Surgical Transfusion" || infoDat[1] == "Surgical Defibrillator" || infoDat[1] == "Surgical Clamp")
									{
										Player::OnTextOverlay(peer, "This surgery tool isnt available yet!");
										stringstream Temperaturas;
										Temperaturas << static_cast<PlayerInfo*>(peer->data)->PatientTemperature;
										auto PTemp = Temperaturas.str();
										if (HardToSeeWork) WorkSee = "\nadd_smalltext|`6It is becoming hard to see your work.``|left|";
										if (PatientLosingBlood) LosingBlood = "\nadd_smalltext|Patient is losing blood `3slowly.``|left|";
										if (static_cast<PlayerInfo*>(peer->data)->PerformingSurgery) Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wSurg-E``|left|18|\nadd_smalltext|" + static_cast<PlayerInfo*>(peer->data)->PatientDiagnosis + ".``|left|\nadd_smalltext|Pulse: " + static_cast<PlayerInfo*>(peer->data)->PatientPulse + "``    Status: " + static_cast<PlayerInfo*>(peer->data)->PatientStatus + "``|left|\nadd_smalltext|Temp: " + static_cast<PlayerInfo*>(peer->data)->TempColor + PTemp + "``    Operation site: " + static_cast<PlayerInfo*>(peer->data)->OperationSite + "``|left|" + WorkSee + "\nadd_smalltext|Incisions: " + static_cast<PlayerInfo*>(peer->data)->IncisionsColor + to_string(static_cast<PlayerInfo*>(peer->data)->PatientIncisions) + "``    |left|" + LosingBlood + "\nadd_spacer|small|\nadd_smalltext|`3The patient is prepped for surgery.``|left|\ntext_scaling_string|Defibrillator|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem1).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem1) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem1) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem2).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem2) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem2) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem3).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem3) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem3) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem4).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem4) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem4) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem5).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem5) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem5) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem6).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem6) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem6) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem7).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem7) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem7) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem8).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem8) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem8) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem9).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem9) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem9) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem10).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem10) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem10) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem11).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem11) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem11) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem12).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem12) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem12) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem13).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem13) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem13) + "|\nadd_button_with_icon|Empty Surgery Tray||noflags|4320||\nadd_button_with_icon|Empty Surgery Tray||noflags|4320||\nadd_button_with_icon||END_LIST|noflags|0||\nadd_button|cancel|Give up!|noflags|0|0|\nend_dialog|surge|||");
										continue;
									}
									if (static_cast<PlayerInfo*>(peer->data)->PatientDiagnosis != "")
									{
										float temperatura2 = static_cast<PlayerInfo*>(peer->data)->PatientTemperature;
										temperatura2 += static_cast<PlayerInfo*>(peer->data)->PatientTemperatureRise;
										if (temperatura2 >= 113)
										{

											end_surgery(peer, true);
											break;
										}
										if (temperatura2 >= 109)
										{
											static_cast<PlayerInfo*>(peer->data)->TempColor = "`4";
										}
										else if (temperatura2 >= 106)
										{
											static_cast<PlayerInfo*>(peer->data)->TempColor = "`3";
										}
										else
										{
											static_cast<PlayerInfo*>(peer->data)->TempColor = "`2";
										}

										float test = temperatura2;
										float value = (int)(test * 100 + .5);
										float newvalue = (float)value / 100;
										static_cast<PlayerInfo*>(peer->data)->PatientTemperature = newvalue;

									}
									if (infoDat[1] == "Surgical Lab Kit")
									{
										auto contains = false;
										SearchInventoryItem(peer, 4318, 1, contains);
										if (!contains)
										{
											autoBan(peer, false, 24 * 7, "Used surgery exploit");
											break;
										}
										RemoveInventoryItem(4318, 1, peer, true);
										auto KiekTuri = 0;
										for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++)
										{
											if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 4318 && static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount >= 1)
											{
												KiekTuri = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
											}
										}
										if (KiekTuri <= 0) UpdateSurgeryItems(peer);



										string Notification = "`3The patient is prepped for surgery.";
										if (surgery_skill_fail(peer))
										{
											Notification = "`3[`4Skill Fail`3] `6You contaminated the sample.";
										}
										else
										{
											Notification = "";
											static_cast<PlayerInfo*>(peer->data)->UnlockedAntibiotic = true;
											UpdateSurgeryItems(peer);
										}



										stringstream Temperaturas;
										Temperaturas << static_cast<PlayerInfo*>(peer->data)->PatientTemperature;
										auto PTemp = Temperaturas.str();
										if (HardToSeeWork) WorkSee = "\nadd_smalltext|`6It is becoming hard to see your work.``|left|";
										if (PatientLosingBlood) LosingBlood = "\nadd_smalltext|Patient is losing blood `3slowly.``|left|";
										if (static_cast<PlayerInfo*>(peer->data)->PerformingSurgery) Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wSurg-E``|left|18|\nadd_smalltext|" + static_cast<PlayerInfo*>(peer->data)->PatientDiagnosis + ".``|left|\nadd_smalltext|Pulse: " + static_cast<PlayerInfo*>(peer->data)->PatientPulse + "``    Status: " + static_cast<PlayerInfo*>(peer->data)->PatientStatus + "``|left|\nadd_smalltext|Temp: " + static_cast<PlayerInfo*>(peer->data)->TempColor + PTemp + "``    Operation site: " + static_cast<PlayerInfo*>(peer->data)->OperationSite + "``|left|" + WorkSee + "\nadd_smalltext|Incisions: " + static_cast<PlayerInfo*>(peer->data)->IncisionsColor + to_string(static_cast<PlayerInfo*>(peer->data)->PatientIncisions) + "``    |left|" + LosingBlood + "\nadd_spacer|small|\nadd_smalltext|" + Notification + "``|left|\ntext_scaling_string|Defibrillator|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem1).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem1) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem1) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem2).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem2) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem2) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem3).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem3) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem3) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem4).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem4) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem4) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem5).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem5) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem5) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem6).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem6) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem6) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem7).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem7) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem7) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem8).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem8) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem8) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem9).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem9) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem9) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem10).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem10) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem10) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem11).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem11) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem11) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem12).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem12) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem12) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem13).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem13) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem13) + "|\nadd_button_with_icon|nulltool||noflags|4320||\nadd_button_with_icon|nulltool||noflags|4320||\nadd_button_with_icon||END_LIST|noflags|0||\nadd_button|cancel|Give up!|noflags|0|0|\nend_dialog|surge|||");

									}
									if (infoDat[1] == "Fix it")
									{
										string Notification = "`3The patient is prepped for surgery.";
										if (surgery_skill_fail(peer))
										{
											Notification = "`3[`4Skill Fail`3] `6You screwed it up! Try again.";
											stringstream Temperaturas;
											Temperaturas << static_cast<PlayerInfo*>(peer->data)->PatientTemperature;
											auto PTemp = Temperaturas.str();

											if (HardToSeeWork) WorkSee = "\nadd_smalltext|`6It is becoming hard to see your work.``|left|";
											if (PatientLosingBlood) LosingBlood = "\nadd_smalltext|Patient is losing blood `3slowly.``|left|";
											if (static_cast<PlayerInfo*>(peer->data)->PerformingSurgery) Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wSurg-E``|left|18|\nadd_smalltext|" + static_cast<PlayerInfo*>(peer->data)->PatientDiagnosis + ".``|left|\nadd_smalltext|Pulse: " + static_cast<PlayerInfo*>(peer->data)->PatientPulse + "``    Status: " + static_cast<PlayerInfo*>(peer->data)->PatientStatus + "``|left|\nadd_smalltext|Temp: " + static_cast<PlayerInfo*>(peer->data)->TempColor + PTemp + "``    Operation site: " + static_cast<PlayerInfo*>(peer->data)->OperationSite + "``|left|" + WorkSee + "\nadd_smalltext|Incisions: " + static_cast<PlayerInfo*>(peer->data)->IncisionsColor + to_string(static_cast<PlayerInfo*>(peer->data)->PatientIncisions) + "``    |left|" + LosingBlood + "\nadd_spacer|small|\nadd_smalltext|" + Notification + "``|left|\ntext_scaling_string|Defibrillator|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem1).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem1) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem1) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem2).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem2) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem2) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem3).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem3) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem3) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem4).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem4) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem4) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem5).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem5) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem5) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem6).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem6) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem6) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem7).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem7) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem7) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem8).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem8) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem8) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem9).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem9) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem9) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem10).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem10) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem10) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem11).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem11) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem11) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem12).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem12) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem12) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem13).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem13) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem13) + "|\nadd_button_with_icon|nulltool||noflags|4320||\nadd_button_with_icon|nulltool||noflags|4320||\nadd_button_with_icon||END_LIST|noflags|0||\nadd_button|cancel|Give up!|noflags|0|0|\nend_dialog|surge|||");
										}
										else
										{

											Notification = "";
											if (static_cast<PlayerInfo*>(peer->data)->PatientRealDiagnosis == "nose job")
											{
												complete_surgery(peer);
												break;
											}
										}
									}
									if (infoDat[1] == "Surgical Antibiotics")
									{
										auto contains = false;
										SearchInventoryItem(peer, 1266, 1, contains);
										if (!contains)
										{
											autoBan(peer, false, 24 * 7, "Used surgery exploit");
											break;
										}
										RemoveInventoryItem(1266, 1, peer, true);
										auto KiekTuri = 0;
										for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++)
										{
											if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 1266 && static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount >= 1)
											{
												KiekTuri = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
											}
										}
										if (KiekTuri <= 0) UpdateSurgeryItems(peer);

										string Notification = "`3The patient is prepped for surgery.";
										if (surgery_skill_fail(peer))
										{
											Notification = "`3[`4Skill Fail`3] `6This is the wrong medication! The bacteria like it.";
										}
										else
										{
											Notification = "";

											float temperatura2 = static_cast<PlayerInfo*>(peer->data)->PatientTemperature;
											temperatura2 -= 2.6;
											if (temperatura2 <= 100)
											{

												end_surgery(peer, true);

												break;
											}
											if (temperatura2 >= 109)
											{
												static_cast<PlayerInfo*>(peer->data)->TempColor = "`4";
											}
											else if (temperatura2 >= 106)
											{
												static_cast<PlayerInfo*>(peer->data)->TempColor = "`3";
											}
											else if (temperatura2 < 106)
											{
												static_cast<PlayerInfo*>(peer->data)->TempColor = "`2";
											}
											if (temperatura2 <= 105.5)
											{
												static_cast<PlayerInfo*>(peer->data)->TempColor = "`2";
												if (static_cast<PlayerInfo*>(peer->data)->PatientRealDiagnosis == "monkey flu" || static_cast<PlayerInfo*>(peer->data)->PatientRealDiagnosis == "turtle flu" || static_cast<PlayerInfo*>(peer->data)->PatientRealDiagnosis == "bird flu")
												{
													complete_surgery(peer);
													break;
												}
												else if (temperatura2 <= 105)
												{
													end_surgery(peer, true);
													break;
												}
												static_cast<PlayerInfo*>(peer->data)->TempColor = "`6";
											}

											float test = temperatura2;
											float value = (int)(test * 100 + .5);
											float sss = (float)value / 100;
											static_cast<PlayerInfo*>(peer->data)->PatientTemperature = sss;

										}

										stringstream Temperaturas;
										Temperaturas << static_cast<PlayerInfo*>(peer->data)->PatientTemperature;
										auto PTemp = Temperaturas.str();

										if (HardToSeeWork) WorkSee = "\nadd_smalltext|`6It is becoming hard to see your work.``|left|";
										if (PatientLosingBlood) LosingBlood = "\nadd_smalltext|Patient is losing blood `3slowly.``|left|";
										if (static_cast<PlayerInfo*>(peer->data)->PerformingSurgery) Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wSurg-E``|left|18|\nadd_smalltext|" + static_cast<PlayerInfo*>(peer->data)->PatientDiagnosis + ".``|left|\nadd_smalltext|Pulse: " + static_cast<PlayerInfo*>(peer->data)->PatientPulse + "``    Status: " + static_cast<PlayerInfo*>(peer->data)->PatientStatus + "``|left|\nadd_smalltext|Temp: " + static_cast<PlayerInfo*>(peer->data)->TempColor + PTemp + "``    Operation site: " + static_cast<PlayerInfo*>(peer->data)->OperationSite + "``|left|" + WorkSee + "\nadd_smalltext|Incisions: " + static_cast<PlayerInfo*>(peer->data)->IncisionsColor + to_string(static_cast<PlayerInfo*>(peer->data)->PatientIncisions) + "``    |left|" + LosingBlood + "\nadd_spacer|small|\nadd_smalltext|" + Notification + "``|left|\ntext_scaling_string|Defibrillator|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem1).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem1) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem1) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem2).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem2) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem2) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem3).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem3) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem3) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem4).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem4) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem4) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem5).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem5) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem5) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem6).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem6) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem6) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem7).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem7) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem7) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem8).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem8) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem8) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem9).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem9) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem9) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem10).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem10) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem10) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem11).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem11) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem11) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem12).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem12) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem12) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem13).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem13) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem13) + "|\nadd_button_with_icon|nulltool||noflags|4320||\nadd_button_with_icon|nulltool||noflags|4320||\nadd_button_with_icon||END_LIST|noflags|0||\nadd_button|cancel|Give up!|noflags|0|0|\nend_dialog|surge|||");
									}
									if (infoDat[1] == "Surgical Sponge")
									{
										auto contains = false;
										SearchInventoryItem(peer, 1258, 1, contains);
										if (!contains)
										{
											autoBan(peer, false, 24 * 7, "Used surgery exploit");
											break;
										}
										RemoveInventoryItem(1258, 1, peer, true);
										auto KiekTuri = 0;
										for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++)
										{
											if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 1258 && static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount >= 1)
											{
												KiekTuri = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
											}
										}
										if (KiekTuri <= 0) UpdateSurgeryItems(peer);

										string Notification = "`3The patient is prepped for surgery.";
										if (surgery_skill_fail(peer))
										{
											Notification = "`3[`4Skill Fail`3] `6You somehow managed to eat the sponge.";
										}
										else
										{
											Notification = "";
											if (static_cast<PlayerInfo*>(peer->data)->HardToSee)
											{
												static_cast<PlayerInfo*>(peer->data)->HardToSee = false;
												HardToSeeWork = false;
											}
										}

										stringstream Temperaturas;
										Temperaturas << static_cast<PlayerInfo*>(peer->data)->PatientTemperature;
										auto PTemp = Temperaturas.str();
										if (HardToSeeWork) WorkSee = "\nadd_smalltext|`6It is becoming hard to see your work.``|left|";
										if (PatientLosingBlood) LosingBlood = "\nadd_smalltext|Patient is losing blood `3slowly.``|left|";
										if (static_cast<PlayerInfo*>(peer->data)->PerformingSurgery) Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wSurg-E``|left|18|\nadd_smalltext|" + static_cast<PlayerInfo*>(peer->data)->PatientDiagnosis + ".``|left|\nadd_smalltext|Pulse: " + static_cast<PlayerInfo*>(peer->data)->PatientPulse + "``    Status: " + static_cast<PlayerInfo*>(peer->data)->PatientStatus + "``|left|\nadd_smalltext|Temp: " + static_cast<PlayerInfo*>(peer->data)->TempColor + PTemp + "``    Operation site: " + static_cast<PlayerInfo*>(peer->data)->OperationSite + "``|left|" + WorkSee + "\nadd_smalltext|Incisions: " + static_cast<PlayerInfo*>(peer->data)->IncisionsColor + to_string(static_cast<PlayerInfo*>(peer->data)->PatientIncisions) + "``    |left|" + LosingBlood + "\nadd_spacer|small|\nadd_smalltext|" + Notification + "``|left|\ntext_scaling_string|Defibrillator|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem1).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem1) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem1) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem2).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem2) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem2) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem3).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem3) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem3) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem4).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem4) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem4) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem5).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem5) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem5) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem6).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem6) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem6) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem7).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem7) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem7) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem8).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem8) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem8) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem9).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem9) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem9) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem10).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem10) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem10) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem11).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem11) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem11) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem12).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem12) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem12) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem13).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem13) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem13) + "|\nadd_button_with_icon|nulltool||noflags|4320||\nadd_button_with_icon|nulltool||noflags|4320||\nadd_button_with_icon||END_LIST|noflags|0||\nadd_button|cancel|Give up!|noflags|0|0|\nend_dialog|surge|||");
									}
									if (infoDat[1] == "Surgical Ultrasound")
									{
										auto contains = false;
										SearchInventoryItem(peer, 4316, 1, contains);
										if (!contains)
										{
											autoBan(peer, false, 24 * 7, "Used surgery exploit");
											break;
										}
										RemoveInventoryItem(4316, 1, peer, true);
										auto KiekTuri = 0;
										for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++)
										{
											if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 4316 && static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount >= 1)
											{
												KiekTuri = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
											}
										}
										if (KiekTuri <= 0) UpdateSurgeryItems(peer);

										string Notification = "`3The patient is prepped for surgery.";
										if (surgery_skill_fail(peer))
										{
											Notification = "`3[`4Skill Fail`3] `6You scanned the nurse with your ultrasound!";
										}
										else
										{

											Notification = "";

											static_cast<PlayerInfo*>(peer->data)->Ultrasound++;

											if (static_cast<PlayerInfo*>(peer->data)->Ultrasound >= 2)
											{
												static_cast<PlayerInfo*>(peer->data)->PatientTemperatureRise = 1.3;
											}

											static_cast<PlayerInfo*>(peer->data)->PatientDiagnosis = "Patient has " + static_cast<PlayerInfo*>(peer->data)->PatientRealDiagnosis + "";
										}

										stringstream Temperaturas;
										Temperaturas << static_cast<PlayerInfo*>(peer->data)->PatientTemperature;
										auto PTemp = Temperaturas.str();
										if (HardToSeeWork) WorkSee = "\nadd_smalltext|`6It is becoming hard to see your work.``|left|";
										if (PatientLosingBlood) LosingBlood = "\nadd_smalltext|Patient is losing blood `3slowly.``|left|";
										if (static_cast<PlayerInfo*>(peer->data)->PerformingSurgery) Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wSurg-E``|left|18|\nadd_smalltext|" + static_cast<PlayerInfo*>(peer->data)->PatientDiagnosis + ".``|left|\nadd_smalltext|Pulse: " + static_cast<PlayerInfo*>(peer->data)->PatientPulse + "``    Status: " + static_cast<PlayerInfo*>(peer->data)->PatientStatus + "``|left|\nadd_smalltext|Temp: " + static_cast<PlayerInfo*>(peer->data)->TempColor + PTemp + "``    Operation site: " + static_cast<PlayerInfo*>(peer->data)->OperationSite + "``|left|" + WorkSee + "\nadd_smalltext|Incisions: " + static_cast<PlayerInfo*>(peer->data)->IncisionsColor + to_string(static_cast<PlayerInfo*>(peer->data)->PatientIncisions) + "``    |left|" + LosingBlood + "\nadd_spacer|small|\nadd_smalltext|" + Notification + "``|left|\ntext_scaling_string|Defibrillator|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem1).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem1) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem1) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem2).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem2) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem2) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem3).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem3) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem3) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem4).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem4) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem4) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem5).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem5) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem5) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem6).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem6) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem6) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem7).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem7) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem7) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem8).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem8) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem8) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem9).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem9) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem9) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem10).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem10) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem10) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem11).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem11) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem11) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem12).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem12) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem12) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem13).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem13) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem13) + "|\nadd_button_with_icon|nulltool||noflags|4320||\nadd_button_with_icon|nulltool||noflags|4320||\nadd_button_with_icon||END_LIST|noflags|0||\nadd_button|cancel|Give up!|noflags|0|0|\nend_dialog|surge|||");
									}
									if (infoDat[1] == "Surgical Scalpel")
									{
										auto contains = false;
										SearchInventoryItem(peer, 1260, 1, contains);
										if (!contains)
										{
											autoBan(peer, false, 24 * 7, "Used surgery exploit");
											break;
										}
										RemoveInventoryItem(1260, 1, peer, true);
										auto KiekTuri = 0;
										for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++)
										{
											if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == 1260 && static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount >= 1)
											{
												KiekTuri = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
											}
										}
										if (KiekTuri <= 0) UpdateSurgeryItems(peer);



										string Notification = "`3The patient is prepped for surgery.";
										if (surgery_skill_fail(peer))
										{
											Notification = "`3[`4Skill Fail`3] `6This will leave a nasty scar, but you managed to cut the right place.";
										}
										else
										{

											Notification = "";



											static_cast<PlayerInfo*>(peer->data)->PatientIncisions++;

											if (static_cast<PlayerInfo*>(peer->data)->PatientIncisions == 1 && static_cast<PlayerInfo*>(peer->data)->PatientRealDiagnosis == "nose job")
											{
												static_cast<PlayerInfo*>(peer->data)->IncisionsColor = "`2";
											}
											else if (static_cast<PlayerInfo*>(peer->data)->PatientIncisions == 2 && static_cast<PlayerInfo*>(peer->data)->PatientRealDiagnosis == "nose job")
											{
												static_cast<PlayerInfo*>(peer->data)->IncisionsColor = "`2";
												static_cast<PlayerInfo*>(peer->data)->FixIt = true;
												UpdateSurgeryItems(peer);
											}
											else
											{
												static_cast<PlayerInfo*>(peer->data)->IncisionsColor = "`4";
												static_cast<PlayerInfo*>(peer->data)->PatientTemperatureRise = 1.6;
											}

										}

										stringstream Temperaturas;
										Temperaturas << static_cast<PlayerInfo*>(peer->data)->PatientTemperature;
										auto PTemp = Temperaturas.str();
										if (HardToSeeWork) WorkSee = "\nadd_smalltext|`6It is becoming hard to see your work.``|left|";
										if (PatientLosingBlood) LosingBlood = "\nadd_smalltext|Patient is losing blood `3slowly.``|left|";
										if (static_cast<PlayerInfo*>(peer->data)->PerformingSurgery) Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wSurg-E``|left|18|\nadd_smalltext|" + static_cast<PlayerInfo*>(peer->data)->PatientDiagnosis + ".``|left|\nadd_smalltext|Pulse: " + static_cast<PlayerInfo*>(peer->data)->PatientPulse + "``    Status: " + static_cast<PlayerInfo*>(peer->data)->PatientStatus + "``|left|\nadd_smalltext|Temp: " + static_cast<PlayerInfo*>(peer->data)->TempColor + PTemp + "``    Operation site: " + static_cast<PlayerInfo*>(peer->data)->OperationSite + "``|left|" + WorkSee + "\nadd_smalltext|Incisions: " + static_cast<PlayerInfo*>(peer->data)->IncisionsColor + to_string(static_cast<PlayerInfo*>(peer->data)->PatientIncisions) + "``    |left|" + LosingBlood + "\nadd_spacer|small|\nadd_smalltext|" + Notification + "``|left|\ntext_scaling_string|Defibrillator|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem1).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem1) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem1) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem2).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem2) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem2) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem3).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem3) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem3) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem4).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem4) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem4) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem5).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem5) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem5) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem6).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem6) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem6) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem7).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem7) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem7) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem8).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem8) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem8) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem9).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem9) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem9) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem10).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem10) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem10) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem11).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem11) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem11) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem12).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem12) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem12) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem13).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem13) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem13) + "|\nadd_button_with_icon|nulltool||noflags|4320||\nadd_button_with_icon|nulltool||noflags|4320||\nadd_button_with_icon||END_LIST|noflags|0||\nadd_button|cancel|Give up!|noflags|0|0|\nend_dialog|surge|||");
									}
									if (infoDat[1] == "Empty Surgery Tray")
									{

										stringstream Temperaturas;
										Temperaturas << static_cast<PlayerInfo*>(peer->data)->PatientTemperature;
										auto PTemp = Temperaturas.str();
										if (HardToSeeWork) WorkSee = "\nadd_smalltext|`6It is becoming hard to see your work.``|left|";
										if (PatientLosingBlood) LosingBlood = "\nadd_smalltext|Patient is losing blood `3slowly.``|left|";
										if (static_cast<PlayerInfo*>(peer->data)->PerformingSurgery) Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wSurg-E``|left|18|\nadd_smalltext|" + static_cast<PlayerInfo*>(peer->data)->PatientDiagnosis + ".``|left|\nadd_smalltext|Pulse: " + static_cast<PlayerInfo*>(peer->data)->PatientPulse + "``    Status: " + static_cast<PlayerInfo*>(peer->data)->PatientStatus + "``|left|\nadd_smalltext|Temp: " + static_cast<PlayerInfo*>(peer->data)->TempColor + PTemp + "``    Operation site: " + static_cast<PlayerInfo*>(peer->data)->OperationSite + "``|left|" + WorkSee + "\nadd_smalltext|Incisions: " + static_cast<PlayerInfo*>(peer->data)->IncisionsColor + to_string(static_cast<PlayerInfo*>(peer->data)->PatientIncisions) + "``    |left|" + LosingBlood + "\nadd_spacer|small|\nadd_smalltext|`3The patient is prepped for surgery.``|left|\ntext_scaling_string|Defibrillator|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem1).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem1) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem1) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem2).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem2) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem2) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem3).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem3) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem3) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem4).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem4) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem4) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem5).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem5) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem5) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem6).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem6) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem6) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem7).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem7) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem7) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem8).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem8) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem8) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem9).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem9) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem9) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem10).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem10) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem10) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem11).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem11) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem11) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem12).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem12) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem12) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem13).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem13) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem13) + "|\nadd_button_with_icon|nulltool||noflags|4320||\nadd_button_with_icon|nulltool||noflags|4320||\nadd_button_with_icon||END_LIST|noflags|0||\nadd_button|cancel|Give up!|noflags|0|0|\nend_dialog|surge|||");
									}
									if (infoDat[1] == "cancel")
									{
										end_surgery(peer, true);



										break;
									}
									else if (!static_cast<PlayerInfo*>(peer->data)->PerformingSurgery && static_cast<PlayerInfo*>(peer->data)->RequestedSurgery)
									{
										static_cast<PlayerInfo*>(peer->data)->RequestedSurgery = false;
										vector<string> Diagnosis{ "monkey flu", "bird flu", "turtle flu", "nose job", "nose job", "nose job" };
										static_cast<PlayerInfo*>(peer->data)->PatientRealDiagnosis = Diagnosis[rand() % Diagnosis.size()];
										if (static_cast<PlayerInfo*>(peer->data)->PatientRealDiagnosis == "monkey flu" || static_cast<PlayerInfo*>(peer->data)->PatientRealDiagnosis == "bird flu" || static_cast<PlayerInfo*>(peer->data)->PatientRealDiagnosis == "turtle flu")
										{
											static_cast<PlayerInfo*>(peer->data)->PatientDiagnosis = "`4The patient has not been diagnosed";
											static_cast<PlayerInfo*>(peer->data)->PatientPulse = "`2Strong";
											static_cast<PlayerInfo*>(peer->data)->PatientStatus = "`4Awake";
											static_cast<PlayerInfo*>(peer->data)->PatientTemperatureRise = 0.75;
											float test = 107.6;
											float value = (int)(test * 100 + .5);
											float newvalue = (float)value / 100;
											static_cast<PlayerInfo*>(peer->data)->PatientTemperature = newvalue;
											static_cast<PlayerInfo*>(peer->data)->OperationSite = "`3Not sanitized";
											static_cast<PlayerInfo*>(peer->data)->PatientIncisions = 0;
											static_cast<PlayerInfo*>(peer->data)->IncisionsColor = "`3";
											static_cast<PlayerInfo*>(peer->data)->TempColor = "`3";
											static_cast<PlayerInfo*>(peer->data)->HardToSee = true;
											HardToSeeWork = true;

										}
										else if (static_cast<PlayerInfo*>(peer->data)->PatientRealDiagnosis == "nose job")
										{
											static_cast<PlayerInfo*>(peer->data)->PatientDiagnosis = "`4The patient has not been diagnosed";
											static_cast<PlayerInfo*>(peer->data)->PatientPulse = "`2Strong";
											static_cast<PlayerInfo*>(peer->data)->PatientStatus = "`4Awake";
											static_cast<PlayerInfo*>(peer->data)->PatientTemperatureRise = 0.35;
											float test = 106.5;
											float value = (int)(test * 100 + .5);
											float newvalue = (float)value / 100;
											static_cast<PlayerInfo*>(peer->data)->PatientTemperature = newvalue;
											static_cast<PlayerInfo*>(peer->data)->OperationSite = "`3Not sanitized";
											static_cast<PlayerInfo*>(peer->data)->PatientIncisions = 0;
											static_cast<PlayerInfo*>(peer->data)->IncisionsColor = "`3";
											static_cast<PlayerInfo*>(peer->data)->TempColor = "`3";
											static_cast<PlayerInfo*>(peer->data)->HardToSee = true;
											HardToSeeWork = true;
										}



										static_cast<PlayerInfo*>(peer->data)->PerformingSurgery = true;
										ENetPeer* currentPeer;
										for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
											if (isHere(peer, currentPeer))
											{
												Player::OnConsoleMessage(currentPeer, "`7[```2" + static_cast<PlayerInfo*>(peer->data)->displayName + "`o is performing surgery on Surg-E!`7]``");
												Player::OnTalkBubble(currentPeer, static_cast<PlayerInfo*>(peer->data)->netID, "`7[```2" + static_cast<PlayerInfo*>(peer->data)->displayName + "`w is performing surgery on Surg-E!`7]``", 0, true);
											}
										}

										stringstream Temperaturas;
										Temperaturas << static_cast<PlayerInfo*>(peer->data)->PatientTemperature;
										auto PTemp = Temperaturas.str();
										if (HardToSeeWork) WorkSee = "\nadd_smalltext|`6It is becoming hard to see your work.``|left|";
										if (PatientLosingBlood) LosingBlood = "\nadd_smalltext|Patient is losing blood `3slowly.``|left|";
										if (static_cast<PlayerInfo*>(peer->data)->PerformingSurgery) Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wSurg-E``|left|18|\nadd_smalltext|" + static_cast<PlayerInfo*>(peer->data)->PatientDiagnosis + ".``|left|\nadd_smalltext|Pulse: " + static_cast<PlayerInfo*>(peer->data)->PatientPulse + "``    Status: " + static_cast<PlayerInfo*>(peer->data)->PatientStatus + "``|left|\nadd_smalltext|Temp: " + static_cast<PlayerInfo*>(peer->data)->TempColor + PTemp + "``    Operation site: " + static_cast<PlayerInfo*>(peer->data)->OperationSite + "``|left|" + WorkSee + "\nadd_smalltext|Incisions: " + static_cast<PlayerInfo*>(peer->data)->IncisionsColor + to_string(static_cast<PlayerInfo*>(peer->data)->PatientIncisions) + "``    |left|" + LosingBlood + "\nadd_spacer|small|\nadd_smalltext|`3The patient is prepped for surgery.``|left|\ntext_scaling_string|Defibrillator|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem1).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem1) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem1) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem2).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem2) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem2) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem3).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem3) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem3) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem4).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem4) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem4) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem5).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem5) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem5) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem6).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem6) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem6) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem7).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem7) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem7) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem8).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem8) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem8) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem9).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem9) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem9) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem10).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem10) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem10) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem11).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem11) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem11) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem12).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem12) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem12) + "|\nadd_button_with_icon|" + getItemDef(static_cast<PlayerInfo*>(peer->data)->SurgItem13).name + "||noflags|" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgItem13) + "|" + GetItemCount(peer, static_cast<PlayerInfo*>(peer->data)->SurgItem13) + "|\nadd_button_with_icon|Empty Surgery Tray||noflags|4320||\nadd_button_with_icon|Empty Surgery Tray||noflags|4320||\nadd_button_with_icon||END_LIST|noflags|0||\nadd_button|cancel|Give up!|noflags|0|0|\nend_dialog|surge|||");
									}



								}
								if (issafewithdrawConfirmDialog) {
									if (infoDat[0].substr(0, 13) == "safewithdraw_") {
										safe_withdrawConfirmCount = infoDat[1];
										if (safe_withdrawConfirmCount.size() > 5) break;
										string coord_and_apos = infoDat[0].erase(0, 13);
										string::size_type pos = coord_and_apos.find('_');
										if (pos != std::string::npos) {
											safe_withdrawConfirmCoord = coord_and_apos.substr(0, pos);
											coord_and_apos.erase(0, pos + 1);
											safe_withdrawConfirmApos = coord_and_apos;
										}
										else break;
										auto isdbox = std::experimental::filesystem::exists("safevault/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + safe_withdrawConfirmCoord + ".json");
										if (!isdbox) break;
										bool contains_non_int3 = !std::regex_match(safe_withdrawConfirmApos, std::regex("^[0-9]+$"));
										if (contains_non_int3 == true) break;
										bool contains_non_int4 = !std::regex_match(safe_withdrawConfirmCount, std::regex("^[0-9]+$"));
										if (contains_non_int4 == true) {
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Invalid input in amount!", 0, false);
											break;
										}
										safe_withdrawConfirmCountInt = atoi(safe_withdrawConfirmCount.c_str());
										safe_withdrawConfirmAposInt = atoi(safe_withdrawConfirmApos.c_str());
										if (safe_withdrawConfirmCountInt < 1 || safe_withdrawConfirmCountInt > 250) {
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Invalid input in amount!", 0, false);
											break;
										}
										try {
											ifstream ifff("safevault/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + safe_withdrawConfirmCoord + ".json");
											json j;
											ifff >> j;
											ifff.close();
											int itemid = 0;
											bool success = true;
											for (int i = 0; i < 20; i++)
											{
												if (j["safe"][i]["aposition"] == safe_withdrawConfirmAposInt)
												{
													itemid = j["safe"][i]["itemid"];

													if (itemid == 0) break;

													if (safe_withdrawConfirmCountInt > j["safe"][i]["itemcount"])
													{
														Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "You don't have that many stored!", 0, true);
														break;
													}

													if (CheckItemExists(peer, j["safe"][i]["itemid"]))
													{
														int currentlyHave = GetQuantityOfItem(peer, j["safe"][i]["itemid"]);
														if (safe_withdrawConfirmCountInt + currentlyHave < 251)
														{
															SaveItemMoreTimes(j["safe"][i]["itemid"], safe_withdrawConfirmCountInt, peer, success, static_cast<PlayerInfo*>(peer->data)->rawName + " withdraw from safe vault");
														}
														else
														{
															Player::OnTextOverlay(peer, "`4You don't have enought space.");
															break;
														}
													}
													else
													{
														if (static_cast<PlayerInfo*>(peer->data)->inventory.items.size() == static_cast<PlayerInfo*>(peer->data)->currentInventorySize)
														{
															Player::OnTextOverlay(peer, "`4Your inventory is full! You can purchase an inventory upgrade in the shop.");
															break;
														}

														SaveItemMoreTimes(j["safe"][i]["itemid"], safe_withdrawConfirmCountInt, peer, success, static_cast<PlayerInfo*>(peer->data)->rawName + " withdraw from safe vault");
													}

													Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wRemoved " + to_string(safe_withdrawConfirmCountInt) + " " + itemDefs[itemid].name + " from the Safe Vault", 0, true);


													if (j["safe"][i]["itemcount"] == safe_withdrawConfirmCountInt)
													{
														j["safe"][i]["placedby"] = "There was " + to_string(safe_withdrawConfirmCountInt) + " of " + to_string(itemid) + " item, and " + static_cast<PlayerInfo*>(peer->data)->rawName + " withdrawed them.";
														j["safe"][i]["itemid"] = 0;
														j["safe"][i]["itemcount"] = 0;
														j["insafe"] = j["insafe"].get<double>() - 1;
													}
													else
													{
														j["safe"][i]["itemcount"] = j["safe"][i]["itemcount"].get<double>() - safe_withdrawConfirmCountInt;
													}

													ofstream of("safevault/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + safe_withdrawConfirmCoord + ".json");
													of << j << std::endl;
													of.close();
													break;
												}
											}
										}
										catch (std::exception&)
										{
											SendConsole("safewithdraw_ Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_later(peer, 0);
										}
										catch (std::runtime_error&)
										{
											SendConsole("safewithdraw_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_later(peer, 0);
										}
										catch (...)
										{
											SendConsole("safewithdraw_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_later(peer, 0);
										}
									}
								}
								if (isboxlvl2AddItemDialog)
								{
									if (infoDat[0].substr(0, 15) == "boxlvl2deposit_") boxlvl2AddItemDialog = infoDat[1];
									if (boxlvl1AddItemDialog.size() > 5) break;
									string coord = infoDat[0].substr(15, infoDat[0].length() - 1).c_str();
									int itemid = atoi(boxlvl2AddItemDialog.c_str());


									if (itemid < 1 || itemid > maxItems)
									{
										autoBan(peer, false, 24 * 7, "Proxy detect! In isboxlvl2AddItemDialog, item itemid was: " + to_string(itemid) + "");
										break;
									}
									if (itemid == 18 || itemid == 32 || itemid == 6336 || getItemDef(itemid).properties & Property_Untradable || getItemDef(itemid).blockType == BlockTypes::FISH || itemid == 8552 || itemid == 9472 || itemid == 9482 || itemid == 9356 || itemid == 9492 || itemid == 9498 || itemid == 8774 || itemid == 1790 || itemid == 2592 || itemid == 1784 || itemid == 1792 || itemid == 1794 || itemid == 7734 || itemid == 8306 || itemid == 9458)
									{
										Player::OnTextOverlay(peer, "`4You can't place " + getItemDef(itemid).name + ".");
										break;
									}



									auto issafe = std::experimental::filesystem::exists("storageboxlvl2/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
									if (!issafe)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured while getting Storage Box Xtreme - Level 2 info", 0, true);
										break;
									}

									int currentlyHave = 0;
									currentlyHave = GetQuantityOfItem(peer, itemid);

									auto contains = false;
									SearchInventoryItem(peer, itemid, currentlyHave, contains);
									if (!contains)
									{
										autoBan(peer, false, 24 * 7, "Used storage box lvl 2 exploit");
										break;
									}

									try
									{
										ifstream ifff("storageboxlvl2/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
										json j;
										ifff >> j;
										ifff.close();

										if (j["instorage"] > 19)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Storage Box Xtreme - Level 2 is full!", 0, true);
											break;
										}

										GTDialog mysafe;
										mysafe.addLabelWithIcon("`wStorage Box Xtreme - Level 2 info", 6288, LABEL_BIG);
										mysafe.addSmallText("You have " + to_string(currentlyHave) + " " + getItemDef(itemid).name + ". How many to store?");
										mysafe.addInputBox("boxlvl2depositcount_" + coord + "_" + to_string(itemid) + "", "", "", 5);
										mysafe.addSpacer(SPACER_SMALL);
										mysafe.addButton("boxlvl2depositconfirm", "Store items");
										mysafe.addSpacer(SPACER_SMALL);
										mysafe.addQuickExit();
										mysafe.endDialog("Close", "", "Exit");
										Player::OnDialogRequest(peer, mysafe.finishDialog());
									}
									catch (std::exception&)
									{
										SendConsole("boxlvl2deposit_ Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_later(peer, 0);
									}
									catch (std::runtime_error&)
									{
										SendConsole("boxlvl2deposit_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_later(peer, 0);
									}
									catch (...)
									{
										SendConsole("boxlvl2deposit_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_later(peer, 0);
									}
								}
								if (isboxlvl3AddItemDialog)
								{
									if (infoDat[0].substr(0, 15) == "boxlvl3deposit_") boxlvl3AddItemDialog = infoDat[1];
									if (boxlvl1AddItemDialog.size() > 5) break;
									string coord = infoDat[0].substr(15, infoDat[0].length() - 1).c_str();
									int itemid = atoi(boxlvl3AddItemDialog.c_str());


									if (itemid < 1 || itemid > maxItems)
									{
										autoBan(peer, false, 24 * 7, "Proxy detect! In isboxlvl3AddItemDialog, item itemid was: " + to_string(itemid) + "");
										break;
									}
									if (itemid == 18 || itemid == 32 || itemid == 6336 || getItemDef(itemid).properties & Property_Untradable || getItemDef(itemid).blockType == BlockTypes::FISH || itemid == 8552 || itemid == 9472 || itemid == 9482 || itemid == 9356 || itemid == 9492 || itemid == 9498 || itemid == 8774 || itemid == 1790 || itemid == 2592 || itemid == 1784 || itemid == 1792 || itemid == 1794 || itemid == 7734 || itemid == 8306 || itemid == 9458)
									{
										Player::OnTextOverlay(peer, "`4You can't place " + getItemDef(itemid).name + ".");
										break;
									}

									auto issafe = std::experimental::filesystem::exists("storageboxlvl3/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
									if (!issafe)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured while getting Storage Box Xtreme - Level 3 info", 0, true);
										break;
									}

									int currentlyHave = 0;
									currentlyHave = GetQuantityOfItem(peer, itemid);

									auto contains = false;
									SearchInventoryItem(peer, itemid, currentlyHave, contains);
									if (!contains)
									{
										autoBan(peer, false, 24 * 7, "Used storage box lvl 3 exploit");
										break;
									}

									try
									{
										ifstream ifff("storageboxlvl3/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
										json j;
										ifff >> j;
										ifff.close();

										if (j["instorage"] > 19)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Storage Box Xtreme - Level 3 is full!", 0, true);
											break;
										}

										GTDialog mysafe;
										mysafe.addLabelWithIcon("`wStorage Box Xtreme - Level 3 info", 6290, LABEL_BIG);
										mysafe.addSmallText("You have " + to_string(currentlyHave) + " " + getItemDef(itemid).name + ". How many to store?");
										mysafe.addInputBox("boxlvl3depositcount_" + coord + "_" + to_string(itemid) + "", "", "", 5);
										mysafe.addSpacer(SPACER_SMALL);
										mysafe.addButton("boxlvl3depositconfirm", "Store items");
										mysafe.addSpacer(SPACER_SMALL);
										mysafe.addQuickExit();
										mysafe.endDialog("Close", "", "Exit");
										Player::OnDialogRequest(peer, mysafe.finishDialog());
									}
									catch (std::exception&)
									{
										SendConsole("boxlvl3deposit_ Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_later(peer, 0);
									}
									catch (std::runtime_error&)
									{
										SendConsole("boxlvl3deposit_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_later(peer, 0);
									}
									catch (...)
									{
										SendConsole("boxlvl3deposit_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_later(peer, 0);
									}
								}
								if (isboxlvl1AddItemDialog)
								{
									if (infoDat[0].substr(0, 15) == "boxlvl1deposit_") boxlvl1AddItemDialog = infoDat[1];
									if (boxlvl1AddItemDialog.size() > 5) break;
									string coord = infoDat[0].substr(15, infoDat[0].length() - 1).c_str();
									int itemid = atoi(boxlvl1AddItemDialog.c_str());


									if (itemid < 1 || itemid > maxItems)
									{
										autoBan(peer, false, 24 * 7, "Proxy detect! In isaddItemToDonationBox, item itemid was: " + to_string(itemid) + "");
										break;
									}
									if (itemid == 18 || itemid == 32 || itemid == 6336 || getItemDef(itemid).properties & Property_Untradable || getItemDef(itemid).blockType == BlockTypes::FISH || itemid == 8552 || itemid == 9472 || itemid == 9482 || itemid == 9356 || itemid == 9492 || itemid == 9498 || itemid == 8774 || itemid == 1790 || itemid == 2592 || itemid == 1784 || itemid == 1792 || itemid == 1794 || itemid == 7734 || itemid == 8306 || itemid == 9458)
									{
										Player::OnTextOverlay(peer, "`4You can't place " + getItemDef(itemid).name + ".");
										break;
									}

									auto issafe = std::experimental::filesystem::exists("storageboxlvl1/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
									if (!issafe)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured while getting Storage Box Xtreme - Level 1 info", 0, true);
										break;
									}

									int currentlyHave = 0;
									currentlyHave = GetQuantityOfItem(peer, itemid);

									auto contains = false;
									SearchInventoryItem(peer, itemid, currentlyHave, contains);
									if (!contains)
									{
										autoBan(peer, false, 24 * 7, "Used storage box lvl 1 exploit");
										break;
									}

									try
									{
										ifstream ifff("storageboxlvl1/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
										json j;
										ifff >> j;
										ifff.close();

										if (j["instorage"] > 19)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Storage Box Xtreme - Level 1 is full!", 0, true);
											break;
										}

										GTDialog mysafe;
										mysafe.addLabelWithIcon("`wStorage Box Xtreme - Level 1 info", 6286, LABEL_BIG);
										mysafe.addSmallText("You have " + to_string(currentlyHave) + " " + getItemDef(itemid).name + ". How many to store?");
										mysafe.addInputBox("boxlvl1depositcount_" + coord + "_" + to_string(itemid) + "", "", "", 5);
										mysafe.addSpacer(SPACER_SMALL);
										mysafe.addButton("boxlvl1depositconfirm", "Store items");
										mysafe.addSpacer(SPACER_SMALL);
										mysafe.addQuickExit();
										mysafe.endDialog("Close", "", "Exit");
										Player::OnDialogRequest(peer, mysafe.finishDialog());
									}
									catch (std::exception&)
									{
										SendConsole("boxlvl1deposit_ Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_later(peer, 0);
									}
									catch (std::runtime_error&)
									{
										SendConsole("boxlvl1deposit_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_later(peer, 0);
									}
									catch (...)
									{
										SendConsole("boxlvl1deposit_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_later(peer, 0);
									}
								}
								if (isSafeAddItemDialog)
								{
									if (infoDat[0].substr(0, 12) == "safedeposit_") SafeAddItemDialog = infoDat[1];
									if (SafeAddItemDialog.size() > 5) break;
									string coord = infoDat[0].substr(12, infoDat[0].length() - 1).c_str();
									int itemid = atoi(SafeAddItemDialog.c_str());


									if (itemid < 1 || itemid > maxItems)
									{
										autoBan(peer, false, 24 * 7, "Proxy detect! In isSafeAddItemDialog, item itemid was: " + to_string(itemid) + "");
										break;
									}
									if (itemid == 18 || itemid == 32 || itemid == 6336 || getItemDef(itemid).properties & Property_Untradable || getItemDef(itemid).blockType == BlockTypes::FISH || itemid == 8552 || itemid == 9472 || itemid == 9482 || itemid == 9356 || itemid == 9492 || itemid == 9498 || itemid == 8774 || itemid == 1790 || itemid == 2592 || itemid == 1784 || itemid == 1792 || itemid == 1794 || itemid == 7734 || itemid == 8306 || itemid == 9458)
									{
										Player::OnTextOverlay(peer, "`4You can't place " + getItemDef(itemid).name + ".");
										break;
									}

									auto issafe = std::experimental::filesystem::exists("safevault/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
									if (!issafe)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured while getting donation box info.", 0, true);
										break;
									}

									int currentlyHave = 0;
									currentlyHave = GetQuantityOfItem(peer, itemid);

									auto contains = false;
									SearchInventoryItem(peer, itemid, currentlyHave, contains);
									if (!contains)
									{
										autoBan(peer, false, 24 * 7, "Used safe vault exploit");
										break;
									}

									try
									{
										ifstream ifff("safevault/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
										json j;
										ifff >> j;
										ifff.close();

										if (j["insafe"] > 19)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Safe Vault is full!", 0, true);
											break;
										}

										GTDialog mysafe;
										mysafe.addLabelWithIcon("`wSafe fault", 8878, LABEL_BIG);
										mysafe.addSmallText("You have " + to_string(currentlyHave) + " " + getItemDef(itemid).name + ". How many to store?");
										mysafe.addInputBox("safedepositcount_" + coord + "_" + to_string(itemid) + "", "", "", 5);
										mysafe.addSpacer(SPACER_SMALL);
										mysafe.addQuickExit();
										mysafe.endDialog("safedepositconfirm", "Store items", "Cancel");
										Player::OnDialogRequest(peer, mysafe.finishDialog());
									}
									catch (std::exception&)
									{
										SendConsole("safedeposit_ Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_later(peer, 0);
									}
									catch (std::runtime_error&)
									{
										SendConsole("safedeposit_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_later(peer, 0);
									}
									catch (...)
									{
										SendConsole("safedeposit_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_later(peer, 0);
									}
								}
								if (issafedepositconfirmDialog) {
									if (infoDat[0].substr(0, 17) == "safedepositcount_") {
										safedepositcount = infoDat[1];
										string coord_and_id = infoDat[0].erase(0, 17);
										string::size_type pos = coord_and_id.find('_');
										if (pos != std::string::npos) {
											safedepositcoord = coord_and_id.substr(0, pos);
											coord_and_id.erase(0, pos + 1);
											safedeposititemID = coord_and_id;
										}
										else break;
										auto isdbox = std::experimental::filesystem::exists("safevault/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + safedepositcoord + ".json");
										if (!isdbox) break;
										bool contains_non_int3 = !std::regex_match(safedeposititemID, std::regex("^[0-9]+$"));
										if (contains_non_int3 == true) break;
										bool contains_non_int4 = !std::regex_match(safedepositcount, std::regex("^[0-9]+$"));
										if (contains_non_int4 == true) {
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Invalid input in amount!", 0, false);
											break;
										}
										givesafeitemCountInt = atoi(safedepositcount.c_str());
										givesafeitemItemIDInt = atoi(safedeposititemID.c_str());
										if (givesafeitemItemIDInt < 1 || givesafeitemItemIDInt > maxItems) break;
										if (givesafeitemCountInt < 1 || givesafeitemCountInt > 250) {
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Invalid input in amount!", 0, false);
											break;
										}
										try {
											ifstream ifff("safevault/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + safedepositcoord + ".json");
											json j;
											ifff >> j;
											ifff.close();
											if (j["insafe"] > 19) {
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Safe fault is full!", 0, true);
												break;
											}
											bool isContains = false;
											SearchInventoryItem(peer, givesafeitemItemIDInt, givesafeitemCountInt, isContains);
											if (isContains == false) {
												Player::OnTextOverlay(peer, "`4You don't have enough " + itemDefs[givesafeitemItemIDInt].name + " in your inventory.");
												break;
											}
											j["insafe"] = j["insafe"].get<double>() + 1;
											for (int i = 0; i < 20; i++) {
												if (j["safe"][i]["itemid"] == 0) {
													j["safe"][i]["itemid"] = givesafeitemItemIDInt;
													j["safe"][i]["itemcount"] = givesafeitemCountInt;
													j["safe"][i]["placedby"] = static_cast<PlayerInfo*>(peer->data)->rawName;
													Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wStored " + to_string(givesafeitemCountInt) + " " + itemDefs[givesafeitemItemIDInt].name + " `win the Safe Vault", 0, true);
													break;
												}
											}
											ofstream of("safevault/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + safedepositcoord + ".json");
											of << j << std::endl;
											of.close();
											RemoveInventoryItem(givesafeitemItemIDInt, givesafeitemCountInt, peer, true);
											updateplayerset(peer, givesafeitemItemIDInt);
										}
										catch (std::exception&)
										{
											SendConsole("safedepositcount_ Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_later(peer, 0);
										}
										catch (std::runtime_error&)
										{
											SendConsole("safedepositcount_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_later(peer, 0);
										}
										catch (...)
										{
											SendConsole("safedepositcount_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_later(peer, 0);
										}
									}
								}
								if (signEditor) {
									if (world == nullptr || static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT" || serverIsFrozen) continue;
									if (infoDat[0] == "signtextas") message321 = infoDat[1];
								}
								if (isEntranceDialog) {
									if (infoDat[0] == "checkbox_public") {
										entranceresult = infoDat[1];
										if (entranceresult != "0" && entranceresult != "1") break;
										if (getItemDef(world->items[static_cast<PlayerInfo*>(peer->data)->wrenchx + (static_cast<PlayerInfo*>(peer->data)->wrenchy * world->width)].foreground).blockType != BlockTypes::GATEWAY) break;
										if (isWorldOwner(peer, world) || isWorldAdmin(peer, world) || isMod(peer) || !RestrictedArea(peer, world, static_cast<PlayerInfo*>(peer->data)->wrenchx, static_cast<PlayerInfo*>(peer->data)->wrenchy)) {
											world->items[static_cast<PlayerInfo*>(peer->data)->wrenchx + (static_cast<PlayerInfo*>(peer->data)->wrenchy * world->width)].opened = entranceresult == "0" ? 0 : 1;
											updateEntrance(peer, world->items[static_cast<PlayerInfo*>(peer->data)->wrenchx + (static_cast<PlayerInfo*>(peer->data)->wrenchy * world->width)].foreground, static_cast<PlayerInfo*>(peer->data)->wrenchx, static_cast<PlayerInfo*>(peer->data)->wrenchy, world->items[static_cast<PlayerInfo*>(peer->data)->wrenchx + (static_cast<PlayerInfo*>(peer->data)->wrenchy * world->width)].opened, world->items[static_cast<PlayerInfo*>(peer->data)->wrenchx + (static_cast<PlayerInfo*>(peer->data)->wrenchy * world->width)].background, true);
											break;
										}
									}
								}
								if (MagUpdateDialog) {
									if (world == nullptr || static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT" || serverIsFrozen) continue;
									if (infoDat[0] == "checkbox_publicremote") {
										publicremote = infoDat[1];
										if (publicremote != "1" && publicremote != "0") break;
										if (isWorldOwner(peer, world) || isMod(peer)) {
											int x = static_cast<PlayerInfo*>(peer->data)->lastPunchX;
											int y = static_cast<PlayerInfo*>(peer->data)->lastPunchY;
											if (publicremote == "1") world->items[x + (y * world->width)].rm = true;
											else if (publicremote == "0") world->items[x + (y * world->width)].rm = false;
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Finished!", 0, true);
											break;
										}
									}
									if (infoDat[0] == "checkbox_gemcollection") {
										if (infoDat[1] == "1") {
											int x = static_cast<PlayerInfo*>(peer->data)->lastPunchX;
											int y = static_cast<PlayerInfo*>(peer->data)->lastPunchY;
											world->items[x + (y * world->width)].mid = 112;
											ENetPeer* currentPeer;
											for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
												if (isHere(peer, currentPeer)) {
													SendItemSucker(currentPeer, 5638, x, y, 112, 0, true, true, world->items[x + (y * world->width)].background);
												}
											}
										} else {
											int x = static_cast<PlayerInfo*>(peer->data)->lastPunchX;
											int y = static_cast<PlayerInfo*>(peer->data)->lastPunchY;
											world->items[x + (y * world->width)].mid = 0;
											ENetPeer* currentPeer;
											for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
												if (isHere(peer, currentPeer)) {
													SendItemSucker(currentPeer, 5638, x, y, 0, 0, true, true, world->items[x + (y * world->width)].background);
												}
											}
										}
										break;
									}
								}
								if (isgivedonationboxitemConfirm)
								{
									if (world == nullptr || static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT" || serverIsFrozen) break;
									if (infoDat[0].substr(0, 25) == "givedonationboxitemCount_")
									{
										givedonationboxitemCount = infoDat[1];
										string coord_and_id = infoDat[0].erase(0, 25);
										string::size_type pos = coord_and_id.find('_');
										if (pos != std::string::npos)
										{
											givedonationboxitemCoord = coord_and_id.substr(0, pos);
											coord_and_id.erase(0, pos + 1);
											givedonationboxitemItemID = coord_and_id;
										}
										else
										{
											autoBan(peer, false, 24 * 7, "Incorrect parameters isgivedonationboxitemConfirm. Coord and id were: " + coord_and_id);
											break;
										}
										auto isdbox = std::experimental::filesystem::exists("donationboxes/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + givedonationboxitemCoord + ".json");
										if (!isdbox)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured while getting donation box info.", 0, true);
											break;
										}
										bool contains_non_int3 = !std::regex_match(givedonationboxitemItemID, std::regex("^[0-9]+$"));
										if (contains_non_int3 == true)
										{
											autoBan(peer, false, 24 * 7, "Proxy detect! isgivedonationboxitemConfirm id was: " + givedonationboxitemItemID);
											break;
										}
										bool contains_non_int4 = !std::regex_match(givedonationboxitemCount, std::regex("^[0-9]+$"));
										if (contains_non_int4 == true)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Invalid input in amount!", 0, false);
											break;
										}
										givedonationboxitemCountInt = atoi(givedonationboxitemCount.c_str());
										givedonationboxitemItemIDInt = atoi(givedonationboxitemItemID.c_str());
										if (givedonationboxitemItemIDInt < 1 || givedonationboxitemItemIDInt > maxItems)
										{
											autoBan(peer, false, 24 * 7, "Proxy detect! In isgivedonationboxitemConfirm, givedonationboxitemCountInt was: " + to_string(givedonationboxitemItemIDInt) + "");
											break;
										}

										if (getItemDef(givedonationboxitemItemIDInt).rarity < 2)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4You can donate items higher than 2 rarity!", 0, true);
											break;
										}
										if (givedonationboxitemCountInt < 1 || givedonationboxitemCountInt > 250)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Invalid input in amount!", 0, false);
											break;
										}
									}
									if (infoDat[0] == "givedonationboxitemNote")
									{
										givedonationboxitemNote = infoDat[1];
										if (givedonationboxitemNote.size() < 1 || givedonationboxitemNote.size() > 50)
										{
											Player::OnTextOverlay(peer, "`4The note should be at least 1 letter.");
											break;
										}
										try
										{
											ifstream ifff("donationboxes/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + givedonationboxitemCoord + ".json");
											json j;
											ifff >> j;
											ifff.close();
											if (j["donated"] > 19)
											{
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Donation box is full!", 0, true);
												break;
											}
											bool isContains = false;
											SearchInventoryItem(peer, givedonationboxitemItemIDInt, givedonationboxitemCountInt, isContains);
											if (isContains == false)
											{
												autoBan(peer, false, 24 * 7, "Used donate box exploit");
												break;
											}
											j["donated"] = j["donated"].get<double>() + 1;
											for (int i = 0; i < 20; i++)
											{
												if (j["donatedItems"][i]["itemid"] == 0)
												{
													j["donatedItems"][i]["itemid"] = givedonationboxitemItemIDInt;
													j["donatedItems"][i]["itemcount"] = givedonationboxitemCountInt;
													j["donatedItems"][i]["sentBy"] = static_cast<PlayerInfo*>(peer->data)->displayName;
													j["donatedItems"][i]["note"] = givedonationboxitemNote;
													ENetPeer* currentPeer;
													for (currentPeer = server->peers;
														currentPeer < &server->peers[server->peerCount];
														++currentPeer)
													{
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
														if (isHere(peer, currentPeer))
														{
															Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`w[`5[`w" + static_cast<PlayerInfo*>(peer->data)->displayName + " `wplaces `5" + to_string(givedonationboxitemCountInt) + " `2" + getItemDef(givedonationboxitemItemIDInt).name + " `winto the " + getItemDef(world->items[static_cast<PlayerInfo*>(peer->data)->lastPunchX + (static_cast<PlayerInfo*>(peer->data)->lastPunchY * world->width)].foreground).name + "`5]`w]", 0, true);
															Player::OnConsoleMessage(currentPeer, "`w[`5[`w" + static_cast<PlayerInfo*>(peer->data)->displayName + " `wplaces `5" + to_string(givedonationboxitemCountInt) + " `2" + getItemDef(givedonationboxitemItemIDInt).name + " `winto the " + getItemDef(world->items[static_cast<PlayerInfo*>(peer->data)->lastPunchX + (static_cast<PlayerInfo*>(peer->data)->lastPunchY * world->width)].foreground).name + "`5]`w]");
															if (static_cast<PlayerInfo*>(peer->data)->lastPunchX >= 0 && static_cast<PlayerInfo*>(peer->data)->lastPunchY >= 0)
															{
																SendItemPacket(currentPeer, world->items[static_cast<PlayerInfo*>(peer->data)->lastPunchX + (static_cast<PlayerInfo*>(peer->data)->lastPunchY * world->width)].foreground, 0, static_cast<PlayerInfo*>(peer->data)->lastPunchX, static_cast<PlayerInfo*>(peer->data)->lastPunchY, 1);
															}
														}
													}
													break;
												}
											}
											ofstream of("donationboxes/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + givedonationboxitemCoord + ".json");
											of << j << std::endl;
											of.close();
											RemoveInventoryItem(givedonationboxitemItemIDInt, givedonationboxitemCountInt, peer, true);
											updateplayerset(peer, givedonationboxitemItemIDInt);
										}
										catch (std::exception&)
										{
											SendConsole("givedonationboxitemCount_ Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_later(peer, 0);
										}
										catch (std::runtime_error&)
										{
											SendConsole("givedonationboxitemCount_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_later(peer, 0);
										}
										catch (...)
										{
											SendConsole("givedonationboxitemCount_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_later(peer, 0);
										}
									}
								}
								if (isaddItemToDonationBox)
								{
									if (world == nullptr || static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT" || serverIsFrozen) break;
									if (infoDat[0].substr(0, 16) == "addDonationItem_") addItemToDonationBox = infoDat[1];
									if (addItemToDonationBox.size() > 5) break;
									string coord = infoDat[0].substr(16, infoDat[0].length() - 1).c_str();
									int itemid = atoi(addItemToDonationBox.c_str());


									if (itemid < 1 || itemid > maxItems)
									{
										autoBan(peer, false, 24 * 7, "Proxy detect! In isaddItemToDonationBox, item itemid was: " + to_string(itemid) + "");
										break;
									}
									if (itemid == 18 || itemid == 32 || itemid == 6336 || getItemDef(itemid).properties & Property_Untradable || getItemDef(itemid).blockType == BlockTypes::FISH || itemid == 8552 || itemid == 9472 || itemid == 9482 || itemid == 9356 || itemid == 9492 || itemid == 9498 || itemid == 8774 || itemid == 1790 || itemid == 2592 || itemid == 1784 || itemid == 1792 || itemid == 1794 || itemid == 7734 || itemid == 8306 || itemid == 9458)
									{
										Player::OnTextOverlay(peer, "`4You can't donate " + getItemDef(itemid).name + ".");
										break;
									}

									if (getItemDef(itemid).rarity < 2)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4You can donate items higher than 2 rarity!", 0, true);
										break;
									}

									auto isdbox = std::experimental::filesystem::exists("donationboxes/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
									if (!isdbox)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured while getting donation box info.", 0, true);
										break;
									}

									try
									{
										ifstream ifff("donationboxes/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
										json j;
										ifff >> j;
										ifff.close();

										if (j["donated"] > 19)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Donation box is full!", 0, true);
											break;
										}

										GTDialog myDbox;
										myDbox.addLabelWithIcon(getItemDef(itemid).name, itemid, LABEL_BIG);
										myDbox.addSmallText("`$How many to put in the box as a gift? (Note: you will `4LOSE `$the items you give!)");
										myDbox.addInputBox("givedonationboxitemCount_" + coord + "_" + to_string(itemid) + "", "Count:", "", 5);
										myDbox.addSpacer(SPACER_SMALL);
										myDbox.addInputBox("givedonationboxitemNote", "Optional Note:", "", 50);

										myDbox.addSpacer(SPACER_SMALL);
										myDbox.addQuickExit();
										myDbox.endDialog("givedonationboxitemConfirm", "`4Give the item(s)", "Cancel");
										Player::OnDialogRequest(peer, myDbox.finishDialog());
									}
									catch (std::exception&)
									{
										SendConsole("addDonationItem_ Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_later(peer, 0);
									}
									catch (std::runtime_error&)
									{
										SendConsole("addDonationItem_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_later(peer, 0);
									}
									catch (...)
									{
										SendConsole("addDonationItem_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_later(peer, 0);
									}
								}
								if (isEditDoorDialog) {
									if (infoDat[0] == "door_target") {
										string a = getStrUpper(infoDat[1]);
										vector<string> b = explode(":", a);
										if (b.size() == 1) {
											door_destination_world = b[0];
										} else if (b.size() > 1) {
											door_destination_world = b[0];
											door_destination_id = b[1];
											if (door_destination_world == "") {
												door_destination_world = static_cast<PlayerInfo*>(peer->data)->currentWorld;
											}
										}
									}
									if (infoDat[0] == "door_name") door_name = infoDat[1];
									if (infoDat[0] == "door_id") {
										door_id = getStrUpper(infoDat[1]);
										world->items[static_cast<PlayerInfo*>(peer->data)->wrenchsession].destWorld = door_destination_world;
										world->items[static_cast<PlayerInfo*>(peer->data)->wrenchsession].destId = door_destination_id;
										world->items[static_cast<PlayerInfo*>(peer->data)->wrenchsession].label = door_name;
										if (world->items[static_cast<PlayerInfo*>(peer->data)->wrenchsession].foreground == 762) {
											world->items[static_cast<PlayerInfo*>(peer->data)->wrenchsession].password = door_id;
										} else {
											world->items[static_cast<PlayerInfo*>(peer->data)->wrenchsession].currId = door_id;
										}
										updateDoor(peer, world->items[static_cast<PlayerInfo*>(peer->data)->wrenchsession].foreground, static_cast<PlayerInfo*>(peer->data)->wrenchsession% world->width, static_cast<PlayerInfo*>(peer->data)->wrenchsession / world->width, world->items[static_cast<PlayerInfo*>(peer->data)->wrenchsession].background, door_name == "" ? (door_destination_id == "" ? door_destination_world : door_destination_world + "...") : door_name, false, false);
									}
								}
								if (title_save)
								{
									if (infoDat[0] == "title_name")
									{
										if (!static_cast<PlayerInfo*>(peer->data)->Subscriber) break;
										title_name = infoDat[1];
										if (title_name.size() > 10 || title_name.size() < 0)
										{
											break;
										}
										if (title_name.find("`6@") != string::npos || title_name.find("`#@") != string::npos)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`oSorry this title cannot be used for security reasons!", 0, true);
											break;
										}
										if (conn == nullptr)
										{
											cout << "conn was nullptr" << endl;
											continue;
										}
										if (conn != nullptr)
										{
											stringstream ss;
											ss << "UPDATE PlayerDatabase SET title = '" + title_name + "' WHERE username = '" + static_cast<PlayerInfo*>(peer->data)->rawName + "' LIMIT 1";
											auto query = ss.str();
											const auto q = query.c_str();
											if (mysql_query(conn, q))
											{
												cout << mysql_error(conn) << endl;
												
												enet_peer_disconnect_later(peer, 0);
												return 0;
											}
											if (title_name.size() == 0)
											{
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`oTitle have been removed!", 0, true);
												if (static_cast<PlayerInfo*>(peer->data)->isNicked)
												{
													for (ENetPeer* currentPeer = server->peers;
														currentPeer < &server->peers[server->peerCount];
														++currentPeer)
													{
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
														if (isHere(peer, currentPeer))
														{
															Player::OnNameChanged(currentPeer, static_cast<PlayerInfo*>(peer->data)->netID, static_cast<PlayerInfo*>(peer->data)->OriName);
														}
													}
												}
												else
												{
													updateworldremove(peer);
												}
												static_cast<PlayerInfo*>(peer->data)->NickPrefix = "";
												if (static_cast<PlayerInfo*>(peer->data)->haveGrowId)
												{
													if (static_cast<PlayerInfo*>(peer->data)->rawName == world->owner)
													{
														if (static_cast<PlayerInfo*>(peer->data)->adminLevel == 0)
														{
															if (static_cast<PlayerInfo*>(peer->data)->NickPrefix != "")
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->tankIDName;
															}
															else if (static_cast<PlayerInfo*>(peer->data)->isNicked)
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->OriName;
															}
															else
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = "`2" + static_cast<PlayerInfo*>(peer->data)->tankIDName;
															}
														}
													}
													else
													{
														if (static_cast<PlayerInfo*>(peer->data)->adminLevel == 0)
														{
															if (static_cast<PlayerInfo*>(peer->data)->NickPrefix != "")
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->tankIDName;
															}
															else if (static_cast<PlayerInfo*>(peer->data)->isNicked)
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->OriName;
															}
															else
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->tankIDName;
															}
														}
													}
												}
												else
												{
													if (static_cast<PlayerInfo*>(peer->data)->rawName == world->owner)
													{
														if (static_cast<PlayerInfo*>(peer->data)->adminLevel == 0)
														{
															if (static_cast<PlayerInfo*>(peer->data)->NickPrefix != "")
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->tankIDName;
															}
															else if (static_cast<PlayerInfo*>(peer->data)->isNicked)
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->OriName;
															}
															else
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = "`2" + static_cast<PlayerInfo*>(peer->data)->tankIDName;
															}
														}
													}
													else
													{
														if (static_cast<PlayerInfo*>(peer->data)->adminLevel == 0)
														{
															if (static_cast<PlayerInfo*>(peer->data)->NickPrefix != "")
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->tankIDName;
															}
															else if (static_cast<PlayerInfo*>(peer->data)->isNicked)
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->OriName;
															}
															else
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->tankIDName;
															}
														}
													}
												}
												if (static_cast<PlayerInfo*>(peer->data)->haveGrowId)
												{
													if (static_cast<PlayerInfo*>(peer->data)->rawName == world->owner)
													{
														if (static_cast<PlayerInfo*>(peer->data)->adminLevel == 1)
														{
															if (static_cast<PlayerInfo*>(peer->data)->NickPrefix != "")
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->tankIDName;
															}
															else if (static_cast<PlayerInfo*>(peer->data)->isNicked)
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->OriName;
															}
															else
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = "`#@" + static_cast<PlayerInfo*>(peer->data)->tankIDName;
															}
														}
													}
													else
													{
														if (static_cast<PlayerInfo*>(peer->data)->adminLevel == 1)
														{
															if (static_cast<PlayerInfo*>(peer->data)->NickPrefix != "")
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->tankIDName;
															}
															else if (static_cast<PlayerInfo*>(peer->data)->isNicked)
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->OriName;
															}
															else
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = "`#@" + static_cast<PlayerInfo*>(peer->data)->tankIDName;
															}
														}
													}
												}
												else
												{
													if (static_cast<PlayerInfo*>(peer->data)->rawName == world->owner)
													{
														if (static_cast<PlayerInfo*>(peer->data)->adminLevel == 1)
														{
															if (static_cast<PlayerInfo*>(peer->data)->NickPrefix != "")
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->tankIDName;
															}
															else if (static_cast<PlayerInfo*>(peer->data)->isNicked)
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->OriName;
															}
															else
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = "`#@" + static_cast<PlayerInfo*>(peer->data)->tankIDName;
															}
														}
													}
													else
													{
														if (static_cast<PlayerInfo*>(peer->data)->adminLevel == 1)
														{
															if (static_cast<PlayerInfo*>(peer->data)->NickPrefix != "")
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->tankIDName;
															}
															else if (static_cast<PlayerInfo*>(peer->data)->isNicked)
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->OriName;
															}
															else
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = "`#@" + static_cast<PlayerInfo*>(peer->data)->tankIDName;
															}
														}
													}
												}
												if (static_cast<PlayerInfo*>(peer->data)->haveGrowId)
												{
													if (static_cast<PlayerInfo*>(peer->data)->rawName == world->owner)
													{
														if (static_cast<PlayerInfo*>(peer->data)->adminLevel == 2)
														{
															if (static_cast<PlayerInfo*>(peer->data)->NickPrefix != "")
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->tankIDName;
															}
															else if (static_cast<PlayerInfo*>(peer->data)->isNicked)
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->OriName;
															}
															else
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = "`6@" + static_cast<PlayerInfo*>(peer->data)->tankIDName;
															}
														}
													}
													else
													{
														if (static_cast<PlayerInfo*>(peer->data)->adminLevel == 2)
														{
															if (static_cast<PlayerInfo*>(peer->data)->NickPrefix != "")
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->tankIDName;
															}
															else if (static_cast<PlayerInfo*>(peer->data)->isNicked)
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->OriName;
															}
															else
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = "`6@" + static_cast<PlayerInfo*>(peer->data)->tankIDName;
															}
														}
													}
												}
												else
												{
													if (static_cast<PlayerInfo*>(peer->data)->rawName == world->owner)
													{
														if (static_cast<PlayerInfo*>(peer->data)->adminLevel == 2)
														{
															if (static_cast<PlayerInfo*>(peer->data)->NickPrefix != "")
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->tankIDName;
															}
															else if (static_cast<PlayerInfo*>(peer->data)->isNicked)
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->OriName;
															}
															else
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = "`6@" + static_cast<PlayerInfo*>(peer->data)->tankIDName;
															}
														}
													}
													else
													{
														if (static_cast<PlayerInfo*>(peer->data)->adminLevel == 2)
														{
															if (static_cast<PlayerInfo*>(peer->data)->NickPrefix != "")
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->tankIDName;
															}
															else if (static_cast<PlayerInfo*>(peer->data)->isNicked)
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->OriName;
															}
															else
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = "`6@" + static_cast<PlayerInfo*>(peer->data)->tankIDName;
															}
														}
													}
												}
											}
											else
											{
												static_cast<PlayerInfo*>(peer->data)->NickPrefix = title_name;
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`oTitle changed to " + title_name + "!", 0, true);
												//restoreplayernick(peer);
												if (static_cast<PlayerInfo*>(peer->data)->haveGrowId)
												{
													if (static_cast<PlayerInfo*>(peer->data)->rawName == world->owner)
													{
														if (static_cast<PlayerInfo*>(peer->data)->adminLevel == 0)
														{
															if (static_cast<PlayerInfo*>(peer->data)->NickPrefix != "")
															{
																if (static_cast<PlayerInfo*>(peer->data)->isNicked)
																{
																	static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->OriName;
																}
																else
																{
																	static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->tankIDName;
																}
															}
															else if (static_cast<PlayerInfo*>(peer->data)->isNicked)
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->OriName;
															}
															else
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = "`2" + static_cast<PlayerInfo*>(peer->data)->tankIDName;
															}
														}
													}
													else
													{
														if (static_cast<PlayerInfo*>(peer->data)->adminLevel == 0)
														{
															if (static_cast<PlayerInfo*>(peer->data)->NickPrefix != "")
															{
																if (static_cast<PlayerInfo*>(peer->data)->isNicked)
																{
																	static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->OriName;
																}
																else
																{
																	static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->tankIDName;
																}
															}
															else if (static_cast<PlayerInfo*>(peer->data)->isNicked)
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->OriName;
															}
															else
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->tankIDName;
															}
														}
													}
												}
												else
												{
													if (static_cast<PlayerInfo*>(peer->data)->rawName == world->owner)
													{
														if (static_cast<PlayerInfo*>(peer->data)->adminLevel == 0)
														{
															if (static_cast<PlayerInfo*>(peer->data)->NickPrefix != "")
															{
																if (static_cast<PlayerInfo*>(peer->data)->isNicked)
																{
																	static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->OriName;
																}
																else
																{
																	static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->tankIDName;
																}
															}
															else if (static_cast<PlayerInfo*>(peer->data)->isNicked)
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->OriName;
															}
															else
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = "`2" + static_cast<PlayerInfo*>(peer->data)->tankIDName;
															}
														}
													}
													else
													{
														if (static_cast<PlayerInfo*>(peer->data)->adminLevel == 0)
														{
															if (static_cast<PlayerInfo*>(peer->data)->NickPrefix != "")
															{
																if (static_cast<PlayerInfo*>(peer->data)->isNicked)
																{
																	static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->OriName;
																}
																else
																{
																	static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->tankIDName;
																}
															}
															else if (static_cast<PlayerInfo*>(peer->data)->isNicked)
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->OriName;
															}
															else
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->tankIDName;
															}
														}
													}
												}
												if (static_cast<PlayerInfo*>(peer->data)->haveGrowId)
												{
													if (static_cast<PlayerInfo*>(peer->data)->rawName == world->owner)
													{
														if (static_cast<PlayerInfo*>(peer->data)->adminLevel == 1)
														{
															if (static_cast<PlayerInfo*>(peer->data)->NickPrefix != "")
															{
																if (static_cast<PlayerInfo*>(peer->data)->isNicked)
																{
																	static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->OriName;
																}
																else
																{
																	static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->tankIDName;
																}
															}
															else if (static_cast<PlayerInfo*>(peer->data)->isNicked)
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->OriName;
															}
															else
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = "`#@" + static_cast<PlayerInfo*>(peer->data)->tankIDName;
															}
														}
													}
													else
													{
														if (static_cast<PlayerInfo*>(peer->data)->adminLevel == 1)
														{
															if (static_cast<PlayerInfo*>(peer->data)->NickPrefix != "")
															{
																if (static_cast<PlayerInfo*>(peer->data)->isNicked)
																{
																	static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->OriName;
																}
																else
																{
																	static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->tankIDName;
																}
															}
															else if (static_cast<PlayerInfo*>(peer->data)->isNicked)
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->OriName;
															}
															else
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = "`#@" + static_cast<PlayerInfo*>(peer->data)->tankIDName;
															}
														}
													}
												}
												else
												{
													if (static_cast<PlayerInfo*>(peer->data)->rawName == world->owner)
													{
														if (static_cast<PlayerInfo*>(peer->data)->adminLevel == 1)
														{
															if (static_cast<PlayerInfo*>(peer->data)->NickPrefix != "")
															{
																if (static_cast<PlayerInfo*>(peer->data)->isNicked)
																{
																	static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->OriName;
																}
																else
																{
																	static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->tankIDName;
																}
															}
															else if (static_cast<PlayerInfo*>(peer->data)->isNicked)
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->OriName;
															}
															else
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = "`#@" + static_cast<PlayerInfo*>(peer->data)->tankIDName;
															}
														}
													}
													else
													{
														if (static_cast<PlayerInfo*>(peer->data)->adminLevel == 1)
														{
															if (static_cast<PlayerInfo*>(peer->data)->NickPrefix != "")
															{
																if (static_cast<PlayerInfo*>(peer->data)->isNicked)
																{
																	static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->OriName;
																}
																else
																{
																	static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->tankIDName;
																}
															}
															else if (static_cast<PlayerInfo*>(peer->data)->isNicked)
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->OriName;
															}
															else
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = "`#@" + static_cast<PlayerInfo*>(peer->data)->tankIDName;
															}
														}
													}
												}
												if (static_cast<PlayerInfo*>(peer->data)->haveGrowId)
												{
													if (static_cast<PlayerInfo*>(peer->data)->rawName == world->owner)
													{
														if (static_cast<PlayerInfo*>(peer->data)->adminLevel == 2)
														{
															if (static_cast<PlayerInfo*>(peer->data)->NickPrefix != "")
															{
																if (static_cast<PlayerInfo*>(peer->data)->isNicked)
																{
																	static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->OriName;
																}
																else
																{
																	static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->tankIDName;
																}
															}
															else if (static_cast<PlayerInfo*>(peer->data)->isNicked)
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->OriName;
															}
															else
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = "`6@" + static_cast<PlayerInfo*>(peer->data)->tankIDName;
															}
														}
													}
													else
													{
														if (static_cast<PlayerInfo*>(peer->data)->adminLevel == 2)
														{
															if (static_cast<PlayerInfo*>(peer->data)->NickPrefix != "")
															{
																if (static_cast<PlayerInfo*>(peer->data)->isNicked)
																{
																	static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->OriName;
																}
																else
																{
																	static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->tankIDName;
																}
															}
															else if (static_cast<PlayerInfo*>(peer->data)->isNicked)
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->OriName;
															}
															else
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = "`6@" + static_cast<PlayerInfo*>(peer->data)->tankIDName;
															}
														}
													}
												}
												else
												{
													if (static_cast<PlayerInfo*>(peer->data)->rawName == world->owner)
													{
														if (static_cast<PlayerInfo*>(peer->data)->adminLevel == 2)
														{
															if (static_cast<PlayerInfo*>(peer->data)->NickPrefix != "")
															{
																if (static_cast<PlayerInfo*>(peer->data)->isNicked)
																{
																	static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->OriName;
																}
																else
																{
																	static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->tankIDName;
																}
															}
															else if (static_cast<PlayerInfo*>(peer->data)->isNicked)
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->OriName;
															}
															else
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = "`6@" + static_cast<PlayerInfo*>(peer->data)->tankIDName;
															}
														}
													}
													else
													{
														if (static_cast<PlayerInfo*>(peer->data)->adminLevel == 2)
														{
															if (static_cast<PlayerInfo*>(peer->data)->NickPrefix != "")
															{
																if (static_cast<PlayerInfo*>(peer->data)->isNicked)
																{
																	static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->OriName;
																}
																else
																{
																	static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->tankIDName;
																}
															}
															else if (static_cast<PlayerInfo*>(peer->data)->isNicked)
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->OriName;
															}
															else
															{
																static_cast<PlayerInfo*>(peer->data)->displayName = "`6@" + static_cast<PlayerInfo*>(peer->data)->tankIDName;
															}
														}
													}
												}

												if (static_cast<PlayerInfo*>(peer->data)->isNicked)
												{
													GamePacket p7 = packetEnd(appendString(appendString(createPacket(), "OnNameChanged"), title_name + ". " + static_cast<PlayerInfo*>(peer->data)->OriName));
													memcpy(p7.data + 8, &(static_cast<PlayerInfo*>(peer->data)->netID), 4);
													ENetPacket* packet7 = enet_packet_create(p7.data, p7.len, ENET_PACKET_FLAG_RELIABLE);
													ENetPeer* currentPeer;
													for (currentPeer = server->peers;
														currentPeer < &server->peers[server->peerCount];
														++currentPeer)
													{
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
														if (isHere(peer, currentPeer))
														{
															enet_peer_send(currentPeer, 0, packet7);
														}
													}
													delete p7.data;
												}
												else
												{
													GamePacket p7 = packetEnd(appendString(appendString(createPacket(), "OnNameChanged"), title_name + ". " + static_cast<PlayerInfo*>(peer->data)->rawName));
													memcpy(p7.data + 8, &(static_cast<PlayerInfo*>(peer->data)->netID), 4);
													ENetPacket* packet7 = enet_packet_create(p7.data, p7.len, ENET_PACKET_FLAG_RELIABLE);
													ENetPeer* currentPeer;
													for (currentPeer = server->peers;
														currentPeer < &server->peers[server->peerCount];
														++currentPeer)
													{
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
														if (isHere(peer, currentPeer))
														{
															enet_peer_send(currentPeer, 0, packet7);
														}
													}
													delete p7.data;
												}
											}
										}
									}
								}
								if (notebook_edit)
								{
									if (infoDat[0] == "personal_note")
									{
										personal_note = infoDat[1];
										if (personal_note.size() >= 128 || personal_note.size() <= 0) break;
										if (conn == nullptr)
										{
											cout << "conn was nullptr" << endl;
											continue;
										}
										if (conn != nullptr)
										{
											stringstream ss;
											ss << "UPDATE PlayerDatabase SET notebook = '" + personal_note + "' WHERE username = '" + static_cast<PlayerInfo*>(peer->data)->rawName + "' LIMIT 1";
											auto query = ss.str();
											const auto q = query.c_str();
											if (mysql_query(conn, q))
											{
												cout << mysql_error(conn) << endl;										
												enet_peer_disconnect_later(peer, 0);
												break;
											}
											static_cast<PlayerInfo*>(peer->data)->notebook = personal_note;
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`2Text saved.", 0, true);
										}
									}
								}
								if (signEditor) {
									int x = static_cast<PlayerInfo*>(peer->data)->wrenchedBlockLocation % world->width;
									int y = static_cast<PlayerInfo*>(peer->data)->wrenchedBlockLocation / world->width;
									if (x < 0 || y < 0) break;
									world->items[static_cast<PlayerInfo*>(peer->data)->wrenchedBlockLocation].sign = message321;
									UpdateMessageVisuals(peer, world->items[static_cast<PlayerInfo*>(peer->data)->wrenchedBlockLocation].foreground, x, y, message321, world->items[static_cast<PlayerInfo*>(peer->data)->wrenchedBlockLocation].background);
								}
								if (isLockDialog) {
									if (infoDat[1] == "changecat") {
										Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wSet World Category``|left|3802|\nadd_textbox|Select a category for your world.|left|\nadd_button|None|None|noflags|0|0|\nadd_button|Mining|Mining|noflags|0|0|\nadd_button|Adventure|Adventure|noflags|0|0|\nadd_button|Art|Art|noflags|0|0|\nadd_button|Farm|Farm|noflags|0|0|\nadd_button|Game|Game|noflags|0|0|\nadd_button|Information|Information|noflags|0|0|\nadd_button|Music|Music|noflags|0|0|\nadd_button|Parkour|Parkour|noflags|0|0|\nadd_button|Puzzle|Puzzle|noflags|0|0|\nadd_button|Roleplay|Roleplay|noflags|0|0|\nadd_button|Shop|Shop|noflags|0|0|\nadd_button|Social|Social|noflags|0|0|\nadd_button|Storage|Storage|noflags|0|0|\nadd_button|Story|Story|noflags|0|0|\nadd_button|Trade|Trade|noflags|0|0|\nadd_smalltext|Worlds in the category 'None' can't be rated by players, and they are only listed on the normal World Select screen.|left|\nadd_smalltext|`4Warning:`` Changing your category will delete all ratings on your world.|left|\nend_dialog|worldcategory|Nevermind||");
										break;
									}
									if (infoDat[0] == "checkbox_public") {
										int x = static_cast<PlayerInfo*>(peer->data)->wrenchedBlockLocation % world->width;
										int y = static_cast<PlayerInfo*>(peer->data)->wrenchedBlockLocation / world->width;
										if (world->items[x + (y * world->width)].foreground == 202 || world->items[x + (y * world->width)].foreground == 204 || world->items[x + (y * world->width)].foreground == 206 || world->items[x + (y * world->width)].foreground == 4994) {
											if (static_cast<PlayerInfo*>(peer->data)->rawName == world->items[x + (y * world->width)].monitorname || isMod(peer) || isWorldOwner(peer, world)) {
												if (!world->items[x + (y * world->width)].opened && infoDat[1] == "1") world->items[x + (y * world->width)].opened = true;
												else if (infoDat[1] == "0" && world->items[x + (y * world->width)].opened) world->items[x + (y * world->width)].opened = false;
											}
										}
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
											if (isHere(peer, currentPeer)) {
												if (world->items[x + (y * world->width)].opened) ApplyLockPacket(world, currentPeer, x, y, world->items[x + (y * world->width)].foreground, -3);
												else if (world->items[x + (y * world->width)].monitorname == static_cast<PlayerInfo*>(currentPeer->data)->rawName) ApplyLockPacket(world, currentPeer, x, y, world->items[x + (y * world->width)].foreground, static_cast<PlayerInfo*>(currentPeer->data)->netID);
												else ApplyLockPacket(world, currentPeer, x, y, world->items[x + (y * world->width)].foreground, -1);
											}
										}
									}
									if (infoDat[0] == "playerNetID") {
										playerNetId = infoDat[1];
									}
									if (infoDat[0] == "checkbox_muted") {
										muted = infoDat[1];
									}
									if (infoDat[0] == "checkbox_rainbow") {
										int x = static_cast<PlayerInfo*>(peer->data)->wrenchedBlockLocation % world->width;
										int y = static_cast<PlayerInfo*>(peer->data)->wrenchedBlockLocation / world->width;
										if (infoDat[1] == "1" && !world->rainbow) {
											world->rainbow = true;
										}
										if (infoDat[1] == "0" && world->rainbow) {
											world->rainbow = false;
										}
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
											if (isHere(peer, currentPeer)) {
												if (world->rainbow) SendRainbowShitData(currentPeer, world->items[x + (y * world->width)].foreground, world->items[x + (y * world->width)].background, x, y, true, static_cast<PlayerInfo*>(peer->data)->netID);
												else SendRainbowShitData(currentPeer, world->items[x + (y * world->width)].foreground, world->items[x + (y * world->width)].background, x, y, false, static_cast<PlayerInfo*>(peer->data)->netID);
											}
										}
									}
									if (infoDat[0] == "minimum_entry_level") {
										int x = static_cast<PlayerInfo*>(peer->data)->wrenchedBlockLocation % world->width;
										int y = static_cast<PlayerInfo*>(peer->data)->wrenchedBlockLocation / world->width;
										if (x < 0 || y < 0) break;
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
											if (isHere(peer, currentPeer)) {
												if (static_cast<PlayerInfo*>(currentPeer->data)->netID == atoi(playerNetId.c_str())) {
													if (!isWorldAdmin(currentPeer, world) && !isWorldOwner(currentPeer, world)) {
														accessPlayer(peer, static_cast<PlayerInfo*>(currentPeer->data)->rawName, world);
													}
												}
											}
										}
										if (muted == "1") world->silence = true;
										else world->silence = false;
										if (world->entrylevel != atoi(infoDat[1].c_str())) {
											if (atoi(infoDat[1].c_str()) >= 125 || infoDat[1].size() > 3) {
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Minimum entry level can't be higher than 124.", 0, 0);
											} else {
												world->entrylevel = atoi(infoDat[1].c_str());
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Minimum entry level for this world is set to `2Level " + infoDat[1] + "``.", 0, 0);
											}
										}
										break;
									}
								}
								if (isStuffDialog)
								{
									if (world == nullptr || static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT" || serverIsFrozen) break;
									int stuffitemi = 0;
									int gravity = 100;
									int x = static_cast<PlayerInfo*>(peer->data)->lastPunchX;
									int y = static_cast<PlayerInfo*>(peer->data)->lastPunchY;
									if (infoDat[0] == "stuffitem")
									{
										if (stuffitem.size() > 5 || stuffitem.size() <= 0) break;
										stuffitem = infoDat[1];
									}
									if (infoDat[0] == "gravity")
									{
										if (gravitystr.size() > 3 || gravitystr.size() <= 0) break;
										gravitystr = infoDat[1];
									}
									if (has_only_digits(stuffitem))
									{
										stuffitemi = atoi(stuffitem.c_str());
										if (stuffitemi > maxItems) break;
									}
									if (has_only_digits_wnegative(gravitystr)) gravity = atoi(gravitystr.c_str());
									updateStuffWeather(peer, x, y, stuffitemi, world->items[x + (y * world->width)].background, gravity, false, false);
									world->weather = 29;
								}
								if (isMagCheckDialog) {
									if (infoDat[0] == "checkbox_gemcollection") {
										if (infoDat[1] == "1") {
											int x = static_cast<PlayerInfo*>(peer->data)->lastPunchX;
											int y = static_cast<PlayerInfo*>(peer->data)->lastPunchY;
											world->items[x + (y * world->width)].mid = 112;
											ENetPeer* currentPeer;
											for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
												if (isHere(peer, currentPeer)) {
													SendItemSucker(currentPeer, 5638, x, y, 112, 0, true, true, world->items[x + (y * world->width)].background);
												}
											}
										} 
										break;
									}
								}
								if (isMagDialog) {
									if (world == nullptr || static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT" || serverIsFrozen || static_cast<PlayerInfo*>(peer->data)->rawName != world->owner && !isMod(peer) && world->owner != "") break;
									int magplantitemi = 0;
									int x = static_cast<PlayerInfo*>(peer->data)->lastPunchX;
									int y = static_cast<PlayerInfo*>(peer->data)->lastPunchY;
									int suckerid = static_cast<PlayerInfo*>(peer->data)->suckerid;
									string suckername = static_cast<PlayerInfo*>(peer->data)->suckername;
									if (infoDat[0] == "magplantitem") magplantitem = infoDat[1];
									magplantitemi = atoi(magplantitem.c_str());
									bool allow = true;
									for (int i = 0; i < world->width * world->height; i++) {
										if (world->items[i].foreground == 5638 || world->items[i].foreground == 6946 || world->items[i].foreground == 6948) {
											string SuckerName3 = "";
											if (world->items[i].foreground == 5638) SuckerName3 = "magplant";
											if (world->items[i].foreground == 6946) SuckerName3 = "gaiabeacon";
											if (world->items[i].foreground == 6948) SuckerName3 = "unstabletesseract";
											if (magplantitemi == world->items[i].mid) allow = false;
										}
									}
									if (magplantitemi == 18 || magplantitemi == 32 || getItemDef(magplantitemi).properties & Property_Untradable) {
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "You cannot use this item in " + getItemDef(suckerid).name + "!", 0, true);
									}
									else if (suckerid == 6946 && !isSeed(magplantitemi)) {
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, getItemDef(suckerid).name + " supports only seeds!", 0, true);
									}
									else if (suckerid == 6948 && getItemDef(magplantitemi).blockType != BlockTypes::FOREGROUND && getItemDef(magplantitemi).blockType != BlockTypes::PAIN_BLOCK && getItemDef(magplantitemi).blockType != BlockTypes::GROUND_BLOCK && getItemDef(magplantitemi).blockType != BlockTypes::BACKGROUND) {
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, getItemDef(suckerid).name + " supports only foregrounds or backgrounds!", 0, true);
									}
									else if (allow == false) {
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "There is already Item Sucker with such item!", 0, true);
									}
									else {
										auto contains = false;
										SearchInventoryItem(peer, magplantitemi, 1, contains);
										if (!contains) break;
										ENetPeer* currentPeer;
										for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
											if (isHere(peer, currentPeer)) {
												SendItemSucker(currentPeer, suckerid, x, y, magplantitemi, 0, true, true, world->items[x + (y * world->width)].background);
											}
										}
										world->items[x + (y * world->width)].mid = magplantitemi;
										world->items[x + (y * world->width)].mc = 0;
									}
								}
								if (isTeleDialog)
								{
									if (world == nullptr || static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT" || serverIsFrozen) continue;
									if (infoDat[0] == "telephonenumber")
									{
										Player::OnTextOverlay(peer, "Salesman under development!");
										break;
										telefonas = infoDat[1];
										if (telefonas.size() > 5 || telefonas.size() <= 0)
										{
											continue;
										}
										if (telefonas != "12345" && telefonas != "53785")
										{
											Player::OnTextOverlay(peer, "This phone number does not exist!");
										}
										else if (telefonas == "12345")              
										{
											Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`wLocke The Salesman``|left|2398|0|0|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`oI'm selling all kind of `9Stuff `oFor `9Various Items `oTell Me, Which kind of `9Stuff `oDo you want to `^Buy`o?|\nadd_spacer|small|\nadd_button|purchaseyellowcrystal|`oPurchase `9Yellow Crystal `o(`@15 `2Green Crystals`o)|\nadd_button|purchaselegendaryorb|`oPurchase `8Legendary Orb `o(`@1 `cSummer Clash Ticket`o)|\nadd_spacer|small|\nadd_button|store|`#Back|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|");
										}
										else
										{
											Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wSales-Man``|left|4358|\nadd_textbox|It is I, Sales-Man, savior of the wealthy! Let me rescue you from your riches. What would you like to buy today?|left|\nadd_button|chc0|Surgery Items|noflags|0|0|\nadd_button|chc1|Wolfworld Items|noflags|0|0|\nadd_button|chc2|Zombie Defense Items|noflags|0|0|\nadd_button|chc3|Cooking Items|noflags|0|0|\nadd_button|chc4|Startopia Items|noflags|0|0|\nadd_button|chc5|Blue Gem Lock|noflags|0|0|\nend_dialog|phonecall|Hang Up||");
										}
									}
								}
								if (isTinyDialog) {
									if (infoDat[0] == "tinyname") {
										tinynames = infoDat[1];
										string upsd = tinynames;
										string act = tinynames;
										std::transform(upsd.begin(), upsd.end(), upsd.begin(), ::toupper);
										if (act == "" || act == "\\" || act.find("\\") != string::npos || act.find(" ") != string::npos || act.find("  ") != string::npos || act.find(".") != string::npos || act.find("?") != string::npos || act.find(",") != string::npos || act.find("@") != string::npos || act.find("[") != string::npos || act.find("]") != string::npos || act.find("#") != string::npos || act.find("<") != string::npos || act.find(">") != string::npos || act.find(":") != string::npos || act.find("\"") != string::npos || act.find("{") != string::npos || act.find("}") != string::npos || act.find("|") != string::npos || act.find("+") != string::npos || act.find("_") != string::npos || act.find("~") != string::npos || act.find("-") != string::npos || act.find("!") != string::npos || act.find("$") != string::npos || act.find("%") != string::npos || act.find("^") != string::npos || act.find("&") != string::npos || act.find("`") != string::npos || act.find("*") != string::npos || act.find("(") != string::npos || act.find(")") != string::npos || act.find("=") != string::npos || act.find("'") != string::npos || act.find(";") != string::npos || act.find("/") != string::npos) {
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Sorry, a world name can't contain special characters or spaces.", 0, false);
											continue;
										}
										if (!WorldExist(upsd)) {
											if (upsd.find_first_not_of("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789") != string::npos) {
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Sorry, a world name can't contain special characters or spaces.", 0, false);
												continue;
											}
											if (upsd.find(" ") != string::npos) {
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Sorry, a world name can't contain special characters or spaces.", 0, false);
												continue;
											}
											if (upsd == "EXIT") {
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "That world name already exists.  You'll have to be more original.  Maybe add some numbers after it?", 0, false);
												Player::OnConsoleMessage(peer, "That world name already exists.  You'll have to be more original.  Maybe add some numbers after it?");
												continue;
											}
											if (upsd == static_cast<PlayerInfo*>(peer->data)->currentWorld) {
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "That world name already exists.  You'll have to be more original.  Maybe add some numbers after it?", 0, false);
												Player::OnConsoleMessage(peer, "That world name already exists.  You'll have to be more original.  Maybe add some numbers after it?");
												continue;
											}
											RemoveInventoryItem(10434, 1, peer, true);
											usedtinyblast = true;
											WorldInfo info = worldDB.get(tinynames);
											if (info.name == "error") {
												Player::OnConsoleMessage(peer, "An error occured while trying to enter this world, please try again!");
												continue;
											}
											string act = tinynames;
											ENetPeer* currentPeer;
											for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
												if (isHere(peer, currentPeer)) {
													Player::OnTalkBubble(currentPeer, static_cast<PlayerInfo*>(peer->data)->netID, "`5** " + static_cast<PlayerInfo*>(peer->data)->displayName + " `5activates a Tiny Blast! `5**", 0, false);
													Player::OnConsoleMessage(currentPeer, "`5** " + static_cast<PlayerInfo*>(peer->data)->displayName + " `5activates a Tiny Blast! `5**");
												}
											}
											handle_world(peer, act);
										} else {
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "That world name already exists.  You'll have to be more original.  Maybe add some numbers after it?", 0, false);
											Player::OnConsoleMessage(peer, "That world name already exists.  You'll have to be more original.  Maybe add some numbers after it?");
										}
									}
								}
								if (isThermoDialog) {
									if (infoDat[0] == "thermoname") {
										thermonames = infoDat[1];
										string upsd = thermonames;
										string act = thermonames;
										std::transform(upsd.begin(), upsd.end(), upsd.begin(), ::toupper);
										if (act == "" || act == "\\" || act.find("\\") != string::npos || act.find(" ") != string::npos || act.find("  ") != string::npos || act.find(".") != string::npos || act.find("?") != string::npos || act.find(",") != string::npos || act.find("@") != string::npos || act.find("[") != string::npos || act.find("]") != string::npos || act.find("#") != string::npos || act.find("<") != string::npos || act.find(">") != string::npos || act.find(":") != string::npos || act.find("\"") != string::npos || act.find("{") != string::npos || act.find("}") != string::npos || act.find("|") != string::npos || act.find("+") != string::npos || act.find("_") != string::npos || act.find("~") != string::npos || act.find("-") != string::npos || act.find("!") != string::npos || act.find("$") != string::npos || act.find("%") != string::npos || act.find("^") != string::npos || act.find("&") != string::npos || act.find("`") != string::npos || act.find("*") != string::npos || act.find("(") != string::npos || act.find(")") != string::npos || act.find("=") != string::npos || act.find("'") != string::npos || act.find(";") != string::npos || act.find("/") != string::npos) {
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Sorry, a world name can't contain special characters or spaces.", 0, false);
											continue;
										}
										if (!WorldExist(upsd)) {
											if (upsd.find_first_not_of("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789") != string::npos) {
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Sorry, a world name can't contain special characters or spaces.", 0, false);
												continue;
											}
											if (upsd.find(" ") != string::npos) {
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Sorry, a world name can't contain special characters or spaces.", 0, false);
												continue;
											}
											if (upsd == "EXIT") {
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "That world name already exists.  You'll have to be more original.  Maybe add some numbers after it?", 0, false);
												Player::OnConsoleMessage(peer, "That world name already exists.  You'll have to be more original.  Maybe add some numbers after it?");
												continue;
											}
											if (upsd == static_cast<PlayerInfo*>(peer->data)->currentWorld) {
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "That world name already exists.  You'll have to be more original.  Maybe add some numbers after it?", 0, false);
												Player::OnConsoleMessage(peer, "That world name already exists.  You'll have to be more original.  Maybe add some numbers after it?");
												continue;
											}
											RemoveInventoryItem(1402, 1, peer, true);
											usedthermoblast = true;
											WorldInfo info = worldDB.get(thermonames);
											if (info.name == "error") {
												Player::OnConsoleMessage(peer, "An error occured while trying to enter this world, please try again!");
												continue;
											}
											string act = thermonames;
											ENetPeer* currentPeer;
											for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
												if (isHere(peer, currentPeer)) {
													Player::OnTalkBubble(currentPeer, static_cast<PlayerInfo*>(peer->data)->netID, "`5** " + static_cast<PlayerInfo*>(peer->data)->displayName + " `5activates a Thermonuclear Blast! `5**", 0, false);
													Player::OnConsoleMessage(currentPeer, "`5** " + static_cast<PlayerInfo*>(peer->data)->displayName + " `5activates a Thermonuclear Blast! `5**");
												}
											}
											handle_world(peer, act);
										} else {
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "That world name already exists.  You'll have to be more original.  Maybe add some numbers after it?", 0, false);
											Player::OnConsoleMessage(peer, "That world name already exists.  You'll have to be more original.  Maybe add some numbers after it?");
										}
									}
								}

								if (isLargeDialog) {
									if (infoDat[0] == "largename") {
										largenames = infoDat[1];
										string upsd = largenames;
										string act = largenames;
										std::transform(upsd.begin(), upsd.end(), upsd.begin(), ::toupper);
										if (act == "" || act == "\\" || act.find("\\") != string::npos || act.find(" ") != string::npos || act.find("  ") != string::npos || act.find(".") != string::npos || act.find("?") != string::npos || act.find(",") != string::npos || act.find("@") != string::npos || act.find("[") != string::npos || act.find("]") != string::npos || act.find("#") != string::npos || act.find("<") != string::npos || act.find(">") != string::npos || act.find(":") != string::npos || act.find("\"") != string::npos || act.find("{") != string::npos || act.find("}") != string::npos || act.find("|") != string::npos || act.find("+") != string::npos || act.find("_") != string::npos || act.find("~") != string::npos || act.find("-") != string::npos || act.find("!") != string::npos || act.find("$") != string::npos || act.find("%") != string::npos || act.find("^") != string::npos || act.find("&") != string::npos || act.find("`") != string::npos || act.find("*") != string::npos || act.find("(") != string::npos || act.find(")") != string::npos || act.find("=") != string::npos || act.find("'") != string::npos || act.find(";") != string::npos || act.find("/") != string::npos) {
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Sorry, a world name can't contain special characters or spaces.", 0, false);
											continue;
										}
										if (!WorldExist(upsd)) {
											if (upsd.find_first_not_of("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789") != string::npos) {
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Sorry, a world name can't contain special characters or spaces.", 0, false);
												continue;
											}
											if (upsd.find(" ") != string::npos) {
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Sorry, a world name can't contain special characters or spaces.", 0, false);
												continue;
											}
											if (upsd == "EXIT") {
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "That world name already exists.  You'll have to be more original.  Maybe add some numbers after it?", 0, false);
												Player::OnConsoleMessage(peer, "That world name already exists.  You'll have to be more original.  Maybe add some numbers after it?");
												continue;
											}
											if (upsd == static_cast<PlayerInfo*>(peer->data)->currentWorld) {
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "That world name already exists.  You'll have to be more original.  Maybe add some numbers after it?", 0, false);
												Player::OnConsoleMessage(peer, "That world name already exists.  You'll have to be more original.  Maybe add some numbers after it?");
												continue;
											}
											RemoveInventoryItem(10428, 1, peer, true);
											usedlargeblast = true;
											WorldInfo info = worldDB.get(largenames);
											if (info.name == "error") {
												Player::OnConsoleMessage(peer, "An error occured while trying to enter this world, please try again!");
												continue;
											}
											string act = largenames;
											ENetPeer* currentPeer;
											for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
												if (isHere(peer, currentPeer)) {
													Player::OnTalkBubble(currentPeer, static_cast<PlayerInfo*>(peer->data)->netID, "`5** " + static_cast<PlayerInfo*>(peer->data)->displayName + " `5activates a Large Blast! `5**", 0, false);
													Player::OnConsoleMessage(currentPeer, "`5** " + static_cast<PlayerInfo*>(peer->data)->displayName + " `5activates a Large Blast! `5**");
												}
											}
											handle_world(peer, act);
										} else {
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "That world name already exists.  You'll have to be more original.  Maybe add some numbers after it?", 0, false);
											Player::OnConsoleMessage(peer, "That world name already exists.  You'll have to be more original.  Maybe add some numbers after it?");
										}
									}
								}
								if (isGuildDialog) {
									if (world == nullptr || static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT" || serverIsFrozen) continue;
									if (infoDat[0] == "gname") guild_name = infoDat[1];
									if (infoDat[0] == "gstatement") guild_statement = infoDat[1];
									if (infoDat[0] == "ggcflagbg") guild_mascot_bg = infoDat[1];
									if (infoDat[0] == "ggcflagfg") {
										guild_mascot_fg = infoDat[1];
										int GCState = PlayerDB::guildRegister(peer, guild_name, guild_statement, guild_mascot_bg, guild_mascot_fg);
										switch (GCState) {
											case -1:
											{
												Player::OnConsoleMessage(peer, "");
												break;
											}
											case -2:
											{
												Player::OnConsoleMessage(peer, "");
												break;
											}
											case -3:
											{
												Player::OnConsoleMessage(peer, "");
												break;
											}
											case -4:
											{
												Player::OnConsoleMessage(peer, "");
												break;
											}
											case -5:
											{
												Player::OnConsoleMessage(peer, "");
												break;
											}
											case -6:
											{
												Player::OnConsoleMessage(peer, "");
												break;
											}
											case -7:
											{
												Player::OnConsoleMessage(peer, "");
												break;
											}
											case -8:
											{
												Player::OnConsoleMessage(peer, "");
												break;
											}
											case 1:
											{
												Player::OnConsoleMessage(peer, "");
												break;
											}
											default: break;
										}
									}
								}
								if (isRegisterDialog) {
									if (infoDat[0] == "username") register_username = infoDat[1];
									if (infoDat[0] == "password") register_password = infoDat[1];
									if (infoDat[0] == "password_verify") register_password_verify = infoDat[1];
									if (infoDat[0] == "email") {
										register_email = infoDat[1];
										if (register_password != register_password_verify) {
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Passwords dont match!", 0, true);
											break;
										}
										auto regState = PlayerDB::playerRegister(peer, register_username, register_password, register_email);
										switch (regState) {
											case 1:
											{
												GamePacket p8 = packetEnd(appendString(appendString(appendInt(appendString(createPacket(), "SetHasGrowID"), 1), register_username), register_password));
												ENetPacket* packet8 = enet_packet_create(p8.data, p8.len, ENET_PACKET_FLAG_RELIABLE);
												enet_peer_send(peer, 0, packet8);
												delete p8.data;
												static_cast<PlayerInfo*>(peer->data)->displayName = register_username;
												static_cast<PlayerInfo*>(peer->data)->tankIDName = register_username;
												static_cast<PlayerInfo*>(peer->data)->tankIDPass = register_password;
												static_cast<PlayerInfo*>(peer->data)->rawName = PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->tankIDName);
												static_cast<PlayerInfo*>(peer->data)->msgName = PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->tankIDName);
												static_cast<PlayerInfo*>(peer->data)->haveGrowId = true;
												static_cast<PlayerInfo*>(peer->data)->HasLogged = true;
												static_cast<PlayerInfo*>(peer->data)->effect = 8421376;
												Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wGrowID GET!``|left|206|\nadd_textbox|A `wGrowID`` with the log on of `w" + static_cast<PlayerInfo*>(peer->data)->displayName + "`` created.  Write it and your password down as they will be required to log on from now on!|left|\nend_dialog|growid_apply|Continue||");
												Player::PlayAudio(peer, "audio/piano_nice.wav", 150);
												ofstream myfile;
												myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
												myfile << 1000;
												myfile.close();
												Player::OnSetBux(peer, 1000, 1);
												GamePacket p7 = packetEnd(appendString(appendString(createPacket(), "OnNameChanged"), register_username));
												memcpy(p7.data + 8, &(static_cast<PlayerInfo*>(peer->data)->netID), 4);
												ENetPacket* packet7 = enet_packet_create(p7.data, p7.len, ENET_PACKET_FLAG_RELIABLE);
												for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
													if (isHere(peer, currentPeer)) {
														enet_peer_send(currentPeer, 0, packet7);
													}
												}
												delete p7.data;
												LoadPlayerData(peer);
												DailyRewardCheck(peer);
												auto success = true;
												SaveItemMoreTimes(6336, 1, peer, success, static_cast<PlayerInfo*>(peer->data)->rawName + " from system");
												break;
											}
											case -1:
											{
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "This account already exists!", 0, true);
												break;
											}
											case -2:
											{
												Player::OnConsoleMessage(peer, "`@Account creation failed, because the name is too short!``");
												break;
											}
											case -15:
											{
												Player::OnConsoleMessage(peer, "`@Account creation failed, because email address is invalid!``");
												break;
											}
											case -10:
											{
												Player::OnConsoleMessage(peer, "`@Player name contains illegal characters.``");
												break;
											}
											case -14:
											{
												Player::OnConsoleMessage(peer, "`@Account creation failed, because you have `4too much `@accounts created.``");
												break;
											}
										}
									}
								}
							}
						}
						int x = static_cast<PlayerMoving*>(peer->data)->punchX;
						int y = static_cast<PlayerMoving*>(peer->data)->punchY;
						int causedBy = static_cast<PlayerMoving*>(peer->data)->netID;
						int tile = static_cast<PlayerMoving*>(peer->data)->plantingTree;
						if (btn.substr(0, 23) == "removeselectedbulletin_")
						{
							if (world == nullptr || static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT" || serverIsFrozen) continue;
							if (static_cast<PlayerInfo*>(peer->data)->rawName == world->owner || world->owner == "" || isMod(peer))
							{
								string coord, apos;
								string coord_and_apos = btn.erase(0, 23);
								string::size_type pos = coord_and_apos.find('_');
								if (pos != std::string::npos)
								{
									coord = coord_and_apos.substr(0, pos);
									coord_and_apos.erase(0, pos + 1);
									apos = coord_and_apos;
								}
								else
								{
									autoBan(peer, false, 24 * 7, "Incorrect parameters removeselectedbulletin_. Coord and id were: " + coord_and_apos);
									break;
								}
								auto isdbox = std::experimental::filesystem::exists("bulletinboard/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
								if (!isdbox)
								{
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured while getting safe bulletin board.", 0, true);
									break;
								}

								bool contains_non_int3 = !std::regex_match(apos, std::regex("^[0-9]+$"));
								if (contains_non_int3 == true)
								{
									autoBan(peer, false, 24 * 7, "Proxy detect! removeselectedbulletin_ apos was: " + apos);
									break;
								}
								int apos_int = atoi(apos.c_str());
								if (apos_int < 1 || apos_int > 90)
								{
									autoBan(peer, false, 24 * 7, "Proxy detect! removeselectedbulletin_ apos was: " + apos);
									break;
								}
								try
								{
									ifstream ifff("bulletinboard/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
									json j;
									ifff >> j;
									ifff.close();
									string tekstas = j["mails"][apos_int - 1]["text"];
									GTDialog myLetterBox;
									myLetterBox.addLabelWithIcon("`oRemove \"" + tekstas + "\" from your board?", 658, LABEL_BIG);
									myLetterBox.addButton("Confirmremoveselectedbulletin_" + coord + "_" + apos, "`wOK");
									myLetterBox.addSpacer(SPACER_SMALL);
									myLetterBox.addQuickExit();
									myLetterBox.endDialog("Close", "", "Cancel");
									Player::OnDialogRequest(peer, myLetterBox.finishDialog());
								}
								catch (std::exception&)
								{
									cout << "bulletin kodas failed" << endl;
									break; /*tipo jeigu nera*/
								}
							}
						}
						if (btn.substr(0, 30) == "Confirmremoveselectedbulletin_")
						{
							if (world == nullptr || static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT" || serverIsFrozen) continue;
							if (static_cast<PlayerInfo*>(peer->data)->rawName == world->owner || world->owner == "" || isMod(peer))
							{
								string coord, apos;
								string coord_and_apos = btn.erase(0, 30);
								string::size_type pos = coord_and_apos.find('_');
								if (pos != std::string::npos)
								{
									coord = coord_and_apos.substr(0, pos);
									coord_and_apos.erase(0, pos + 1);
									apos = coord_and_apos;
								}
								else
								{
									autoBan(peer, false, 24 * 7, "Incorrect parameters Confirmremoveselectedbulletin_. Coord and id were: " + coord_and_apos);
									break;
								}
								auto isdbox = std::experimental::filesystem::exists("bulletinboard/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
								if (!isdbox)
								{
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured while getting safe bulletin board.", 0, true);
									break;
								}

								bool contains_non_int3 = !std::regex_match(apos, std::regex("^[0-9]+$"));
								if (contains_non_int3 == true)
								{
									autoBan(peer, false, 24 * 7, "Proxy detect! Confirmremoveselectedbulletin_ apos was: " + apos);
									break;
								}
								int apos_int = atoi(apos.c_str());
								if (apos_int < 1 || apos_int > 90)
								{
									autoBan(peer, false, 24 * 7, "Proxy detect! Confirmremoveselectedbulletin_ apos was: " + apos);
									break;
								}
								try
								{
									ifstream ifff("bulletinboard/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
									json j;
									ifff >> j;
									ifff.close();
									int inmail = j["inmail"];
									j["inmail"] = inmail - 1;
									j["mails"][apos_int - 1]["text"] = "";
									j["mails"][apos_int - 1]["growid"] = "";
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`2Bulletin removed.", 0, true);
									ofstream of("bulletinboard/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
									of << j << std::endl;
									of.close();
								}
								catch (std::exception&)
								{
									cout << "bulletin kodas failed" << endl;
									break; /*tipo jeigu nera*/
								}
							}
						}
						if (btn.substr(0, 18) == "addbulletinletter_")
						{
							if (world == nullptr || static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT" || serverIsFrozen) continue;
							string coord = btn.substr(btn.find("_") + 1);
							auto isdbox = std::experimental::filesystem::exists("bulletinboard/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
							if (!isdbox)
							{
								Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured while getting bulletin board info.", 0, true);
								continue;
							}

							std::stringstream bss(cch);
							std::string bto;

							string addtext = "";

							while (std::getline(bss, bto, '\n'))
							{
								vector<string> infoDat = explode("|", bto);
								if (infoDat[0] == "addbulletinletterinput")
								{
									addtext = infoDat[1];
								}
							}
							if (addtext.length() < 3)
							{
								Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wThat's not interesting enough to post.", 0, true);
								continue;
							}

							try
							{
								ifstream ifff("bulletinboard/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
								json j;
								ifff >> j;
								ifff.close();
								if (j["inmail"] >= 90)
								{
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Bulletin Board is full!", 0, true);
									continue;
								}
								for (int i = 0; i < 90; i++)
								{
									if (j["mails"][i]["growid"] == "")
									{
										j["mails"][i]["growid"] = static_cast<PlayerInfo*>(peer->data)->displayName;
										j["mails"][i]["text"] = addtext;
										int inmail = j["inmail"];
										j["inmail"] = inmail + 1;
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`2Bulletin posted.", 0, true);

										ofstream of("bulletinboard/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
										of << j << std::endl;
										of.close();

										break;
									}
								}
							}
							catch (std::exception&)
							{
								cout << "bulletin kodas failed" << endl;
								break; /*tipo jeigu nera*/
							}
						}
						if (btn.substr(0, 17) == "bulletinletterok_")
						{
							if (world == nullptr || static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT" || serverIsFrozen) continue;
							string coord = btn.substr(btn.find("_") + 1);
							auto isdbox = std::experimental::filesystem::exists("bulletinboard/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
							if (!isdbox)
							{
								Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured while getting bulletin board info.", 0, true);
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->rawName == world->owner || world->owner == "" || isMod(peer))
							{
								std::stringstream bss(cch);
								std::string bto;

								string publiccanadd = "";
								string hidenames = "";

								while (std::getline(bss, bto, '\n'))
								{
									vector<string> infoDat = explode("|", bto);
									if (infoDat[0] == "publiccanaddbulletinboard")
									{
										publiccanadd = infoDat[1];
									}
									if (infoDat[0] == "hidenamesbulletinboard")
									{
										hidenames = infoDat[1];
									}
								}
								if (publiccanadd != "" && hidenames != "")
								{
									int does_pubiccanadd = atoi(publiccanadd.c_str());
									int are_hidenames = atoi(hidenames.c_str());
									if ((does_pubiccanadd != 0 && does_pubiccanadd != 1) || (are_hidenames != 0 && are_hidenames != 1))
									{
										autoBan(peer, false, 24 * 7, "Incorrect parameters bulletinletterok_. publiccanadd was " + publiccanadd + ",hidenames was " + hidenames + "");
										break;
									}
									try
									{
										ifstream ifff("bulletinboard/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
										json j;
										ifff >> j;
										ifff.close();

										j["hidenames"] = are_hidenames;
										j["publiccanadd"] = does_pubiccanadd;

										ofstream of("bulletinboard/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
										of << j << std::endl;
										of.close();
									}
									catch (std::exception&)
									{
										SendConsole("bulletinboardclear_ Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_later(peer, 0);
									}
									catch (std::runtime_error&)
									{
										SendConsole("bulletinboardclear_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_later(peer, 0);
									}
									catch (...)
									{
										SendConsole("bulletinboardclear_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_later(peer, 0);
									}
								}
							}
						}
						if (btn.substr(0, 19) == "bulletinboardclear_")
						{
							if (world == nullptr || static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT" || serverIsFrozen) continue;
							string coord = btn.substr(btn.find("_") + 1);
							auto isdbox = std::experimental::filesystem::exists("bulletinboard/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
							if (!isdbox)
							{
								Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured while getting bulletin board info.", 0, true);
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->rawName == world->owner || world->owner == "" || isMod(peer))
							{
								try
								{
									ifstream ifff("bulletinboard/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
									json j;
									ifff >> j;
									ifff.close();
									if (j["inmail"] < 1)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4There is no any mails!", 0, true);
										continue;
									}
									for (int i = 0; i < 90; i++)
									{
										j["mails"][i]["growid"] = "";
										j["mails"][i]["text"] = "";
									}
									j["inmail"] = 0;
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`2Bulletin Board emptied.", 0, true);

									ofstream of("bulletinboard/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
									of << j << std::endl;
									of.close();
								}
								catch (std::exception&)
								{
									SendConsole("bulletinboardclear_ Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_later(peer, 0);
								}
								catch (std::runtime_error&)
								{
									SendConsole("bulletinboardclear_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_later(peer, 0);
								}
								catch (...)
								{
									SendConsole("bulletinboardclear_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_later(peer, 0);
								}
							}
						}
						if (btn.substr(0, 10) == "mailempty_")
						{
							if (world == nullptr || static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT" || serverIsFrozen) continue;
							string coord = btn.substr(btn.find("_") + 1);
							auto isdbox = std::experimental::filesystem::exists("mailbox/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
							if (!isdbox)
							{
								Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured while getting mailbox info.", 0, true);
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->rawName == world->owner || world->owner == "" || isMod(peer))
							{
								try
								{
									ifstream ifff("mailbox/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
									json j;
									ifff >> j;
									ifff.close();
									if (j["inmail"] < 1)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4There is no any mails!", 0, true);
										continue;
									}
									for (int i = 0; i < 20; i++)
									{
										j["mails"][i]["growid"] = "";
										j["mails"][i]["text"] = "";
									}
									j["inmail"] = 0;
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`2Mailbox emptied.", 0, true);

									int x = j["x"];
									int y = j["y"];
									ENetPeer* currentPeer;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
										if (isHere(peer, currentPeer))
										{
											RemoveItemPacket(currentPeer, 656, 0, x, y, 1);
										}
									}
									ofstream of("mailbox/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
									of << j << std::endl;
									of.close();
								}
								catch (std::exception&)
								{
									SendConsole("mailempty_ Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_later(peer, 0);
								}
								catch (std::runtime_error&)
								{
									SendConsole("mailempty_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_later(peer, 0);
								}
								catch (...)
								{
									SendConsole("mailempty_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_later(peer, 0);
								}
							}
						}
						if (btn.substr(0, 14) == "bluemailempty_")
						{
							if (world == nullptr || static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT" || serverIsFrozen) continue;
							string coord = btn.substr(btn.find("_") + 1);
							auto isdbox = std::experimental::filesystem::exists("bluemailbox/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
							if (!isdbox)
							{
								Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured while getting blue mailbox info.", 0, true);
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->rawName == world->owner || world->owner == "" || isMod(peer))
							{
								try
								{
									ifstream ifff("bluemailbox/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
									json j;
									ifff >> j;
									ifff.close();
									if (j["inmail"] < 1)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4There is no any mails!", 0, true);
										continue;
									}
									for (int i = 0; i < 20; i++)
									{
										j["mails"][i]["growid"] = "";
										j["mails"][i]["text"] = "";
									}
									j["inmail"] = 0;
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`2Mailbox emptied.", 0, true);

									int x = j["x"];
									int y = j["y"];
									ENetPeer* currentPeer;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
										if (isHere(peer, currentPeer))
										{
											RemoveItemPacket(currentPeer, 1006, 0, x, y, 1);
										}
									}
									ofstream of("bluemailbox/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
									of << j << std::endl;
									of.close();
								}
								catch (std::exception&)
								{
									SendConsole("bluemailempty_ Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_later(peer, 0);
								}
								catch (std::runtime_error&)
								{
									SendConsole("bluemailempty_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_later(peer, 0);
								}
								catch (...)
								{
									SendConsole("bluemailempty_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_later(peer, 0);
								}
							}
						}
						if (btn.substr(0, 14) == "retrieveGifts_")
						{
							if (world == nullptr || static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT" || serverIsFrozen) continue;
							string coord = btn.substr(btn.find("_") + 1);
							auto isdbox = std::experimental::filesystem::exists("donationboxes/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
							if (!isdbox)
							{
								Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured while getting donation box info.", 0, true);
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->rawName == world->owner || world->owner == "" || isMod(peer))
							{
								try
								{
									ifstream ifff("donationboxes/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
									json j;
									ifff >> j;
									ifff.close();
									if (j["donated"] < 1)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4There is no any donations!", 0, true);
										continue;
									}
									bool success = true;
									for (int i = 0; i < 20; i++)
									{
										if (j["donatedItems"][i]["itemid"] != 0)
										{
											int howManyEarnings = j["donatedItems"][i]["itemcount"];
											int itemid = j["donatedItems"][i]["itemid"];
											string whoSent = j["donatedItems"][i]["sentBy"];
											if (j["donatedItems"][i]["itemcount"] > 250)
											{
												Player::OnTextOverlay(peer, "You cant receive that!");
												break;
											}
											if (CheckItemExists(peer, j["donatedItems"][i]["itemid"]))
											{
												int currentlyHave = GetQuantityOfItem(peer, j["donatedItems"][i]["itemid"]);
												if (j["donatedItems"][i]["itemcount"].get<double>() + currentlyHave < 251)
												{
													SaveItemMoreTimes(j["donatedItems"][i]["itemid"], j["donatedItems"][i]["itemcount"], peer, success, static_cast<PlayerInfo*>(peer->data)->rawName + " from donation box");
													j["donatedItems"][i]["itemid"] = 0;
													j["donatedItems"][i]["itemcount"] = 0;
													j["donatedItems"][i]["sentBy"] = "";
													j["donatedItems"][i]["note"] = "";
													j["donated"] = j["donated"].get<double>() - 1;
													ENetPeer* currentPeer;
													for (currentPeer = server->peers;
														currentPeer < &server->peers[server->peerCount];
														++currentPeer)
													{
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
														if (isHere(peer, currentPeer))
														{
															Player::OnConsoleMessage(currentPeer, "`w[`o" + static_cast<PlayerInfo*>(peer->data)->displayName + " `oreceives `5" + to_string(howManyEarnings) + " `w" + itemDefs[itemid].name + " `ofrom `w" + whoSent + "`o, how nice!`w]");
														}
													}
													Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`2Box emptied.", 0, true);
												}
												else
												{
													int kiekTrukstaIki250 = 250 - currentlyHave;
													SaveItemMoreTimes(j["donatedItems"][i]["itemid"], kiekTrukstaIki250, peer, success, static_cast<PlayerInfo*>(peer->data)->rawName + " from " + getItemDef(world->items[static_cast<PlayerInfo*>(peer->data)->lastPunchX + (static_cast<PlayerInfo*>(peer->data)->lastPunchY * world->width)].foreground).name + "");
													j["donatedItems"][i]["itemcount"] = j["donatedItems"][i]["itemcount"].get<double>() - kiekTrukstaIki250;
													howManyEarnings -= kiekTrukstaIki250;
													ENetPeer* currentPeer;
													for (currentPeer = server->peers;
														currentPeer < &server->peers[server->peerCount];
														++currentPeer)
													{
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
														if (isHere(peer, currentPeer))
														{
															Player::OnConsoleMessage(currentPeer, "`w[`o" + static_cast<PlayerInfo*>(peer->data)->rawName + " receives `5" + to_string(kiekTrukstaIki250) + " (`w" + to_string(howManyEarnings) + " `5left) `w" + itemDefs[itemid].name + " `ofrom `w" + whoSent + "`o, how nice!`w]");
														}
													}
													Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`2Box emptied.", 0, true);
												}
											}
											else
											{
												if (static_cast<PlayerInfo*>(peer->data)->inventory.items.size() == static_cast<PlayerInfo*>(peer->data)->currentInventorySize)
												{
													Player::OnTextOverlay(peer, "`4Your inventory is full! You can purchase an inventory upgrade in the shop.");
													break;
												}

												SaveItemMoreTimes(j["donatedItems"][i]["itemid"], j["donatedItems"][i]["itemcount"], peer, success, static_cast<PlayerInfo*>(peer->data)->rawName + " from donation box");
												j["donatedItems"][i]["itemid"] = 0;
												j["donatedItems"][i]["itemcount"] = 0;
												j["donatedItems"][i]["sentBy"] = "";
												j["donatedItems"][i]["note"] = "";
												j["donated"] = j["donated"].get<double>() - 1;
												ENetPeer* currentPeer;
												for (currentPeer = server->peers;
													currentPeer < &server->peers[server->peerCount];
													++currentPeer)
												{
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
													if (isHere(peer, currentPeer))
													{
														Player::OnConsoleMessage(currentPeer, "`w[`o" + static_cast<PlayerInfo*>(peer->data)->rawName + " receives `5" + to_string(howManyEarnings) + " `w" + itemDefs[itemid].name + " `ofrom `w" + whoSent + "`o, how nice!`w]");
													}
												}
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`2Box emptied.", 0, true);
											}
										}
									}

									if (j["donated"] <= 0)
									{
										ENetPeer* currentPeer;
										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
											if (isHere(peer, currentPeer))
											{
												if (static_cast<PlayerInfo*>(peer->data)->lastPunchX >= 0 && static_cast<PlayerInfo*>(peer->data)->lastPunchY >= 0)
												{
													RemoveItemPacket(currentPeer, world->items[static_cast<PlayerInfo*>(peer->data)->lastPunchX + (static_cast<PlayerInfo*>(peer->data)->lastPunchY * world->width)].foreground, 0, static_cast<PlayerInfo*>(peer->data)->lastPunchX, static_cast<PlayerInfo*>(peer->data)->lastPunchY, 1);
												}
											}
										}
									}
									ofstream of("donationboxes/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
									of << j << std::endl;
									of.close();
								}
								catch (std::exception&)
								{
									SendConsole("retrieveGifts_ Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_later(peer, 0);
								}
								catch (std::runtime_error&)
								{
									SendConsole("retrieveGifts_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_later(peer, 0);
								}
								catch (...)
								{
									SendConsole("retrieveGifts_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_later(peer, 0);
								}
							}
						}
						if (btn.substr(0, 15) == "safeupdatepass_")
						{
							if (world == nullptr || static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT" || serverIsFrozen) continue;
							string coord = btn.substr(btn.find("_") + 1);
							auto isdbox = std::experimental::filesystem::exists("safevault/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
							if (!isdbox)
							{
								Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured. Break the safe.", 0, true);
							}
							else
							{
								if (static_cast<PlayerInfo*>(peer->data)->rawName == PlayerDB::getProperName(world->owner) || world->owner == "" || isMod(peer))
								{
									try
									{
										GTDialog mySafe;
										mySafe.addLabelWithIcon("`wSafe Vault", 8878, LABEL_BIG);
										ifstream ifff("safevault/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
										json j;
										ifff >> j;
										if (j["password"] == "")
										{
											mySafe.addSmallText("The ingenious minds at GrowTech bring you the `2Safe Vault`` - a place to store your items safely with its integrated password option!");
											mySafe.addSmallText("How the password works:");
											mySafe.addSmallText("The Safe Vault requires both a `2password`` and a `2recovery answer`` to be entered to use a password.");
											mySafe.addSmallText("Enter your `2password`` and `2recovery answer`` below - keep them safe and `4DO NOT`` share them with anyone you do not trust!");
											mySafe.addSmallText("The password and recovery answer can be no longer than 12 characters in length - number and alphabet only please, no special characters are allowed!");
											mySafe.addSmallText("If you forget your password, enter your recovery answer to access the Safe Vault - The Safe Vault will `4NOT be password protected now``. You will need to enter a new password.");
											mySafe.addSmallText("You can change your password, however you will need to enter the old password before a new one can be used.");
											mySafe.addSmallText("`4WARNING``: DO NOT forget your password and recovery answer or you will not be able to access the Safe Vault!");
											mySafe.addSmallText("`4There is no password currently set on this Safe Vault.``");
											mySafe.addSmallText("Enter a new password.");
											mySafe.addInputBox("safenewpass_" + coord, "", "", 18);
											mySafe.addSmallText("Enter a recovery answer.");
											mySafe.addInputBox("safe_recoverypass", "", "", 12);
											mySafe.addButton("safe_setpassword", "Update Password");
											mySafe.addSpacer(SPACER_SMALL);
											mySafe.addQuickExit();
											mySafe.endDialog("Close", "", "Exit");
											Player::OnDialogRequest(peer, mySafe.finishDialog());
										}
										else
										{
											mySafe.addSmallText("The ingenious minds at GrowTech bring you the `2Safe Vault`` - a place to store your items safely with its integrated password option!");
											mySafe.addSmallText("How the password works:");
											mySafe.addSmallText("The Safe Vault requires both a `2password`` and a `2recovery answer`` to be entered to use a password.");
											mySafe.addSmallText("Enter your `2password`` and `2recovery answer`` below - keep them safe and `4DO NOT`` share them with anyone you do not trust!");
											mySafe.addSmallText("The password and recovery answer can be no longer than 12 characters in length - number and alphabet only please, no special characters are allowed!");
											mySafe.addSmallText("If you forget your password, enter your recovery answer to access the Safe Vault - The Safe Vault will `4NOT be password protected now``. You will need to enter a new password.");
											mySafe.addSmallText("You can change your password, however you will need to enter the old password before a new one can be used.");
											mySafe.addSmallText("`4WARNING``: DO NOT forget your password and recovery answer or you will not be able to access the Safe Vault!");
											mySafe.addSmallText("Enter your old password.");
											mySafe.addInputBox("safeoldpassword_" + coord, "", "", 18);
											mySafe.addSmallText("Enter a new password.");
											mySafe.addInputBox("safe_newpassword", "", "", 18);
											mySafe.addSmallText("Enter a recovery answer.");
											mySafe.addInputBox("storage_recoveryanswer", "", "", 12);
											mySafe.addButton("safe_updatepassword", "Update Password");
											mySafe.addSmallText("Remove the password protection from the `5Safe Vault``.");
											mySafe.addSmallText("You will need to enter the old password to remove the password protection.");
											mySafe.addButton("safe_removepassword", "Remove Password");
											mySafe.addSpacer(SPACER_SMALL);
											mySafe.addQuickExit();
											mySafe.endDialog("Close", "", "Exit");
											Player::OnDialogRequest(peer, mySafe.finishDialog());
										}
									}
									catch (std::exception&)
									{
										SendConsole("safeupdatepass_ Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_later(peer, 0);
									}
									catch (std::runtime_error&)
									{
										SendConsole("safeupdatepass_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_later(peer, 0);
									}
									catch (...)
									{
										SendConsole("safeupdatepass_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_later(peer, 0);
									}
								}
							}
						}
						if (btn.substr(0, 21) == "boxlvl2DepositedItem_")
						{
							if (world == nullptr || static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT" || serverIsFrozen) continue;
							if (static_cast<PlayerInfo*>(peer->data)->rawName == PlayerDB::getProperName(world->owner) || world->owner == "" || isMod(peer))
							{
								string apos_and_coord = btn.erase(0, 21);
								string::size_type pos = apos_and_coord.find('_');
								string apos = "";
								string coord = "";

								if (pos != std::string::npos)
								{
									apos = apos_and_coord.substr(0, pos);
									apos_and_coord.erase(0, pos + 1);
									coord = apos_and_coord;
								}
								else
								{
									autoBan(peer, false, 24 * 7, "Incorrect parameters boxlvl2DepositedItem_. apos and coord were: " + apos_and_coord);
									break;
								}
								auto isdbox = std::experimental::filesystem::exists("storageboxlvl2/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
								if (!isdbox)
								{
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured while getting box info.", 0, true);
									break;
								}

								bool contains_non_int3 = !std::regex_match(apos, std::regex("^[0-9]+$"));
								if (contains_non_int3 == true)
								{
									autoBan(peer, false, 24 * 7, "Proxy detect! boxlvl2DepositedItem_ apos was: " + apos);
									break;
								}

								try
								{
									ifstream ifff("storageboxlvl2/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
									json j;
									ifff >> j;
									ifff.close();

									int itemid = 0;
									int count = 0;
									for (int i = 0; i < 40; i++)
									{
										if (j["storage"][i]["aposition"] == atoi(apos.c_str()))
										{
											itemid = j["storage"][i]["itemid"];
											count = j["storage"][i]["itemcount"];
											GTDialog storagelvl1;
											storagelvl1.addLabelWithIcon("`wStorage Box Xtreme - Level 2", 6288, LABEL_BIG);
											storagelvl1.addSmallText("`oYou have `w" + to_string(count) + " " + itemDefs[itemid].name + " `ostored.");
											storagelvl1.addSmallText("`oWithdraw how many?");
											storagelvl1.addInputBox("boxlvl2withdraw_" + coord + "_" + apos, "", to_string(count), 5);
											storagelvl1.addSpacer(SPACER_SMALL);
											storagelvl1.addButton("boxlvl2_withdrawConfirm", "Remove items");
											storagelvl1.addSpacer(SPACER_SMALL);
											storagelvl1.addQuickExit();
											storagelvl1.endDialog("Close", "", "Exit");
											Player::OnDialogRequest(peer, storagelvl1.finishDialog());
											break;
										}
									}
								}
								catch (std::exception&)
								{
									SendConsole("boxlvl2DepositedItem_ Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_later(peer, 0);
								}
								catch (std::runtime_error&)
								{
									SendConsole("boxlvl2DepositedItem_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_later(peer, 0);
								}
								catch (...)
								{
									SendConsole("boxlvl2DepositedItem_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_later(peer, 0);
								}
							}
						}
						if (btn.substr(0, 21) == "boxlvl3DepositedItem_")
						{
							if (world == nullptr || static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT" || serverIsFrozen) continue;
							if (static_cast<PlayerInfo*>(peer->data)->rawName == PlayerDB::getProperName(world->owner) || world->owner == "" || isMod(peer))
							{
								string apos_and_coord = btn.erase(0, 21);
								string::size_type pos = apos_and_coord.find('_');
								string apos = "";
								string coord = "";

								if (pos != std::string::npos)
								{
									apos = apos_and_coord.substr(0, pos);
									apos_and_coord.erase(0, pos + 1);
									coord = apos_and_coord;
								}
								else
								{
									autoBan(peer, false, 24 * 7, "Incorrect parameters boxlvl3DepositedItem_. apos and coord were: " + apos_and_coord);
									break;
								}
								auto isdbox = std::experimental::filesystem::exists("storageboxlvl3/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
								if (!isdbox)
								{
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured while getting box info.", 0, true);
									break;
								}

								bool contains_non_int3 = !std::regex_match(apos, std::regex("^[0-9]+$"));
								if (contains_non_int3 == true)
								{
									autoBan(peer, false, 24 * 7, "Proxy detect! boxlvl3DepositedItem_ apos was: " + apos);
									break;
								}

								try
								{
									ifstream ifff("storageboxlvl3/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
									json j;
									ifff >> j;
									ifff.close();

									int itemid = 0;
									int count = 0;
									for (int i = 0; i < 90; i++)
									{
										if (j["storage"][i]["aposition"] == atoi(apos.c_str()))
										{
											itemid = j["storage"][i]["itemid"];
											count = j["storage"][i]["itemcount"];
											GTDialog storagelvl1;
											storagelvl1.addLabelWithIcon("`wStorage Box Xtreme - Level 3", 6290, LABEL_BIG);
											storagelvl1.addSmallText("`oYou have `w" + to_string(count) + " " + itemDefs[itemid].name + " `ostored.");
											storagelvl1.addSmallText("`oWithdraw how many?");
											storagelvl1.addInputBox("boxlvl3withdraw_" + coord + "_" + apos, "", to_string(count), 5);
											storagelvl1.addSpacer(SPACER_SMALL);
											storagelvl1.addButton("boxlvl3_withdrawConfirm", "Remove items");
											storagelvl1.addSpacer(SPACER_SMALL);
											storagelvl1.addQuickExit();
											storagelvl1.endDialog("Close", "", "Exit");
											Player::OnDialogRequest(peer, storagelvl1.finishDialog());
											break;
										}
									}
								}
								catch (std::exception&)
								{
									SendConsole("boxlvl3DepositedItem_ Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_later(peer, 0);
								}
								catch (std::runtime_error&)
								{
									SendConsole("boxlvl3DepositedItem_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_later(peer, 0);
								}
								catch (...)
								{
									SendConsole("boxlvl3DepositedItem_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_later(peer, 0);
								}
							}
						}
						if (btn.substr(0, 21) == "boxlvl1DepositedItem_")
						{
							if (world == nullptr || static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT" || serverIsFrozen) continue;
							if (static_cast<PlayerInfo*>(peer->data)->rawName == PlayerDB::getProperName(world->owner) || world->owner == "" || isMod(peer))
							{
								string apos_and_coord = btn.erase(0, 21);
								string::size_type pos = apos_and_coord.find('_');
								string apos = "";
								string coord = "";

								if (pos != std::string::npos)
								{
									apos = apos_and_coord.substr(0, pos);
									apos_and_coord.erase(0, pos + 1);
									coord = apos_and_coord;
								}
								else
								{
									autoBan(peer, false, 24 * 7, "Incorrect parameters boxlvl1DepositedItem_. apos and coord were: " + apos_and_coord);
									break;
								}
								auto isdbox = std::experimental::filesystem::exists("storageboxlvl1/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
								if (!isdbox)
								{
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured while getting box info.", 0, true);
									break;
								}

								bool contains_non_int3 = !std::regex_match(apos, std::regex("^[0-9]+$"));
								if (contains_non_int3 == true)
								{
									autoBan(peer, false, 24 * 7, "Proxy detect! boxlvl1DepositedItem_ apos was: " + apos);
									break;
								}

								try
								{
									ifstream ifff("storageboxlvl1/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
									json j;
									ifff >> j;
									ifff.close();

									int itemid = 0;
									int count = 0;
									for (int i = 0; i < 20; i++)
									{
										if (j["storage"][i]["aposition"] == atoi(apos.c_str()))
										{
											itemid = j["storage"][i]["itemid"];
											count = j["storage"][i]["itemcount"];
											GTDialog storagelvl1;
											storagelvl1.addLabelWithIcon("`wStorage Box Xtreme - Level 1", 6286, LABEL_BIG);
											storagelvl1.addSmallText("`oYou have `w" + to_string(count) + " " + itemDefs[itemid].name + " `ostored.");
											storagelvl1.addSmallText("`oWithdraw how many?");
											storagelvl1.addInputBox("boxlvl1withdraw_" + coord + "_" + apos, "", to_string(count), 5);
											storagelvl1.addSpacer(SPACER_SMALL);
											storagelvl1.addButton("boxlvl1_withdrawConfirm", "Remove items");
											storagelvl1.addSpacer(SPACER_SMALL);
											storagelvl1.addQuickExit();
											storagelvl1.endDialog("Close", "", "Exit");
											Player::OnDialogRequest(peer, storagelvl1.finishDialog());
											break;
										}
									}
								}
								catch (std::exception&)
								{
									SendConsole("boxlvl1DepositedItem_ Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_later(peer, 0);
								}
								catch (std::runtime_error&)
								{
									SendConsole("boxlvl1DepositedItem_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_later(peer, 0);
								}
								catch (...)
								{
									SendConsole("boxlvl1DepositedItem_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_later(peer, 0);
								}
							}
						}
						if (btn == "goals") {
							int firefighterxp = 1500;
							if (static_cast<PlayerInfo*>(peer->data)->firefighterlevel > 0) firefighterxp = firefighterxp * static_cast<PlayerInfo*>(peer->data)->firefighterlevel;
							if (static_cast<PlayerInfo*>(peer->data)->firefighterlevel == 0) firefighterxp = 750;
							int providerxp = 1300;
							if (static_cast<PlayerInfo*>(peer->data)->providerlevel > 0) providerxp = providerxp * static_cast<PlayerInfo*>(peer->data)->providerlevel;
							if (static_cast<PlayerInfo*>(peer->data)->providerlevel == 0) providerxp = 600;
							int geigerxp = 600;
							if (static_cast<PlayerInfo*>(peer->data)->geigerlevel > 0) geigerxp = geigerxp * static_cast<PlayerInfo*>(peer->data)->geigerlevel;
							if (static_cast<PlayerInfo*>(peer->data)->geigerlevel == 0) geigerxp = 350;
							int fishermanxp = 1600;
							if (static_cast<PlayerInfo*>(peer->data)->fishermanlevel > 0) fishermanxp = fishermanxp * static_cast<PlayerInfo*>(peer->data)->fishermanlevel;
							if (static_cast<PlayerInfo*>(peer->data)->fishermanlevel == 0) fishermanxp = 900;
							Player::OnDialogRequest(peer, "add_label_with_icon|big|`wRole Stats``|left|982|\nadd_spacer|small|\nadd_textbox|`9What prizes and powers have you unlocked in your Roles and what's left to discover? Find out here!``|left|\nadd_spacer|small|\nadd_player_info|Firefighter|" + to_string(static_cast<PlayerInfo*>(peer->data)->firefighterlevel) + "|" + to_string(static_cast<PlayerInfo*>(peer->data)->firefighterxp) + "|" + to_string(firefighterxp) + "|\nadd_spacer|small|\nadd_button|viewFirefighter|`0View Firefighter Rewards``|noflags|0|0|\nadd_spacer|small|\nadd_player_info|Provider|" + to_string(static_cast<PlayerInfo*>(peer->data)->providerlevel) + "|" + to_string(static_cast<PlayerInfo*>(peer->data)->providerxp) + "|" + to_string(providerxp) + "|\nadd_spacer|small|\nadd_button|viewProvider|`0View Provider Rewards``|noflags|0|0|\nadd_spacer|small|\nadd_player_info|Geiger Hunter|" + to_string(static_cast<PlayerInfo*>(peer->data)->geigerlevel) + "|" + to_string(static_cast<PlayerInfo*>(peer->data)->geigerxp) + "|" + to_string(geigerxp) + "|\nadd_spacer|small|\nadd_button|viewGeiger|`0View Geiger Hunter Rewards``|noflags|0|0|\nadd_spacer|small|\nadd_player_info|Fisherman|" + to_string(static_cast<PlayerInfo*>(peer->data)->fishermanlevel) + "|" + to_string(static_cast<PlayerInfo*>(peer->data)->fishermanxp) + "|" + to_string(fishermanxp) + "|\nadd_spacer|small|\nadd_button|viewFisherman|`0View Fisherman Rewards``|noflags|0|0|\nadd_spacer|small|\nadd_button|back|Back|noflags|0|0|\nend_dialog|mainwrenchpage|||\nadd_quick_exit|");
						}
						if (btn == "viewFisherman") {
							string level1 = "", level2 = "", level3 = "", level4 = "", level5 = "", level6 = "", level7 = "", level8 = "", level9 = "", level10 = "";
							if (static_cast<PlayerInfo*>(peer->data)->fishermanlevel >= 1) {
								level1 = "`oUnlocked: Licorice Rod``";
							} else {
								level1 = "`a(Locked) Licorice Rod``";
							}
							if (static_cast<PlayerInfo*>(peer->data)->fishermanlevel >= 2) {
								level2 = "`oUnlocked: Quantum: 1% chances of getting items as a bonus drop from from fishing``";
							} else {
								level2 = "`a(Locked) Quantum: 1% chances of getting items as a bonus drop from from fishing``";
							}
							if (static_cast<PlayerInfo*>(peer->data)->fishermanlevel >= 3) {
								level3 = "`oUnlocked: Adds a chance to get Golden Block as a bonus drop from fishing``";
							} else {
								level3 = "`a(Locked) Adds a chance to get Golden Block as a bonus drop from fishing``";
							}
							if (static_cast<PlayerInfo*>(peer->data)->fishermanlevel >= 4) {
								level4 = "`oUnlocked: Floating Leaf``|left|3074|\nadd_label_with_icon|sml|`oUnlocked: Quantum (level 2) - Chance increase to 2%``";
							} else {
								level4 = "`a(Locked) Floating Leaf``|left|3074|\nadd_label_with_icon|sml|`a(Locked) Quantum (level 2) - Chance increase to 2%``";
							}
							if (static_cast<PlayerInfo*>(peer->data)->fishermanlevel >= 5) {
								level5 = "`oUnlocked: Magical Rainbow Fishing Rod``";
							} else {
								level5 = "`a(Locked) Magical Rainbow Fishing Rod``";
							}
							if (static_cast<PlayerInfo*>(peer->data)->fishermanlevel >= 6) {
								level6 = "`oUnlocked: Quantum (level 3) - Chance increase to 3%``";
							} else {
								level6 = "`a(Locked) Quantum (level 3) - Chance increase to 3%``";
							}
							if (static_cast<PlayerInfo*>(peer->data)->fishermanlevel >= 7) {
								level7 = "`oUnlocked: Bubble Wings``";
							} else {
								level7 = "`a(Locked) Bubble Wings``";
							}
							if (static_cast<PlayerInfo*>(peer->data)->fishermanlevel >= 8) {
								level8 = "`oUnlocked: Quantum (level 4) - Chance increase to 4%``|left|7002|\nadd_label_with_icon|sml|`oUnlocked: Cursed Fishing Rod``|left|3100|";
							} else {
								level8 = "`a(Locked) Quantum (level 4) - Chance increase to 4%``|left|7002|\nadd_label_with_icon|sml|`a(Locked) Cursed Fishing Rod``|left|3100|";
							}
							if (static_cast<PlayerInfo*>(peer->data)->fishermanlevel >= 9) {
								level9 = "`oUnlocked: Ancestral Tesseract of Dimensions``";
							} else {
								level9 = "`a(Locked) Ancestral Tesseract of Dimensions``";
							}
							if (static_cast<PlayerInfo*>(peer->data)->fishermanlevel >= 10) {
								level10 = "`oUnlocked: Adds a chance to get double gems from fishing``|left|112|\nadd_label_with_icon|sml|`oUnlocked: Quantum (level 5) - Chance increase to 5%``|left|7002|\nadd_label_with_icon|sml|`oUnlocked: Goldenrod``";
							} else {
								level10 = "`a(Locked) Adds a chance to get double gems from fishing``|left|112|\nadd_label_with_icon|sml|`a(Locked) Quantum (level 5) - Chance increase to 5%``|left|7002|\nadd_label_with_icon|sml|`a(Locked) Goldenrod``";
							}
							Player::OnDialogRequest(peer, "add_label_with_icon|big|`wFisherman Rewards``|left|10262|\nadd_spacer|small|\nadd_textbox|`9Here are all the Fisherman rewards that you have earned so far!``|left|\nadd_spacer|small|\nadd_spacer|small|\nadd_smalltext|Level 1 rewards:|left|\nadd_label_with_icon|sml|" + level1 + "|left|3010|\nadd_spacer|small|\nadd_smalltext|Level 2 rewards:|left|\nadd_label_with_icon|sml|" + level2 + "|left|7002|\nadd_spacer|small|\nadd_smalltext|Level 3 rewards:|left|\nadd_label_with_icon|sml|" + level3 + "|left|260|\nadd_spacer|small|\nadd_smalltext|Level 4 rewards:|left|\nadd_label_with_icon|sml|" + level4 + "|left|7002|\nadd_spacer|small|\nadd_smalltext|Level 5 rewards:|left|\nadd_label_with_icon|sml|" + level5 + "|left|5740|\nadd_spacer|small|\nadd_smalltext|Level 6 rewards:|left|\nadd_label_with_icon|sml|" + level6 + "|left|7002|\nadd_spacer|small|\nadd_smalltext|Level 7 rewards:|left|\nadd_label_with_icon|sml|" + level7 + "|left|1550|\nadd_spacer|small|\nadd_smalltext|Level 8 rewards:|left|\nadd_label_with_icon|sml|" + level8 + "|left|10424|\nadd_spacer|small|\nadd_smalltext|Level 9 rewards:|left|\nadd_label_with_icon|sml|" + level9 + "|left|5080|\nadd_spacer|small|\nadd_smalltext|Level 10 rewards:|left|\nadd_label_with_icon|sml|" + level10 + "|left|3040|\nadd_spacer|small|\nadd_button|back|Back|noflags|0|0|\nend_dialog|roleRewardsPage|||\nadd_quick_exit|");
						}
						if (btn == "viewGeiger") {
							string level1 = "", level2 = "", level3 = "", level4 = "", level5 = "", level6 = "", level7 = "", level8 = "", level9 = "", level10 = "";
							if (static_cast<PlayerInfo*>(peer->data)->geigerlevel >= 1) {
								level1 = "`oUnlocked: Uranium Necklace``";
							} else {
								level1 = "`a(Locked) Uranium Necklace``";
							}
							if (static_cast<PlayerInfo*>(peer->data)->geigerlevel >= 2) {
								level2 = "`oUnlocked: Infusion: 1% chances of not gaining irradiated mod``";
							} else {
								level2 = "`a(Locked) Infusion: 1% chances of not gaining irradiated mod``";
							}
							if (static_cast<PlayerInfo*>(peer->data)->geigerlevel >= 3) {
								level3 = "`oUnlocked: Adds a chance to get Uranium Block as a bonus drop from geiger hunting``";
							} else {
								level3 = "`a(Locked) Adds a chance to get Uranium Block as a bonus drop from geiger hunting``";
							}
							if (static_cast<PlayerInfo*>(peer->data)->geigerlevel >= 4) {
								level4 = "`oUnlocked: Weil Magic: 1% chances of gaining extra bonus drop from geiger hunting``|left|3764|\nadd_label_with_icon|sml|`oUnlocked: Infusion (level 2) - Chance increase to 2%``";
							} else {
								level4 = "`a(Locked) Weil Magic: 1% chances of gaining extra bonus drop from geiger hunting``|left|3764|\nadd_label_with_icon|sml|`a(Locked) Infusion (level 2) - Chance increase to 2%``";
							}
							if (static_cast<PlayerInfo*>(peer->data)->geigerlevel >= 5) {
								level5 = "`oUnlocked: Adds a chance to get Electrical Power Cube as a bonus drop from geiger hunting``";
							} else {
								level5 = "`a(Locked) Adds a chance to get Electrical Power Cube as a bonus drop from geiger hunting``";
							}
							if (static_cast<PlayerInfo*>(peer->data)->geigerlevel >= 6) {
								level6 = "`oUnlocked: Infusion (level 3) - Chance increase to 3%``";
							} else {
								level6 = "`a(Locked) Infusion (level 3) - Chance increase to 3%``";
							}
							if (static_cast<PlayerInfo*>(peer->data)->geigerlevel >= 7) {
								level7 = "`oUnlocked: Unlocked: Weil Magic (level 2) - Chance increase to 2%``";
							} else {
								level7 = "`a(Locked) Unlocked: Weil Magic (level 2) - Chance increase to 2%``";
							}
							if (static_cast<PlayerInfo*>(peer->data)->geigerlevel >= 8) {
								level8 = "`oUnlocked: Infusion (level 4) - Chance increase to 4%``|left|9386|\nadd_label_with_icon|sml|`oUnlocked: Rift Cape``|left|10424|";
							} else {
								level8 = "`a(Locked) Infusion (level 4) - Chance increase to 4%``|left|9386|\nadd_label_with_icon|sml|`a(Locked) Rift Cape``|left|10424|";
							}
							if (static_cast<PlayerInfo*>(peer->data)->geigerlevel >= 9) {
								level9 = "`oUnlocked: Ancestral Lens of Riches``";
							} else {
								level9 = "`a(Locked) Ancestral Lens of Riches``";
							}
							if (static_cast<PlayerInfo*>(peer->data)->geigerlevel >= 10) {
								level10 = "`oUnlocked: Adds a chance to get Growtoken as a bonus drop from geiger hunting``|left|1486|\nadd_label_with_icon|sml|`oUnlocked: Infusion (level 5) - Chance increase to 5%``|left|9386|\nadd_label_with_icon|sml|`oUnlocked: Unique Prize``";
							} else {
								level10 = "`a(Locked) Adds a chance to get Growtoken as a bonus drop from geiger hunting``|left|1486|\nadd_label_with_icon|sml|`a(Locked) Infusion (level 5) - Chance increase to 5%``|left|9386|\nadd_label_with_icon|sml|`a(Locked) Unique Prize``";
							}
							Player::OnDialogRequest(peer, "add_label_with_icon|big|`wGeiger Hunter Rewards``|left|2204|\nadd_spacer|small|\nadd_textbox|`9Here are all the Geiger Hunter rewards that you have earned so far!``|left|\nadd_spacer|small|\nadd_spacer|small|\nadd_smalltext|Level 1 rewards:|left|\nadd_label_with_icon|sml|" + level1 + "|left|4656|\nadd_spacer|small|\nadd_smalltext|Level 2 rewards:|left|\nadd_label_with_icon|sml|" + level2 + "|left|9386|\nadd_spacer|small|\nadd_smalltext|Level 3 rewards:|left|\nadd_label_with_icon|sml|" + level3 + "|left|4658|\nadd_spacer|small|\nadd_smalltext|Level 4 rewards:|left|\nadd_label_with_icon|sml|" + level4 + "|left|9386|\nadd_spacer|small|\nadd_smalltext|Level 5 rewards:|left|\nadd_label_with_icon|sml|" + level5 + "|left|6976|\nadd_spacer|small|\nadd_smalltext|Level 6 rewards:|left|\nadd_label_with_icon|sml|" + level6 + "|left|9386|\nadd_spacer|small|\nadd_smalltext|Level 7 rewards:|left|\nadd_label_with_icon|sml|" + level7 + "|left|3764|\nadd_spacer|small|\nadd_smalltext|Level 8 rewards:|left|\nadd_label_with_icon|sml|" + level8 + "|left|10424|\nadd_spacer|small|\nadd_smalltext|Level 9 rewards:|left|\nadd_label_with_icon|sml|" + level9 + "|left|5084|\nadd_spacer|small|\nadd_smalltext|Level 10 rewards:|left|\nadd_label_with_icon|sml|" + level10 + "|left|2478|\nadd_spacer|small|\nadd_button|back|Back|noflags|0|0|\nend_dialog|roleRewardsPage|||\nadd_quick_exit|");
						}
						if (btn == "viewProvider") {
							string level1 = "", level2 = "", level3 = "", level4 = "", level5 = "", level6 = "", level7 = "", level8 = "", level9 = "", level10 = "";
							if (static_cast<PlayerInfo*>(peer->data)->providerlevel >= 1) {
								level1 = "`oUnlocked: Awkward Friendly Unicorn``";
							} else {
								level1 = "`a(Locked) Awkward Friendly Unicorn``";
							}
							if (static_cast<PlayerInfo*>(peer->data)->providerlevel >= 2) {
								level2 = "`oUnlocked: Weed Magic: 1% chances of providers dropping double items``";
							} else {
								level2 = "`a(Locked) Weed Magic: 1% chances of providers dropping double items``";
							}
							if (static_cast<PlayerInfo*>(peer->data)->providerlevel >= 3) {
								level3 = "`oUnlocked: 3 Growtokens``";
							} else {
								level3 = "`a(Locked) 3 Growtokens``";
							}
							if (static_cast<PlayerInfo*>(peer->data)->providerlevel >= 4) {
								level4 = "`oUnlocked: Adds a chance to get Smaraged Block as a bonus drop from harvesting providers``|left|9460|\nadd_label_with_icon|sml|`oUnlocked: Weed Magic (level 2) - Chance increase to 2%``";
							} else {
								level4 = "`a(Locked) Adds a chance to get Smaraged Block as a bonus drop from harvesting providers``|left|9460|\nadd_label_with_icon|sml|`a(Locked) Weed Magic (level 2) - Chance increase to 2%``";
							}
							if (static_cast<PlayerInfo*>(peer->data)->providerlevel >= 5) {
								level5 = "`oUnlocked: Ancestral Seed of Life``";
							} else {
								level5 = "`a(Locked) Ancestral Seed of Life``";
							}
							if (static_cast<PlayerInfo*>(peer->data)->providerlevel >= 6) {
								level6 = "`oUnlocked: Weed Magic (level 3) - Chance increase to 3%``";
							} else {
								level6 = "`a(Locked) Weed Magic (level 3) - Chance increase to 3%``";
							}
							if (static_cast<PlayerInfo*>(peer->data)->providerlevel >= 7) {
								level7 = "`oUnlocked: Adds a chance to get Emerald Shard as a bonus drop from harvesting providers``";
							} else {
								level7 = "`a(Locked) Adds a chance to get Emerald Shard as a bonus drop from harvesting providers``";
							}
							if (static_cast<PlayerInfo*>(peer->data)->providerlevel >= 8) {
								level8 = "`oUnlocked: 30-Day Premium Subscription Token``|left|6860|\nadd_label_with_icon|sml|`oUnlocked: Weed Magic (level 4) - Chance increase to 4%``";
							} else {
								level8 = "`a(Locked) 30-Day Premium Subscription Token``|left|6860|\nadd_label_with_icon|sml|`a(Locked) Weed Magic (level 4) - Chance increase to 4%``";
							}
							if (static_cast<PlayerInfo*>(peer->data)->providerlevel >= 9) {
								level9 = "`oUnlocked: 10 Growtokens``";
							} else {
								level9 = "`a(Locked) 10 Growtokens``";
							}
							if (static_cast<PlayerInfo*>(peer->data)->providerlevel >= 10) {
								level10 = "`oUnlocked: Adds a chance for providers to drop themself without losing one``|left|10072|\nadd_label_with_icon|sml|`oUnlocked: Weed Magic (level 5) - Chance increase to 5%``|left|954|\nadd_label_with_icon|sml|`oUnlocked: Unique Prize``";
							} else {
								level10 = "`a(Locked) Adds a chance for providers to drop themself without losing one``|left|10072|\nadd_label_with_icon|sml|`a(Locked) Weed Magic (level 5) - Chance increase to 5%``|left|954|\nadd_label_with_icon|sml|`a(Locked) Unique Prize``";
							}
							Player::OnDialogRequest(peer, "add_label_with_icon|big|`wProvider Rewards``|left|872|\nadd_spacer|small|\nadd_textbox|`9Here are all the Provider rewards that you have earned so far!``|left|\nadd_spacer|small|\nadd_spacer|small|\nadd_smalltext|Level 1 rewards:|left|\nadd_label_with_icon|sml|" + level1 + "|left|1636|\nadd_spacer|small|\nadd_smalltext|Level 2 rewards:|left|\nadd_label_with_icon|sml|" + level2 + "|left|954|\nadd_spacer|small|\nadd_smalltext|Level 3 rewards:|left|\nadd_label_with_icon|sml|" + level3 + "|left|1486|\nadd_spacer|small|\nadd_smalltext|Level 4 rewards:|left|\nadd_label_with_icon|sml|" + level4 + "|left|954|\nadd_spacer|small|\nadd_smalltext|Level 5 rewards:|left|\nadd_label_with_icon|sml|" + level5 + "|left|5082|\nadd_spacer|small|\nadd_smalltext|Level 6 rewards:|left|\nadd_label_with_icon|sml|" + level6 + "|left|954|\nadd_spacer|small|\nadd_smalltext|Level 7 rewards:|left|\nadd_label_with_icon|sml|" + level7 + "|left|2410|\nadd_spacer|small|\nadd_smalltext|Level 8 rewards:|left|\nadd_label_with_icon|sml|" + level8 + "|left|954|\nadd_spacer|small|\nadd_smalltext|Level 9 rewards:|left|\nadd_label_with_icon|sml|" + level9 + "|left|1486|\nadd_spacer|small|\nadd_smalltext|Level 10 rewards:|left|\nadd_label_with_icon|sml|" + level10 + "|left|2478|\nadd_spacer|small|\nadd_button|back|Back|noflags|0|0|\nend_dialog|roleRewardsPage|||\nadd_quick_exit|");
						}
						if (btn == "viewFirefighter") {
							string level1 = "", level2 = "", level3 = "", level4 = "", level5 = "", level6 = "", level7 = "", level8 = "", level9 = "", level10 = "";
							if (static_cast<PlayerInfo*>(peer->data)->firefighterlevel >= 1) {
								level1 = "`oUnlocked: Growtoken``";
							} else {
								level1 = "`a(Locked) Growtoken``";
							}
							if (static_cast<PlayerInfo*>(peer->data)->firefighterlevel >= 2) {
								level2 = "`oUnlocked: Fire King: 1% chances of receiving bonus gems when putting out fire``";
							} else {
								level2 = "`a(Locked) Fire King: 1% chances of receiving bonus gems when putting out fire``";
							}
							if (static_cast<PlayerInfo*>(peer->data)->firefighterlevel >= 3) {
								level3 = "`oUnlocked: Adds a chance to get Amethyst Block as a bonus drop from putting out fire``";
							} else {
								level3 = "`a(Locked) Adds a chance to get Amethyst Block as a bonus drop from putting out fire``";
							}
							if (static_cast<PlayerInfo*>(peer->data)->firefighterlevel >= 4) {
								level4 = "`oUnlocked: Adds a chance to get Fallen Pillar as a bonus drop from putting out fire``|left|7156|\nadd_label_with_icon|sml|`oUnlocked: Fire King (level 2) - Chance increase to 2%``";
							} else {
								level4 = "`a(Locked) Adds a chance to get Fallen Pillar as a bonus drop from putting out fire``|left|7156|\nadd_label_with_icon|sml|`a(Locked) Fire King (level 2) - Chance increase to 2%``";
							}
							if (static_cast<PlayerInfo*>(peer->data)->firefighterlevel >= 5) {
								level5 = "`oUnlocked: Burning Hands``";
							} else {
								level5 = "`a(Locked) Burning Hands``";
							}
							if (static_cast<PlayerInfo*>(peer->data)->firefighterlevel >= 6) {
								level6 = "`oUnlocked: Fire King (level 3) - Chance increase to 3%``";
							} else {
								level6 = "`a(Locked) Fire King (level 3) - Chance increase to 3%``";
							}
							if (static_cast<PlayerInfo*>(peer->data)->firefighterlevel >= 7) {
								level7 = "`oUnlocked: Adds a chance to get Diamond Stone as a bonus drop from putting out fire``";
							} else {
								level7 = "`a(Locked) Adds a chance to get Diamond Stone as a bonus drop from putting out fire``";
							}
							if (static_cast<PlayerInfo*>(peer->data)->firefighterlevel >= 8) {
								level8 = "`oUnlocked: 30-Day Premium Subscription Token``|left|6860|\nadd_label_with_icon|sml|`oUnlocked: Fire King (level 4) - Chance increase to 4%``";
							} else {
								level8 = "`a(Locked) 30-Day Premium Subscription Token``|left|6860|\nadd_label_with_icon|sml|`a(Locked) Fire King (level 4) - Chance increase to 4%``";
							}
							if (static_cast<PlayerInfo*>(peer->data)->firefighterlevel >= 9) {
								level9 = "`oUnlocked: 10 Growtokens``";
							} else {
								level9 = "`a(Locked) 10 Growtokens``";
							}
							if (static_cast<PlayerInfo*>(peer->data)->firefighterlevel >= 10) {
								level10 = "`oUnlocked: Adds a chance to get foreground block that was on fire as a bonus drop``|left|10072|\nadd_label_with_icon|sml|`oUnlocked: Fire King (level 5) - Chance increase to 5%``|left|3046|\nadd_label_with_icon|sml|`oUnlocked: Unique Prize``";
							} else {
								level10 = "`a(Locked) Adds a chance to get foreground block that was on fire as a bonus drop``|left|10072|\nadd_label_with_icon|sml|`a(Locked) Fire King (level 5) - Chance increase to 5%``|left|3046|\nadd_label_with_icon|sml|`a(Locked) Unique Prize``";
							}
							Player::OnDialogRequest(peer, "add_label_with_icon|big|`wFirefighter Rewards``|left|3046|\nadd_spacer|small|\nadd_textbox|`9Here are all the Firefighter rewards that you have earned so far!``|left|\nadd_spacer|small|\nadd_spacer|small|\nadd_smalltext|Level 1 rewards:|left|\nadd_label_with_icon|sml|" + level1 + "|left|1486|\nadd_spacer|small|\nadd_smalltext|Level 2 rewards:|left|\nadd_label_with_icon|sml|" + level2 + "|left|3046|\nadd_spacer|small|\nadd_smalltext|Level 3 rewards:|left|\nadd_label_with_icon|sml|" + level3 + "|left|4762|\nadd_spacer|small|\nadd_smalltext|Level 4 rewards:|left|\nadd_label_with_icon|sml|" + level4 + "|left|3046|\nadd_spacer|small|\nadd_smalltext|Level 5 rewards:|left|\nadd_label_with_icon|sml|" + level5 + "|left|4996|\nadd_spacer|small|\nadd_smalltext|Level 6 rewards:|left|\nadd_label_with_icon|sml|" + level6 + "|left|3046|\nadd_spacer|small|\nadd_smalltext|Level 7 rewards:|left|\nadd_label_with_icon|sml|" + level7 + "|left|9468|\nadd_spacer|small|\nadd_smalltext|Level 8 rewards:|left|\nadd_label_with_icon|sml|" + level8 + "|left|3046|\nadd_spacer|small|\nadd_smalltext|Level 9 rewards:|left|\nadd_label_with_icon|sml|" + level9 + "|left|1486|\nadd_spacer|small|\nadd_smalltext|Level 10 rewards:|left|\nadd_label_with_icon|sml|" + level10 + "|left|2478|\nadd_spacer|small|\nadd_button|back|Back|noflags|0|0|\nend_dialog|roleRewardsPage|||\nadd_quick_exit|");
						}
						if (btn == "pullstock")
						{
							if (world->owner != "" && !isWorldOwner(peer, world) && !isMod(peer)) continue;
							int xxx = static_cast<PlayerInfo*>(peer->data)->lastPunchX;
							int yyy = static_cast<PlayerInfo*>(peer->data)->lastPunchY;
							if (xxx < 0 && yyy < 0) continue;
							int withdrawcpy = world->items[xxx + (yyy * world->width)].vdraw;
							if (withdrawcpy != 0) {
								Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wWithdraw the world locks first!", 0, true);
								continue;
							}
							int realid = world->items[xxx + (yyy * world->width)].vid;
							int countid = world->items[xxx + (yyy * world->width)].vcount;
							if (CheckItemMaxed(peer, realid, countid)) {
								Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wYou can't carry any of those!", 0, true);
								Player::OnConsoleMessage(peer, "`oYou can't carry any of those!");
								continue;
							}
							if (countid > 200) {
								bool success = true;
								SaveItemMoreTimes(realid, 200, peer, success, static_cast<PlayerInfo*>(peer->data)->rawName + " collected from Vending Machine");
								world->items[xxx + (yyy * world->width)].vcount -= 200;
								Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wYou picked up 200 " + getItemDef(realid).name + "`w, leaving " + to_string(world->items[xxx + (yyy * world->width)].vcount) + " in the machine.", 0, true);
								if (isMod(peer) && !isWorldOwner(peer, world)) LogAccountActivity(peer, "Collected 200 " + getItemDef(realid).name + " from " + getItemDef(world->items[xxx + (yyy * world->width)].foreground).name + " (" + world->name + ")");
								Player::OnConsoleMessage(peer, "`oYou picked up 200 " + getItemDef(realid).name + "`o, leaving " + to_string(world->items[xxx + (yyy * world->width)].vcount) + " in the machine.");
								ENetPeer* currentPeer;
								for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
									if (isHere(peer, currentPeer)) {			
										if (world->items[xxx + (yyy * world->width)].opened && world->items[xxx + (yyy * world->width)].vcount < world->items[xxx + (yyy * world->width)].vprice) {
											UpdateVend(currentPeer, xxx, yyy, 0, false, world->items[xxx + (yyy * world->width)].vprice, world->items[xxx + (yyy * world->width)].background, world->items[xxx + (yyy * world->width)].opened);
										}
										else UpdateVend(currentPeer, xxx, yyy, world->items[xxx + (yyy * world->width)].vid, false, world->items[xxx + (yyy * world->width)].vprice, world->items[xxx + (yyy * world->width)].background, world->items[xxx + (yyy * world->width)].opened);
									}
								}
							}
							else
							{
								world->items[xxx + (yyy * world->width)].vprice = 0;
								bool success = true;
								SaveItemMoreTimes(realid, countid, peer, success, static_cast<PlayerInfo*>(peer->data)->rawName + " collected from Vending Machine");
								world->items[xxx + (yyy * world->width)].vid = 0;
								world->items[xxx + (yyy * world->width)].vcount = 0;
								Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wYou picked up " + to_string(countid) + " " + getItemDef(realid).name + "`w.", 0, true);
								if (isMod(peer) && !isWorldOwner(peer, world)) LogAccountActivity(peer, "Collected " + to_string(countid) + " " + getItemDef(realid).name + " from " + getItemDef(world->items[xxx + (yyy * world->width)].foreground).name + " (" + world->name + ")");
								Player::OnConsoleMessage(peer, "`oYou picked up " + to_string(countid) + " " + getItemDef(realid).name + "`o.");
								ENetPeer* currentPeer;
								for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
									if (isHere(peer, currentPeer)) {
										if (world->items[xxx + (yyy * world->width)].opened && world->items[xxx + (yyy * world->width)].vcount < world->items[xxx + (yyy * world->width)].vprice) {
											UpdateVend(currentPeer, xxx, yyy, 0, false, world->items[xxx + (yyy * world->width)].vprice, world->items[xxx + (yyy * world->width)].background, world->items[xxx + (yyy * world->width)].opened);
										}
										else UpdateVend(currentPeer, xxx, yyy, 0, false, 0, world->items[xxx + (yyy * world->width)].background, world->items[xxx + (yyy * world->width)].opened);
									}
								}
							}
						}
						if (btn == "withdraw")
						{
							if (world->owner != "" && !isWorldOwner(peer, world)) continue;
							int xxx = static_cast<PlayerInfo*>(peer->data)->lastPunchX;
							int yyy = static_cast<PlayerInfo*>(peer->data)->lastPunchY;
							if (xxx < 0 && yyy < 0) continue;
							int withdrawcpy = world->items[xxx + (yyy * world->width)].vdraw;
							if (withdrawcpy != 0) {
								if (withdrawcpy <= 200) {
									if (CheckItemMaxed(peer, 242, withdrawcpy)) {
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wI dont have free space to collect " + to_string(withdrawcpy) + " World Locks!", 0, true);
										continue;
									}
									world->items[xxx + (yyy * world->width)].vdraw = 0;
									int realid = world->items[xxx + (yyy * world->width)].vid;
									int priceid = world->items[xxx + (yyy * world->width)].vprice;
									bool success = true;
									SaveItemMoreTimes(242, withdrawcpy, peer, success, static_cast<PlayerInfo*>(peer->data)->rawName + " collected from Vending Machine");
									if (isMod(peer) && !isWorldOwner(peer, world)) LogAccountActivity(peer, "Collected " + to_string(withdrawcpy) + " World Locks from " + getItemDef(world->items[xxx + (yyy * world->width)].foreground).name + " (" + world->name + ")");
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wYou collected " + to_string(withdrawcpy) + " World Locks.", 0, true);
									if (world->items[xxx + (yyy * world->width)].vcount == 0) {
										priceid = 0;
										realid = 0;
									}
									ENetPeer* currentPeer;
									for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
										if (isHere(peer, currentPeer)) {
											if (world->items[xxx + (yyy * world->width)].opened && world->items[xxx + (yyy * world->width)].vcount < world->items[xxx + (yyy * world->width)].vprice) {
												UpdateVend(currentPeer, xxx, yyy, 0, false, priceid, world->items[xxx + (yyy * world->width)].background, world->items[xxx + (yyy * world->width)].opened);
											}
											else UpdateVend(currentPeer, xxx, yyy, realid, false, priceid, world->items[xxx + (yyy * world->width)].background, world->items[xxx + (yyy * world->width)].opened);
										}
									}
								}
								else if (withdrawcpy > 200)
								{
									if (CheckItemMaxed(peer, 242, 200))
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wI dont have free space to collect 200 World Locks!", 0, true);
										continue;
									}
									int grazinti = withdrawcpy - 200;
									world->items[xxx + (yyy * world->width)].vdraw = grazinti;
									int realid = world->items[xxx + (yyy * world->width)].vid;
									int priceid = world->items[xxx + (yyy * world->width)].vprice;
									bool success = true;
									SaveItemMoreTimes(242, 200, peer, success, static_cast<PlayerInfo*>(peer->data)->rawName + " collected from Vending Machine");
									if (isMod(peer) && !isWorldOwner(peer, world)) LogAccountActivity(peer, "Collected 200 World Locks from " + getItemDef(world->items[xxx + (yyy * world->width)].foreground).name + " (" + world->name + ")");
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wYou collected 200 World Locks, leaving " + to_string(grazinti) + " in the machine!", 0, true);
									if (world->items[xxx + (yyy * world->width)].vcount == 0) {
										priceid = 0;
										realid = 0;
									}
									ENetPeer* currentPeer;
									for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
										if (isHere(peer, currentPeer)) {
											if (world->items[xxx + (yyy * world->width)].opened && world->items[xxx + (yyy * world->width)].vcount < world->items[xxx + (yyy * world->width)].vprice) {
												UpdateVend(currentPeer, xxx, yyy, 0, true, priceid, world->items[xxx + (yyy * world->width)].background, world->items[xxx + (yyy * world->width)].opened);
											}
											else UpdateVend(currentPeer, xxx, yyy, realid, true, priceid, world->items[xxx + (yyy * world->width)].background, world->items[xxx + (yyy * world->width)].opened);
										}
									}
								}
								else {
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wHuh?", 0, true);
								}
							}
						}
						if (btn == "manipulatorstop") {
							if (world == nullptr || static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT" || serverIsFrozen) continue;
							int x = static_cast<PlayerInfo*>(peer->data)->lastPunchX;
							int y = static_cast<PlayerInfo*>(peer->data)->lastPunchY;
							world->items[x + (y * world->width)].mid = 0;
							ENetPeer* currentPeer;
							for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
								if (isHere(peer, currentPeer)) {
									SendItemSucker(currentPeer, 6952, x, y, world->items[x + (y * world->width)].mid, 0, false, false, world->items[x + (y * world->width)].background);
								}
							}
						}
						if (btn == "organicstop") {
							if (world == nullptr || static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT" || serverIsFrozen) continue;
							int x = static_cast<PlayerInfo*>(peer->data)->lastPunchX;
							int y = static_cast<PlayerInfo*>(peer->data)->lastPunchY;
							if (world->items[x + (y * world->width)].mc > 250) {
								if (CheckItemMaxed(peer, world->items[x + (y * world->width)].mid, 250)) {
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wI dont have a free space to pickup `2250 `$" + getItemDef(world->items[x + (y * world->width)].mid).name + "`w!", 0, true);
									continue;
								}
								else {
									world->items[x + (y * world->width)].mc -= 250;
									bool success = true;
									SaveItemMoreTimes(world->items[x + (y * world->width)].mid, 250, peer, success, static_cast<PlayerInfo*>(peer->data)->rawName + " withdraw from Techno-Organic Engine");
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`oCollected `2250 `5" + getItemDef(world->items[x + (y * world->width)].mid).name + " `oFrom the Techno-Organic Engine!", 0, true);
									if (isMod(peer) && !isWorldOwner(peer, world)) LogAccountActivity(peer, "Collected 250 " + getItemDef(world->items[x + (y * world->width)].mid).name + " from " + getItemDef(world->items[x + (y * world->width)].foreground).name + " (" + world->name + ")");
									ENetPeer* currentPeer;
									for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
										if (isHere(peer, currentPeer)) {
											SendItemSucker(currentPeer, 6954, x, y, world->items[x + (y * world->width)].mid, 1, true, true, world->items[x + (y * world->width)].background);
										}
									}
								}
							}
							else
							{
								if (CheckItemMaxed(peer, world->items[x + (y * world->width)].mid, world->items[x + (y * world->width)].mc)) {
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wI dont have a free space to pickup `2" + to_string(world->items[x + (y * world->width)].mc) + " `$" + getItemDef(world->items[x + (y * world->width)].mid).name + "`w!", 0, true);
									continue;
								}
								else {
									bool success = true;
									SaveItemMoreTimes(world->items[x + (y * world->width)].mid, world->items[x + (y * world->width)].mc, peer, success, static_cast<PlayerInfo*>(peer->data)->rawName + " withdraw from Techno-Organic Engine");
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`oCollected `2" + to_string(world->items[x + (y * world->width)].mc) + " `5" + getItemDef(world->items[x + (y * world->width)].mid).name + " `oFrom the Techno-Organic Engine!", 0, true);
									if (isMod(peer) && !isWorldOwner(peer, world)) LogAccountActivity(peer, "Collected " + to_string(world->items[x + (y * world->width)].mc) + " " + getItemDef(world->items[x + (y * world->width)].mid).name + " from " + getItemDef(world->items[x + (y * world->width)].foreground).name + " (" + world->name + ")");
									world->items[x + (y * world->width)].mid = 0;
									ENetPeer* currentPeer;
									for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
										if (isHere(peer, currentPeer)) {
											SendItemSucker(currentPeer, 6954, x, y, world->items[x + (y * world->width)].mid, -1, true, true, world->items[x + (y * world->width)].background);
										}
									}
									world->items[x + (y * world->width)].mc = 0;
								}
							}
						}
						if (btn == "addorganic") {
							if (world->owner != "" && !isWorldOwner(peer, world)) continue;
							int xxx = static_cast<PlayerInfo*>(peer->data)->lastPunchX;
							int yyy = static_cast<PlayerInfo*>(peer->data)->lastPunchY;
							if (xxx < 0 && yyy < 0) continue;
							int iditem = world->items[xxx + (yyy * world->width)].mid;
							int countitem = world->items[xxx + (yyy * world->width)].mc;
							auto mtitems = 0;
							for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++) {
								if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == iditem) {
									mtitems = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
									break;
								}
							}
							auto iscontainseas = false;
							SearchInventoryItem(peer, iditem, mtitems, iscontainseas);
							if (!iscontainseas) {
								Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Huh?", 0, true);
								continue;
							}
							else {
								if (countitem + mtitems > 5000) {
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "The machine will really explode if you will fit more of them into it!", 0, true);
									continue;
								}
								RemoveInventoryItem(iditem, mtitems, peer, true);
								countitem += mtitems;
								world->items[xxx + (yyy * world->width)].mc = countitem;
								Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wAdded " + to_string(mtitems) + " to the machine.", 0, true);
								if (isMod(peer) && !isWorldOwner(peer, world)) LogAccountActivity(peer, "Added " + to_string(mtitems) + " " + getItemDef(world->items[xxx + (yyy * world->width)].mid).name + " into " + getItemDef(world->items[xxx + (yyy * world->width)].foreground).name + " (" + world->name + ")");
								ENetPeer* currentPeer;
								for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
									if (isHere(peer, currentPeer)) {
										SendItemSucker(currentPeer, 6954, xxx, yyy, world->items[xxx + (yyy * world->width)].mid, 1, true, true, world->items[xxx + (yyy * world->width)].background);
									}
								}
							}
						}

						if (btn == "addvend") {
							if (world->owner != "" && !isWorldOwner(peer, world) && !isMod(peer)) continue;
							int xxx = static_cast<PlayerInfo*>(peer->data)->lastPunchX;
							int yyy = static_cast<PlayerInfo*>(peer->data)->lastPunchY;
							if (xxx < 0 && yyy < 0) continue;
							int iditem = world->items[xxx + (yyy * world->width)].vid;
							int countitem = world->items[xxx + (yyy * world->width)].vcount;
							auto mtitems = 0;
							for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++) {
								if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == iditem) {
									mtitems = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
									break;
								}
							}
							auto iscontainseas = false;
							SearchInventoryItem(peer, iditem, mtitems, iscontainseas);
							if (!iscontainseas) {
								Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Huh?", 0, true);
								continue;
							}
							else {
								RemoveInventoryItem(iditem, mtitems, peer, true);
								updateplayerset(peer, iditem);
								countitem += mtitems;
								world->items[xxx + (yyy * world->width)].vcount = countitem;
								Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wAdded " + to_string(mtitems) + " to the machine.", 0, true);
								if (isMod(peer) && !isWorldOwner(peer, world)) LogAccountActivity(peer, "Added " + to_string(mtitems) + " " + getItemDef(world->items[xxx + (yyy * world->width)].vid).name + " into " + getItemDef(world->items[xxx + (yyy * world->width)].foreground).name + " (" + world->name + ")");
							}
						}
						if (btn == "addletter")
						{
							if (world == nullptr || static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT" || serverIsFrozen) continue;
							std::stringstream bss(cch);
							std::string bto;

							string text = "";
							string coord = "";

							while (std::getline(bss, bto, '\n'))
							{
								vector<string> infoDat = explode("|", bto);
								if (infoDat[0].substr(0, 15) == "addletterinput_")
								{
									text = infoDat[1];
									string coord = infoDat[0].substr(infoDat[0].find("_") + 1);
									auto isdbox = std::experimental::filesystem::exists("mailbox/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
									if (!isdbox)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured. Break the mailbox.", 0, true);
										break;
									}

									if (text.size() < 3)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wThats not interesting enough to mail.", 0, true);
										break;
									}

									try
									{
										ifstream ifff("mailbox/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
										json j;
										ifff >> j;
										ifff.close();

										if (j["inmail"] > 19)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`oThis mailbox already has `w20 `oletters in it. Try again later.", 0, true);
										}
										for (int i = 0; i < 20; i++)
										{
											if (j["mails"][i]["growid"] == "")
											{
												j["mails"][i]["growid"] = static_cast<PlayerInfo*>(peer->data)->displayName;
												j["mails"][i]["text"] = text;
												if (isMod(peer) && !isWorldOwner(peer, world)) LogAccountActivity(peer, "Added letter (" + text + "``) into Mailbox (" + world->name + ")");
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`2You place your letter in the mailbox.", 0, true);
												int x = j["x"];
												int y = j["y"];
												if (j["inmail"] < 1)
												{
													ENetPeer* currentPeer;
													for (currentPeer = server->peers;
														currentPeer < &server->peers[server->peerCount];
														++currentPeer)
													{
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
														if (isHere(peer, currentPeer))
														{
															SendItemPacket(currentPeer, 656, 0, x, y, 1);
														}
													}
												}
												j["inmail"] = j["inmail"].get<double>() + 1;
												ofstream of("mailbox/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
												of << j << std::endl;
												of.close();
												break;
											}
										}
									}
									catch (std::exception&)
									{
										SendConsole("addletter Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_later(peer, 0);
									}
									catch (std::runtime_error&)
									{
										SendConsole("addletter Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_later(peer, 0);
									}
									catch (...)
									{
										SendConsole("addletter Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_later(peer, 0);
									}
								}
							}
						}
						if (btn == "addblueletter")
						{
							if (world == nullptr || static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT" || serverIsFrozen) continue;
							std::stringstream bss(cch);
							std::string bto;

							string text = "";
							string coord = "";

							while (std::getline(bss, bto, '\n'))
							{
								vector<string> infoDat = explode("|", bto);
								if (infoDat[0].substr(0, 19) == "addblueletterinput_")
								{
									text = infoDat[1];
									string coord = infoDat[0].substr(infoDat[0].find("_") + 1);
									auto isdbox = std::experimental::filesystem::exists("bluemailbox/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
									if (!isdbox)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured. Break the blue mailbox.", 0, true);
										break;
									}

									if (text.size() < 3)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wThats not interesting enough to mail.", 0, true);
										break;
									}

									try
									{
										ifstream ifff("bluemailbox/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
										json j;
										ifff >> j;
										ifff.close();

										if (j["inmail"] > 19)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`oThis mailbox already has `w20 `oletters in it. Try again later.", 0, true);
										}
										for (int i = 0; i < 20; i++)
										{
											if (j["mails"][i]["growid"] == "")
											{
												j["mails"][i]["growid"] = static_cast<PlayerInfo*>(peer->data)->displayName;
												j["mails"][i]["text"] = text;
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`2You place your letter in the mailbox.", 0, true);
												if (isMod(peer) && !isWorldOwner(peer, world)) LogAccountActivity(peer, "Added letter (" + text + "``) into Blue Mailbox (" + world->name + ")");
												int x = j["x"];
												int y = j["y"];
												if (j["inmail"] < 1)
												{
													ENetPeer* currentPeer;
													for (currentPeer = server->peers;
														currentPeer < &server->peers[server->peerCount];
														++currentPeer)
													{
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
														if (isHere(peer, currentPeer))
														{
															SendItemPacket(currentPeer, 1006, 0, x, y, 1);
														}
													}
												}
												j["inmail"] = j["inmail"].get<double>() + 1;
												ofstream of("bluemailbox/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
												of << j << std::endl;
												of.close();
												break;
											}
										}
									}
									catch (std::exception&)
									{
										SendConsole("addblueletter Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_later(peer, 0);
									}
									catch (std::runtime_error&)
									{
										SendConsole("addblueletter Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_later(peer, 0);
									}
									catch (...)
									{
										SendConsole("addblueletter Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_later(peer, 0);
									}
								}
							}
						}
						if (btn == "boxlvl2depositconfirm")
						{
							if (world == nullptr || static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT" || serverIsFrozen) continue;
							std::stringstream bss(cch);
							std::string bto;

							string count = "";
							int countint = 0;
							string coord = "";
							string id = "";
							int idint = 0;

							while (std::getline(bss, bto, '\n'))
							{
								vector<string> infoDat = explode("|", bto);
								if (infoDat[0].substr(0, 20) == "boxlvl2depositcount_")
								{
									count = infoDat[1];

									string coord_and_id = infoDat[0].erase(0, 20);
									string::size_type pos = coord_and_id.find('_');
									if (pos != std::string::npos)
									{
										coord = coord_and_id.substr(0, pos);
										coord_and_id.erase(0, pos + 1);
										id = coord_and_id;
									}
									else
									{
										autoBan(peer, false, 24 * 7, "Incorrect parameters boxlvl2depositconfirm. Coord and id were: " + coord_and_id);
										break;
									}
									auto isdbox = std::experimental::filesystem::exists("storageboxlvl2/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
									if (!isdbox)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured while getting box info.", 0, true);
										break;
									}

									bool contains_non_int3 = !std::regex_match(id, std::regex("^[0-9]+$"));
									if (contains_non_int3 == true)
									{
										autoBan(peer, false, 24 * 7, "Proxy detect! boxlvl2depositconfirm item id was: " + id);
										break;
									}

									bool contains_non_int4 = !std::regex_match(count, std::regex("^[0-9]+$"));
									if (contains_non_int4 == true)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Invalid input in amount!", 0, false);
										break;
									}
									countint = atoi(count.c_str());

									idint = atoi(id.c_str());
									if (idint < 1 || idint > maxItems)
									{
										autoBan(peer, false, 24 * 7, "Proxy detect! In boxlvl2depositconfirm, id was: " + to_string(idint) + "");
										break;
									}

									if (countint < 1 || countint > 250)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Invalid input in amount!", 0, false);
										break;
									}

									try
									{
										ifstream ifff("storageboxlvl2/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
										json j;
										ifff >> j;
										ifff.close();

										if (j["instorage"] > 19)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Storage Box Xtreme - Level 2 is full!", 0, true);
											break;
										}
										bool isContains = false;
										SearchInventoryItem(peer, idint, countint, isContains);
										if (isContains == false)
										{
											Player::OnTextOverlay(peer, "`4You don't have enough " + itemDefs[idint].name + " in your inventory.");
											break;
										}
										j["instorage"] = j["instorage"].get<double>() + 1;

										for (int i = 0; i < 20; i++)
										{
											if (j["storage"][i]["itemid"] == 0)
											{
												j["storage"][i]["itemid"] = idint;
												j["storage"][i]["placedby"] = static_cast<PlayerInfo*>(peer->data)->rawName;
												j["storage"][i]["itemcount"] = countint;

												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wStored " + to_string(countint) + " " + itemDefs[idint].name + " `win the Storage Box Xtreme - Level 2", 0, true);
												if (isMod(peer) && !isWorldOwner(peer, world)) LogAccountActivity(peer, "Stored " + to_string(countint) + " " + itemDefs[idint].name + " in Storage Box Xtreme - Level 2 (" + world->name + ")");
												break;
											}
										}

										ofstream of("storageboxlvl2/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
										of << j << std::endl;
										of.close();
										RemoveInventoryItem(idint, countint, peer, true);
										updateplayerset(peer, idint);
									}
									catch (std::exception&)
									{
										SendConsole("boxlvl2depositcount_ Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_later(peer, 0);
									}
									catch (std::runtime_error&)
									{
										SendConsole("boxlvl2depositcount_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_later(peer, 0);
									}
									catch (...)
									{
										SendConsole("boxlvl2depositcount_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_later(peer, 0);
									}
								}
							}
						}
						if (btn == "boxlvl3depositconfirm")
						{
							if (world == nullptr || static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT" || serverIsFrozen) continue;
							std::stringstream bss(cch);
							std::string bto;

							string count = "";
							int countint = 0;
							string coord = "";
							string id = "";
							int idint = 0;

							while (std::getline(bss, bto, '\n'))
							{
								vector<string> infoDat = explode("|", bto);
								if (infoDat[0].substr(0, 20) == "boxlvl3depositcount_")
								{
									count = infoDat[1];

									string coord_and_id = infoDat[0].erase(0, 20);
									string::size_type pos = coord_and_id.find('_');
									if (pos != std::string::npos)
									{
										coord = coord_and_id.substr(0, pos);
										coord_and_id.erase(0, pos + 1);
										id = coord_and_id;
									}
									else
									{
										autoBan(peer, false, 24 * 7, "Incorrect parameters boxlvl3depositconfirm. Coord and id were: " + coord_and_id);
										break;
									}
									auto isdbox = std::experimental::filesystem::exists("storageboxlvl3/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
									if (!isdbox)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured while getting box info.", 0, true);
										break;
									}

									bool contains_non_int3 = !std::regex_match(id, std::regex("^[0-9]+$"));
									if (contains_non_int3 == true)
									{
										autoBan(peer, false, 24 * 7, "Proxy detect! boxlvl3depositconfirm item id was: " + id);
										break;
									}

									bool contains_non_int4 = !std::regex_match(count, std::regex("^[0-9]+$"));
									if (contains_non_int4 == true)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Invalid input in amount!", 0, false);
										break;
									}
									countint = atoi(count.c_str());

									idint = atoi(id.c_str());
									if (idint < 1 || idint > maxItems)
									{
										autoBan(peer, false, 24 * 7, "Proxy detect! In boxlvl3depositconfirm, id was: " + to_string(idint) + "");
										break;
									}

									if (countint < 1 || countint > 250)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Invalid input in amount!", 0, false);
										break;
									}

									try
									{
										ifstream ifff("storageboxlvl3/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
										json j;
										ifff >> j;
										ifff.close();

										if (j["instorage"] > 19)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Storage Box Xtreme - Level 3 is full!", 0, true);
											break;
										}
										bool isContains = false;
										SearchInventoryItem(peer, idint, countint, isContains);
										if (isContains == false)
										{
											Player::OnTextOverlay(peer, "`4You don't have enough " + itemDefs[idint].name + " in your inventory.");
											break;
										}
										j["instorage"] = j["instorage"].get<double>() + 1;

										for (int i = 0; i < 20; i++)
										{
											if (j["storage"][i]["itemid"] == 0)
											{
												j["storage"][i]["itemid"] = idint;
												j["storage"][i]["placedby"] = static_cast<PlayerInfo*>(peer->data)->rawName;
												j["storage"][i]["itemcount"] = countint;

												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wStored " + to_string(countint) + " " + itemDefs[idint].name + " `win the Storage Box Xtreme - Level 3", 0, true);
												if (isMod(peer) && !isWorldOwner(peer, world)) LogAccountActivity(peer, "Stored " + to_string(countint) + " " + itemDefs[idint].name + " in Storage Box Xtreme - Level 3 (" + world->name + ")");
												break;
											}
										}

										ofstream of("storageboxlvl3/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
										of << j << std::endl;
										of.close();
										RemoveInventoryItem(idint, countint, peer, true);
										updateplayerset(peer, idint);
									}
									catch (std::exception&)
									{
										SendConsole("boxlvl3depositconfirm Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_later(peer, 0);
									}
									catch (std::runtime_error&)
									{
										SendConsole("boxlvl3depositconfirm Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_later(peer, 0);
									}
									catch (...)
									{
										SendConsole("boxlvl3depositconfirm Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_later(peer, 0);
									}
								}
							}
						}
						if (btn == "boxlvl1depositconfirm")
						{
							if (world == nullptr || static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT" || serverIsFrozen) continue;
							std::stringstream bss(cch);
							std::string bto;

							string count = "";
							int countint = 0;
							string coord = "";
							string id = "";
							int idint = 0;

							while (std::getline(bss, bto, '\n'))
							{
								vector<string> infoDat = explode("|", bto);
								if (infoDat[0].substr(0, 20) == "boxlvl1depositcount_")
								{
									count = infoDat[1];

									string coord_and_id = infoDat[0].erase(0, 20);
									string::size_type pos = coord_and_id.find('_');
									if (pos != std::string::npos)
									{
										coord = coord_and_id.substr(0, pos);
										coord_and_id.erase(0, pos + 1);
										id = coord_and_id;
									}
									else
									{
										autoBan(peer, false, 24 * 7, "Incorrect parameters boxlvl1depositconfirm. Coord and id were: " + coord_and_id);
										break;
									}
									auto isdbox = std::experimental::filesystem::exists("storageboxlvl1/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
									if (!isdbox)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured while getting box info.", 0, true);
										break;
									}

									bool contains_non_int3 = !std::regex_match(id, std::regex("^[0-9]+$"));
									if (contains_non_int3 == true)
									{
										autoBan(peer, false, 24 * 7, "Proxy detect! boxlvl1depositconfirm item id was: " + id);
										break;
									}

									bool contains_non_int4 = !std::regex_match(count, std::regex("^[0-9]+$"));
									if (contains_non_int4 == true)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Invalid input in amount!", 0, false);
										break;
									}
									countint = atoi(count.c_str());

									idint = atoi(id.c_str());
									if (idint < 1 || idint > maxItems)
									{
										autoBan(peer, false, 24 * 7, "Proxy detect! In boxlvl1depositconfirm, id was: " + to_string(idint) + "");
										break;
									}

									if (countint < 1 || countint > 250)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Invalid input in amount!", 0, false);
										break;
									}

									try
									{
										ifstream ifff("storageboxlvl1/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
										json j;
										ifff >> j;
										ifff.close();

										if (j["instorage"] > 19)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Storage Box Xtreme - Level 1 is full!", 0, true);
											break;
										}
										bool isContains = false;
										SearchInventoryItem(peer, idint, countint, isContains);
										if (isContains == false)
										{
											Player::OnTextOverlay(peer, "`4You don't have enough " + itemDefs[idint].name + " in your inventory.");
											break;
										}
										j["instorage"] = j["instorage"].get<double>() + 1;

										for (int i = 0; i < 20; i++)
										{
											if (j["storage"][i]["itemid"] == 0)
											{
												j["storage"][i]["itemid"] = idint;
												j["storage"][i]["placedby"] = static_cast<PlayerInfo*>(peer->data)->rawName;
												j["storage"][i]["itemcount"] = countint;

												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wStored " + to_string(countint) + " " + itemDefs[idint].name + " `win the Storage Box Xtreme - Level 1", 0, true);
												if (isMod(peer) && !isWorldOwner(peer, world)) LogAccountActivity(peer, "Stored " + to_string(countint) + " " + itemDefs[idint].name + " in Storage Box Xtreme - Level 1 (" + world->name + ")");
												break;
											}
										}

										ofstream of("storageboxlvl1/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
										of << j << std::endl;
										of.close();
										RemoveInventoryItem(idint, countint, peer, true);
										updateplayerset(peer, idint);
									}
									catch (std::exception&)
									{
										SendConsole("boxlvl1depositconfirm Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_later(peer, 0);
									}
									catch (std::runtime_error&)
									{
										SendConsole("boxlvl1depositconfirm Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_later(peer, 0);
									}
									catch (...)
									{
										SendConsole("boxlvl1depositconfirm Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_later(peer, 0);
									}
								}
							}
						}
						if (btn == "boxlvl2_withdrawConfirm")
						{
							if (world == nullptr || static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT" || serverIsFrozen) continue;
							std::stringstream bss(cch);
							std::string bto;

							string howMany = "";
							string apos = "";
							string coord = "";
							int aposInt = 0;
							int howManyInt = 0;

							while (std::getline(bss, bto, '\n'))
							{
								vector<string> infoDat = explode("|", bto);
								if (infoDat[0].substr(0, 16) == "boxlvl2withdraw_")
								{
									howMany = infoDat[1];
									if (howMany.size() > 5) break;

									string coord_and_apos = infoDat[0].erase(0, 16);
									string::size_type pos = coord_and_apos.find('_');
									if (pos != std::string::npos)
									{
										coord = coord_and_apos.substr(0, pos);
										coord_and_apos.erase(0, pos + 1);
										apos = coord_and_apos;
									}
									else
									{
										autoBan(peer, false, 24 * 7, "Incorrect parameters boxlvl2_withdrawConfirm. Coord and id were: " + coord_and_apos);
										break;
									}
									auto isdbox = std::experimental::filesystem::exists("storageboxlvl2/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
									if (!isdbox)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured while getting safe vault info.", 0, true);
										break;
									}

									bool contains_non_int3 = !std::regex_match(apos, std::regex("^[0-9]+$"));
									if (contains_non_int3 == true)
									{
										autoBan(peer, false, 24 * 7, "Proxy detect! boxlvl2_withdrawConfirm apos was: " + apos);
										break;
									}

									bool contains_non_int4 = !std::regex_match(howMany, std::regex("^[0-9]+$"));
									if (contains_non_int4 == true)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Invalid input in amount!", 0, false);
										break;
									}
									howManyInt = atoi(howMany.c_str());

									aposInt = atoi(apos.c_str());

									if (howManyInt < 1 || howManyInt > 250)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Invalid input in amount!", 0, false);
										break;
									}

									try
									{
										ifstream ifff("storageboxlvl2/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
										json j;
										ifff >> j;
										ifff.close();

										int itemid = 0;
										bool success = true;

										for (int i = 0; i < 20; i++)
										{
											if (j["storage"][i]["aposition"] == aposInt)
											{
												itemid = j["storage"][i]["itemid"];

												if (itemid == 0) break;

												if (howManyInt > j["storage"][i]["itemcount"])
												{
													Player::OnTextOverlay(peer, "`4Your Storage Box Xtreme - Level 2 does not contains such many.");
													break;
												}

												if (CheckItemExists(peer, j["storage"][i]["itemid"]))
												{
													int currentlyHave = GetQuantityOfItem(peer, j["storage"][i]["itemid"]);
													if (howManyInt + currentlyHave < 251)
													{
														SaveItemMoreTimes(j["storage"][i]["itemid"], howManyInt, peer, success, static_cast<PlayerInfo*>(peer->data)->rawName + " from Storage Box Xtreme - Level 2");
													}
													else
													{
														Player::OnTextOverlay(peer, "`4You don't have enought space.");
														break;
													}
												}
												else
												{
													if (static_cast<PlayerInfo*>(peer->data)->inventory.items.size() == static_cast<PlayerInfo*>(peer->data)->currentInventorySize)
													{
														Player::OnTextOverlay(peer, "`4Your inventory is full! You can purchase an inventory upgrade in the shop.");
														break;
													}

													SaveItemMoreTimes(j["storage"][i]["itemid"], howManyInt, peer, success, static_cast<PlayerInfo*>(peer->data)->rawName + " from Storage Box Xtreme - Level 2");
												}

												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wRemoved " + to_string(howManyInt) + " " + itemDefs[itemid].name + " from the Storage Box Xtreme - Level 2", 0, true);
												if (isMod(peer) && !isWorldOwner(peer, world)) LogAccountActivity(peer, "Removed " + to_string(howManyInt) + " " + itemDefs[itemid].name + " from Storage Box Xtreme - Level 2 (" + world->name + ")");

												if (j["storage"][i]["itemcount"] == howManyInt)
												{
													j["storage"][i]["itemid"] = 0;
													j["storage"][i]["placedby"] = "There was " + to_string(howManyInt) + " of " + to_string(itemid) + " item, and " + static_cast<PlayerInfo*>(peer->data)->rawName + " withdrawed them.";
													j["storage"][i]["itemcount"] = 0;
													j["instorage"] = j["instorage"].get<double>() - 1;
												}
												else
												{
													j["storage"][i]["itemcount"] = j["storage"][i]["itemcount"].get<double>() - howManyInt;
												}

												ofstream of("storageboxlvl2/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
												of << j << std::endl;
												of.close();
												break;
											}
										}
									}
									catch (std::exception&)
									{
										SendConsole("boxlvl2_withdrawConfirm Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_later(peer, 0);
									}
									catch (std::runtime_error&)
									{
										SendConsole("boxlvl2_withdrawConfirm Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_later(peer, 0);
									}
									catch (...)
									{
										SendConsole("boxlvl2_withdrawConfirm Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_later(peer, 0);
									}
								}
							}
						}
						if (btn == "boxlvl3_withdrawConfirm")
						{
							if (world == nullptr || static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT" || serverIsFrozen) continue;
							std::stringstream bss(cch);
							std::string bto;

							string howMany = "";
							string apos = "";
							string coord = "";
							int aposInt = 0;
							int howManyInt = 0;

							while (std::getline(bss, bto, '\n'))
							{
								vector<string> infoDat = explode("|", bto);
								if (infoDat[0].substr(0, 16) == "boxlvl3withdraw_")
								{
									howMany = infoDat[1];
									if (howMany.size() > 5) break;

									string coord_and_apos = infoDat[0].erase(0, 16);
									string::size_type pos = coord_and_apos.find('_');
									if (pos != std::string::npos)
									{
										coord = coord_and_apos.substr(0, pos);
										coord_and_apos.erase(0, pos + 1);
										apos = coord_and_apos;
									}
									else
									{
										autoBan(peer, false, 24 * 7, "Incorrect parameters boxlvl3_withdrawConfirm. Coord and id were: " + coord_and_apos);
										break;
									}
									auto isdbox = std::experimental::filesystem::exists("storageboxlvl3/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
									if (!isdbox)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured while getting safe vault info.", 0, true);
										break;
									}

									bool contains_non_int3 = !std::regex_match(apos, std::regex("^[0-9]+$"));
									if (contains_non_int3 == true)
									{
										autoBan(peer, false, 24 * 7, "Proxy detect! boxlvl3_withdrawConfirm apos was: " + apos);
										break;
									}

									bool contains_non_int4 = !std::regex_match(howMany, std::regex("^[0-9]+$"));
									if (contains_non_int4 == true)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Invalid input in amount!", 0, false);
										break;
									}
									howManyInt = atoi(howMany.c_str());

									aposInt = atoi(apos.c_str());

									if (howManyInt < 1 || howManyInt > 250)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Invalid input in amount!", 0, false);
										break;
									}

									try
									{
										ifstream ifff("storageboxlvl3/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
										json j;
										ifff >> j;
										ifff.close();

										int itemid = 0;
										bool success = true;

										for (int i = 0; i < 20; i++)
										{
											if (j["storage"][i]["aposition"] == aposInt)
											{
												itemid = j["storage"][i]["itemid"];

												if (itemid == 0) break;

												if (howManyInt > j["storage"][i]["itemcount"])
												{
													Player::OnTextOverlay(peer, "`4Your Storage Box Xtreme - Level 3 does not contains such many.");
													break;
												}

												if (CheckItemExists(peer, j["storage"][i]["itemid"]))
												{
													int currentlyHave = GetQuantityOfItem(peer, j["storage"][i]["itemid"]);
													if (howManyInt + currentlyHave < 251)
													{
														SaveItemMoreTimes(j["storage"][i]["itemid"], howManyInt, peer, success, static_cast<PlayerInfo*>(peer->data)->rawName + " from Storage Box Xtreme - Level 3");
													}
													else
													{
														Player::OnTextOverlay(peer, "`4You don't have enought space.");
														break;
													}
												}
												else
												{
													if (static_cast<PlayerInfo*>(peer->data)->inventory.items.size() == static_cast<PlayerInfo*>(peer->data)->currentInventorySize)
													{
														Player::OnTextOverlay(peer, "`4Your inventory is full! You can purchase an inventory upgrade in the shop.");
														break;
													}

													SaveItemMoreTimes(j["storage"][i]["itemid"], howManyInt, peer, success, static_cast<PlayerInfo*>(peer->data)->rawName + " from Storage Box Xtreme - Level 3");
												}

												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wRemoved " + to_string(howManyInt) + " " + itemDefs[itemid].name + " from the Storage Box Xtreme - Level 3", 0, true);
												if (isMod(peer) && !isWorldOwner(peer, world)) LogAccountActivity(peer, "Removed " + to_string(howManyInt) + " " + itemDefs[itemid].name + " from Storage Box Xtreme - Level 3 (" + world->name + ")");		

												if (j["storage"][i]["itemcount"] == howManyInt)
												{
													j["storage"][i]["itemid"] = 0;
													j["storage"][i]["placedby"] = "There was " + to_string(howManyInt) + " of " + to_string(itemid) + " item, and " + static_cast<PlayerInfo*>(peer->data)->rawName + " withdrawed them.";
													j["storage"][i]["itemcount"] = 0;
													j["instorage"] = j["instorage"].get<double>() - 1;
												}
												else
												{
													j["storage"][i]["itemcount"] = j["storage"][i]["itemcount"].get<double>() - howManyInt;
												}

												ofstream of("storageboxlvl3/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
												of << j << std::endl;
												of.close();
												break;
											}
										}
									}
									catch (std::exception&)
									{
										SendConsole("boxlvl3_withdrawConfirm Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_later(peer, 0);
									}
									catch (std::runtime_error&)
									{
										SendConsole("boxlvl3_withdrawConfirm Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_later(peer, 0);
									}
									catch (...)
									{
										SendConsole("boxlvl3_withdrawConfirm Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_later(peer, 0);
									}
								}
							}
						}
						if (btn == "boxlvl1_withdrawConfirm")
						{
							if (world == nullptr || static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT" || serverIsFrozen) continue;
							std::stringstream bss(cch);
							std::string bto;

							string howMany = "";
							string apos = "";
							string coord = "";
							int aposInt = 0;
							int howManyInt = 0;

							while (std::getline(bss, bto, '\n'))
							{
								vector<string> infoDat = explode("|", bto);
								if (infoDat[0].substr(0, 16) == "boxlvl1withdraw_")
								{
									howMany = infoDat[1];
									if (howMany.size() > 5) break;

									string coord_and_apos = infoDat[0].erase(0, 16);
									string::size_type pos = coord_and_apos.find('_');
									if (pos != std::string::npos)
									{
										coord = coord_and_apos.substr(0, pos);
										coord_and_apos.erase(0, pos + 1);
										apos = coord_and_apos;
									}
									else
									{
										autoBan(peer, false, 24 * 7, "Incorrect parameters boxlvl1_withdrawConfirm. Coord and id were: " + coord_and_apos);
										break;
									}
									auto isdbox = std::experimental::filesystem::exists("storageboxlvl1/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
									if (!isdbox)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured while getting safe vault info.", 0, true);
										break;
									}

									bool contains_non_int3 = !std::regex_match(apos, std::regex("^[0-9]+$"));
									if (contains_non_int3 == true)
									{
										autoBan(peer, false, 24 * 7, "Proxy detect! boxlvl1_withdrawConfirm apos was: " + apos);
										break;
									}

									bool contains_non_int4 = !std::regex_match(howMany, std::regex("^[0-9]+$"));
									if (contains_non_int4 == true)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Invalid input in amount!", 0, false);
										break;
									}
									howManyInt = atoi(howMany.c_str());

									aposInt = atoi(apos.c_str());

									if (howManyInt < 1 || howManyInt > 250)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Invalid input in amount!", 0, false);
										break;
									}

									try
									{
										ifstream ifff("storageboxlvl1/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
										json j;
										ifff >> j;
										ifff.close();

										int itemid = 0;
										bool success = true;

										for (int i = 0; i < 20; i++)
										{
											if (j["storage"][i]["aposition"] == aposInt)
											{
												itemid = j["storage"][i]["itemid"];

												if (itemid == 0) break;

												if (howManyInt > j["storage"][i]["itemcount"])
												{
													Player::OnTextOverlay(peer, "`4Your Storage Box Xtreme - Level 1 does not contains such many.");
													break;
												}

												if (CheckItemExists(peer, j["storage"][i]["itemid"]))
												{
													int currentlyHave = GetQuantityOfItem(peer, j["storage"][i]["itemid"]);
													if (howManyInt + currentlyHave < 251)
													{
														SaveItemMoreTimes(j["storage"][i]["itemid"], howManyInt, peer, success, static_cast<PlayerInfo*>(peer->data)->rawName + " from Storage Box Xtreme - Level 1");
													}
													else
													{
														Player::OnTextOverlay(peer, "`4You don't have enought space.");
														break;
													}
												}
												else
												{
													if (static_cast<PlayerInfo*>(peer->data)->inventory.items.size() == static_cast<PlayerInfo*>(peer->data)->currentInventorySize)
													{
														Player::OnTextOverlay(peer, "`4Your inventory is full! You can purchase an inventory upgrade in the shop.");
														break;
													}

													SaveItemMoreTimes(j["storage"][i]["itemid"], howManyInt, peer, success, static_cast<PlayerInfo*>(peer->data)->rawName + " from Storage Box Xtreme - Level 1");
												}

												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wRemoved " + to_string(howManyInt) + " " + itemDefs[itemid].name + " from the Storage Box Xtreme - Level 1", 0, true);
												if (isMod(peer) && !isWorldOwner(peer, world)) LogAccountActivity(peer, "Removed " + to_string(howManyInt) + " " + itemDefs[itemid].name + " from Storage Box Xtreme - Level 1 (" + world->name + ")");

												if (j["storage"][i]["itemcount"] == howManyInt)
												{
													j["storage"][i]["itemid"] = 0;
													j["storage"][i]["placedby"] = "There was " + to_string(howManyInt) + " of " + to_string(itemid) + " item, and " + static_cast<PlayerInfo*>(peer->data)->rawName + " withdrawed them.";
													j["storage"][i]["itemcount"] = 0;
													j["instorage"] = j["instorage"].get<double>() - 1;
												}
												else
												{
													j["storage"][i]["itemcount"] = j["storage"][i]["itemcount"].get<double>() - howManyInt;
												}

												ofstream of("storageboxlvl1/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
												of << j << std::endl;
												of.close();
												break;
											}
										}
									}
									catch (std::exception&)
									{
										SendConsole("boxlvl1_withdrawConfirm Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_later(peer, 0);
									}
									catch (std::runtime_error&)
									{
										SendConsole("boxlvl1_withdrawConfirm Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_later(peer, 0);
									}
									catch (...)
									{
										SendConsole("boxlvl1_withdrawConfirm Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_later(peer, 0);
									}
								}
							}
						}
						if (btn.substr(0, 21) == "safeBoxDepositedItem_")
						{
							if (world == nullptr || static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT" || serverIsFrozen) continue;
							if (static_cast<PlayerInfo*>(peer->data)->rawName == PlayerDB::getProperName(world->owner) || world->owner == "" || isMod(peer))
							{
								string apos_and_coord = btn.erase(0, 21);
								string::size_type pos = apos_and_coord.find('_');
								string apos = "";
								string coord = "";

								if (pos != std::string::npos)
								{
									apos = apos_and_coord.substr(0, pos);
									apos_and_coord.erase(0, pos + 1);
									coord = apos_and_coord;
								}
								else
								{
									autoBan(peer, false, 24 * 7, "Incorrect parameters safeBoxDepositedItem_. apos and coord were: " + apos_and_coord);
									break;
								}
								auto isdbox = std::experimental::filesystem::exists("safevault/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
								if (!isdbox)
								{
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured while getting safe vault info.", 0, true);
									break;
								}

								bool contains_non_int3 = !std::regex_match(apos, std::regex("^[0-9]+$"));
								if (contains_non_int3 == true)
								{
									autoBan(peer, false, 24 * 7, "Proxy detect! safeBoxDepositedItem_ apos was: " + apos);
									break;
								}

								try
								{
									ifstream ifff("safevault/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
									json j;
									ifff >> j;
									ifff.close();

									int itemid = 0;
									int count = 0;
									for (int i = 0; i < 20; i++)
									{
										if (j["safe"][i]["aposition"] == atoi(apos.c_str()))
										{
											itemid = j["safe"][i]["itemid"];
											count = j["safe"][i]["itemcount"];
											GTDialog mySafe;
											mySafe.addLabelWithIcon("`wSafe Vault", 8878, LABEL_BIG);
											mySafe.addSmallText("`oYou have `w" + to_string(count) + " " + itemDefs[itemid].name + " `ostored.");
											mySafe.addSmallText("`oWithdraw how many?");
											mySafe.addInputBox("safewithdraw_" + coord + "_" + apos, "", to_string(count), 5);
											mySafe.addSpacer(SPACER_SMALL);
											mySafe.addQuickExit();
											mySafe.endDialog("safe_withdrawConfirm", "Remove items", "Exit");
											Player::OnDialogRequest(peer, mySafe.finishDialog());
											break;
										}
									}
								}
								catch (std::exception&)
								{
									SendConsole("safeBoxDepositedItem_ Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_later(peer, 0);
								}
								catch (std::runtime_error&)
								{
									SendConsole("safeBoxDepositedItem_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_later(peer, 0);
								}
								catch (...)
								{
									SendConsole("safeBoxDepositedItem_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_later(peer, 0);
								}
							}
						}
						if (btn.substr(0, 29) == "saferecoverPasswordInConfirm_")
						{
							if (static_cast<PlayerInfo*>(peer->data)->rawName == PlayerDB::getProperName(world->owner) || world->owner == "" || isMod(peer))
							{
								if (world == nullptr || static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT" || serverIsFrozen) continue;
								string coord = btn.substr(btn.find("_") + 1);
								auto isdbox = std::experimental::filesystem::exists("safevault/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
								if (!isdbox)
								{
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured. Break the safe.", 0, true);
									break;
								}
								GTDialog recover;
								recover.addLabelWithIcon("`wSafe Vault", 8878, LABEL_BIG);
								recover.addSmallText("Please enter recovery answer.");
								recover.addInputBox("saferecoveryanswer_" + coord, "", "", 12);
								recover.addButton("saferecoveryanswerconfirm", "Enter Recovery Answer");
								recover.addSpacer(SPACER_SMALL);
								recover.addQuickExit();
								recover.endDialog("Close", "", "Exit");
								Player::OnDialogRequest(peer, recover.finishDialog());
							}
						}
						if (btn == "saferecoveryanswerconfirm")
						{
							if (world == nullptr || static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT" || serverIsFrozen) continue;
							std::stringstream bss(cch);
							std::string bto;

							string recoveryanswer = "";
							string coord = "";

							while (std::getline(bss, bto, '\n'))
							{
								vector<string> infoDat = explode("|", bto);
								if (infoDat[0].substr(0, 19) == "saferecoveryanswer_")
								{
									if (static_cast<PlayerInfo*>(peer->data)->rawName == PlayerDB::getProperName(world->owner) || world->owner == "" || isMod(peer))
									{
										recoveryanswer = infoDat[1];
										coord = infoDat[0].substr(19, infoDat[0].length() - 1).c_str();
										auto isdbox = std::experimental::filesystem::exists("safevault/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
										if (!isdbox)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured. Break the safe.", 0, true);
											break;
										}
										try
										{
											ifstream ifff("safevault/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
											json j;
											ifff >> j;
											ifff.close();

											if (recoveryanswer != j["recovery"])
											{
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Recovery answer did not match!", 0, true);
												break;
											}

											j["password"] = "";
											j["recovery"] = "";
											ofstream of("safevault/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
											of << j << std::endl;
											of.close();

											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Your safe vault was `2Updated!", 0, true);
										}
										catch (std::exception&)
										{
											SendConsole("saferecoveryanswer_ Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_later(peer, 0);
										}
										catch (std::runtime_error&)
										{
											SendConsole("saferecoveryanswer_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_later(peer, 0);
										}
										catch (...)
										{
											SendConsole("saferecoveryanswer_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_later(peer, 0);
										}
									}
								}
							}
						}
						if (btn == "safe_updatepassword")
						{
							if (world == nullptr || static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT" || serverIsFrozen) continue;
							std::stringstream bss(cch);
							std::string bto;

							string inputoldpass = "";
							string coord = "";
							string newpass = "";
							string recans = "";

							while (std::getline(bss, bto, '\n'))
							{
								vector<string> infoDat = explode("|", bto);
								if (infoDat[0].substr(0, 16) == "safeoldpassword_")
								{
									if (static_cast<PlayerInfo*>(peer->data)->rawName == PlayerDB::getProperName(world->owner) || world->owner == "" || isMod(peer))
									{
										inputoldpass = infoDat[1];
										coord = infoDat[0].substr(16, infoDat[0].length() - 1).c_str();
										auto isdbox = std::experimental::filesystem::exists("safevault/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
										if (!isdbox)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured. Break the safe.", 0, true);
											break;
										}
										try
										{
											ifstream ifff("safevault/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
											json j;
											ifff >> j;
											ifff.close();

											if (j["password"] != inputoldpass)
											{
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Old password did not match", 0, true);
												break;
											}
										}
										catch (std::exception&)
										{
											SendConsole("safeoldpassword_ Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_later(peer, 0);
										}
										catch (std::runtime_error&)
										{
											SendConsole("safeoldpassword_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_later(peer, 0);
										}
										catch (...)
										{
											SendConsole("safeoldpassword_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_later(peer, 0);
										}
									}
								}
								if (infoDat[0] == "safe_newpassword")
								{
									if (static_cast<PlayerInfo*>(peer->data)->rawName == PlayerDB::getProperName(world->owner) || world->owner == "" || isMod(peer))
									{
										newpass = infoDat[1];
									}
								}
								if (infoDat[0] == "storage_recoveryanswer")
								{
									if (static_cast<PlayerInfo*>(peer->data)->rawName == PlayerDB::getProperName(world->owner) || world->owner == "" || isMod(peer))
									{
										recans = infoDat[1];

										try
										{
											ifstream ifff("safevault/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
											json j;
											ifff >> j;
											ifff.close();

											j["password"] = newpass;
											j["recovery"] = recans;
											ofstream of("safevault/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
											of << j << std::endl;
											of.close();

											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Your safe vault was `2Updated!", 0, true);
										}
										catch (std::exception&)
										{
											SendConsole("storage_recoveryanswer Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_later(peer, 0);
										}
										catch (std::runtime_error&)
										{
											SendConsole("storage_recoveryanswer Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_later(peer, 0);
										}
										catch (...)
										{
											SendConsole("storage_recoveryanswer Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_later(peer, 0);
										}
									}
								}
							}
						}
						if (btn == "safe_removepassword")
						{
							if (world == nullptr || static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT" || serverIsFrozen) continue;
							std::stringstream bss(cch);
							std::string bto;

							string inputoldpass = "";
							string coord = "";

							while (std::getline(bss, bto, '\n'))
							{
								vector<string> infoDat = explode("|", bto);
								if (infoDat[0].substr(0, 16) == "safeoldpassword_")
								{
									if (static_cast<PlayerInfo*>(peer->data)->rawName == PlayerDB::getProperName(world->owner) || world->owner == "" || isMod(peer))
									{
										inputoldpass = infoDat[1];
										coord = infoDat[0].substr(16, infoDat[0].length() - 1).c_str();
										auto isdbox = std::experimental::filesystem::exists("safevault/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
										if (!isdbox)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured. Break the safe.", 0, true);
											break;
										}
										try
										{
											ifstream ifff("safevault/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
											json j;
											ifff >> j;
											ifff.close();

											if (j["password"] != inputoldpass)
											{
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Old password did not match", 0, true);
												break;
											}

											j["password"] = "";
											j["recovery"] = "";
											ofstream of("safevault/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
											of << j << std::endl;
											of.close();

											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Your safe vault is no longer `4Password Protected`o!", 0, true);
											if (isMod(peer) && !isWorldOwner(peer, world)) LogAccountActivity(peer, "Disabled Safe Vault password protection (" + world->name + ")");
										}
										catch (std::exception&)
										{
											SendConsole("safeoldpassword_ Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_later(peer, 0);
										}
										catch (std::runtime_error&)
										{
											SendConsole("safeoldpassword_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_later(peer, 0);
										}
										catch (...)
										{
											SendConsole("safeoldpassword_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_later(peer, 0);
										}
									}
								}
							}
						}
						if (btn == "safe_setpassword")
						{
							if (world == nullptr || static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT" || serverIsFrozen) continue;
							std::stringstream bss(cch);
							std::string bto;

							string inputnewpass = "";
							string coord = "";
							string inputnewrecoveryans = "";

							while (std::getline(bss, bto, '\n'))
							{
								vector<string> infoDat = explode("|", bto);
								if (infoDat[0].substr(0, 12) == "safenewpass_")
								{
									if (static_cast<PlayerInfo*>(peer->data)->rawName == PlayerDB::getProperName(world->owner) || world->owner == "" || isMod(peer))
									{
										inputnewpass = infoDat[1];
										coord = infoDat[0].substr(12, infoDat[0].length() - 1).c_str();
										auto isdbox = std::experimental::filesystem::exists("safevault/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
										if (!isdbox)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured. Break the safe.", 0, true);
											break;
										}

										if (inputnewpass.size() < 2)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Your password is too easy.", 0, true);
											break;
										}
									}
								}
								if (infoDat[0] == "safe_recoverypass")
								{
									if (static_cast<PlayerInfo*>(peer->data)->rawName == PlayerDB::getProperName(world->owner) || world->owner == "" || isMod(peer))
									{
										inputnewrecoveryans = infoDat[1];

										if (inputnewpass.size() < 2)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Your recovery answer is too easy.", 0, true);
											break;
										}

										try
										{
											ifstream ifff("safevault/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
											json j;
											ifff >> j;
											ifff.close();
											j["password"] = inputnewpass;
											j["recovery"] = inputnewrecoveryans;

											ofstream of("safevault/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
											of << j << std::endl;
											of.close();

											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Your safe vault is now `2Password Protected`o!", 0, true);
											if (isMod(peer) && !isWorldOwner(peer, world)) LogAccountActivity(peer, "Changed Safe Vault password to " + inputnewpass + " and recovery answer to " + inputnewrecoveryans + " (" + world->name + ")");
										}
										catch (std::exception&)
										{
											SendConsole("safe_recoverypass Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_later(peer, 0);
										}
										catch (std::runtime_error&)
										{
											SendConsole("safe_recoverypass Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_later(peer, 0);
										}
										catch (...)
										{
											SendConsole("safe_recoverypass Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_later(peer, 0);
										}
									}
								}
							}
						}

						if (btn == "safe_confirmpass")
						{
							if (world == nullptr || static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT" || serverIsFrozen) continue;
							std::stringstream bss(cch);
							std::string bto;

							string inputpass = "";

							while (std::getline(bss, bto, '\n'))
							{
								vector<string> infoDat = explode("|", bto);
								if (infoDat[0].substr(0, 21) == "safeconfirmpassInput_")
								{
									inputpass = infoDat[1];
									if (static_cast<PlayerInfo*>(peer->data)->rawName == PlayerDB::getProperName(world->owner) || world->owner == "" || isMod(peer))
									{
										string coord = infoDat[0].substr(21, infoDat[0].length() - 1).c_str();
										auto isdbox = std::experimental::filesystem::exists("safevault/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
										if (!isdbox)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4An error occured. Break the safe.", 0, true);
											break;
										}
										try
										{
											ifstream ifff("safevault/" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "/X" + coord + ".json");
											json j;
											ifff >> j;
											ifff.close();
											string basic_string = j["password"];
											if (inputpass != basic_string)
											{
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`4Password did not match", 0, true);
												break;
											}
											int stored = j["insafe"];

											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`2Password matched", 0, true);

											GTDialog mySafe;
											mySafe.addLabelWithIcon("`wSafe Vault", 8878, LABEL_BIG);

											if (stored > 0)
											{
												mySafe.addSpacer(SPACER_SMALL);
											}

											int count = 0;
											int id = 0;
											int aposition = 0;
											for (int i = 0; i < 20; i++)
											{
												if (j["safe"][i]["itemid"] != 0)
												{
													count = j["safe"][i]["itemcount"];
													id = j["safe"][i]["itemid"];
													aposition = j["safe"][i]["aposition"];

													if (i % 6 == 0 && i != 0)
													{
														mySafe.addStaticBlueFrameWithIdCountText(to_string(id), to_string(count), getItemDef(id).name, "safeBoxDepositedItem_" + to_string(aposition) + "_" + coord, true);
													}
													else
													{
														mySafe.addStaticBlueFrameWithIdCountText(to_string(id), to_string(count), getItemDef(id).name, "safeBoxDepositedItem_" + to_string(aposition) + "_" + coord, false);
													}
												}
											}

											if (stored > 0)
											{
												mySafe.addNewLineAfterFrame();
											}

											mySafe.addSmallText("`w" + to_string(stored) + "/20 `$items stored.");
											mySafe.addSpacer(SPACER_SMALL);
											mySafe.addPicker("safedeposit_" + coord, "Deposit item", "Select an item");
											if (j["password"] == "")
											{
												mySafe.addSmallText("`$This Safe Vault is not `4password protected`$!");
											}
											else
											{
												mySafe.addSmallText("`$This Safe Vault is `2password protected`$!");
											}
											mySafe.addSpacer(SPACER_SMALL);
											mySafe.addSmallText("`$Change your password.");
											mySafe.addButton("safeupdatepass_" + coord, "Update Password");

											mySafe.addSpacer(SPACER_SMALL);
											mySafe.addQuickExit();
											mySafe.endDialog("Close", "", "Exit");
											Player::OnDialogRequest(peer, mySafe.finishDialog());
										}
										catch (std::exception&)
										{
											SendConsole("safeconfirmpassInput_ Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_later(peer, 0);
										}
										catch (std::runtime_error&)
										{
											SendConsole("safeconfirmpassInput_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_later(peer, 0);
										}
										catch (...)
										{
											SendConsole("safeconfirmpassInput_ Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_later(peer, 0);
										}
										break;
									}
								}
							}
						}
						if (btn == "pickupdisplayitem")
						{
							if (world == nullptr || static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT" || serverIsFrozen) continue;
							if (static_cast<PlayerInfo*>(peer->data)->rawName == world->owner || world->owner == "")
							{
								short dfg = static_cast<PlayerInfo*>(peer->data)->displayfg;
								short dbg = static_cast<PlayerInfo*>(peer->data)->displaybg;
								int x = static_cast<PlayerInfo*>(peer->data)->displaypunchx;
								int y = static_cast<PlayerInfo*>(peer->data)->displaypunchy;
								static_cast<PlayerInfo*>(peer->data)->displayfg = 0;
								static_cast<PlayerInfo*>(peer->data)->displaybg = 0;
								static_cast<PlayerInfo*>(peer->data)->displaypunchx = 0;
								static_cast<PlayerInfo*>(peer->data)->displaypunchy = 0;
								if (world->items[x + (y * world->width)].intdata != 0)
								{
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wYou removed `5" + getItemDef(world->items[x + (y * world->width)].intdata).name + " `wfrom the Display Block.", 0, true);
									bool success = true;
									SaveItemMoreTimes(world->items[x + (y * world->width)].intdata, 1, peer, success, static_cast<PlayerInfo*>(peer->data)->rawName + " from Display Block");
									world->items[x + (y * world->width)].intdata = 0;
									ENetPeer* currentPeer;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
											continue;
										if (isHere(peer, currentPeer))
										{
											UpdateVisualsForBlock(currentPeer, true, x, y, world);
										}
									}
									if (isMod(peer) && !isWorldOwner(peer, world)) LogAccountActivity(peer, "Pickup " + getItemDef(world->items[x + (y * world->width)].intdata).name + " from " + getItemDef(world->items[x + (y * world->width)].foreground).name + " (" + world->name + ")");
								}
								else
								{
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Error occured while trying to remove item!", 0, true);
									continue;
								}
							}
						}
						if (btn == "WorldDropPickup")
						{
							if (world == nullptr || static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT" || serverIsFrozen) continue;
							if (static_cast<PlayerInfo*>(peer->data)->rawName == world->owner || isMod(peer))
							{
								if (!world->DisableDrop)
								{
									world->DisableDrop = true;
									Player::OnConsoleMessage(peer, "`oVisitors can no longer collect dropped items!");
									ENetPeer* currentPeer;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
										if (static_cast<PlayerInfo*>(peer->data)->rawName == world->owner) continue;
										if (static_cast<PlayerInfo*>(peer->data)->currentWorld != "EXIT")
										{
											if (static_cast<PlayerInfo*>(peer->data)->currentWorld == static_cast<PlayerInfo*>(currentPeer->data)->currentWorld)
											{
												Player::OnConsoleMessage(currentPeer, "`oOwner has disabled ability to collect dropped items!");
											}
										}
									}
									if (isMod(peer) && !isWorldOwner(peer, world)) LogAccountActivity(peer, "Disabled ability to collect dropped items (" + world->name + ")");
								}
								else
								{
									world->DisableDrop = false;
									Player::OnConsoleMessage(peer, "`oVisitors can again collect dropped items!");
									ENetPeer* currentPeer;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
										if (static_cast<PlayerInfo*>(peer->data)->rawName == world->owner) continue;
										if (static_cast<PlayerInfo*>(peer->data)->currentWorld != "EXIT")
										{
											if (static_cast<PlayerInfo*>(peer->data)->currentWorld == static_cast<PlayerInfo*>(currentPeer->data)->currentWorld)
											{
												Player::OnConsoleMessage(currentPeer, "`oOwner has enabled ability to collect dropped items!");
											}
										}
									}
									if (isMod(peer) && !isWorldOwner(peer, world)) LogAccountActivity(peer, "Enabled ability to collect dropped items (" + world->name + ")");
								}
							}
						}
						if (btn == "getremote") {
							if (world == nullptr || static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT" || serverIsFrozen) continue;
							int x = static_cast<PlayerInfo*>(peer->data)->lastPunchX;
							int y = static_cast<PlayerInfo*>(peer->data)->lastPunchY;
							bool canuseremote = true;
							if (canuseremote) {
								if (static_cast<PlayerInfo*>(peer->data)->inventory.items.size() == static_cast<PlayerInfo*>(peer->data)->currentInventorySize) {
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wInventory is full!", 0, true);
									continue;
								}
								bool iscontainss = false;
								SearchInventoryItem(peer, 5640, 1, iscontainss);
								if (!iscontainss) {
									if (isWorldOwner(peer, world) && world->items[x + (y * world->width)].mid != 0 && world->items[x + (y * world->width)].mc != 0 || world->items[x + (y * world->width)].rm && world->items[x + (y * world->width)].mid != 0 && world->items[x + (y * world->width)].mc != 0) {
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wYou received a MAGPLANT 5000 Remote.", 0, true);
										bool success = true;
										SaveItemMoreTimes(5640, 1, peer, success, static_cast<PlayerInfo*>(peer->data)->rawName + " from MAGPLANT 5000");
										static_cast<PlayerInfo*>(peer->data)->magplantitemid = world->items[x + (y * world->width)].mid;
										static_cast<PlayerInfo*>(peer->data)->magplantx = x;
										static_cast<PlayerInfo*>(peer->data)->magplanty = y;
									}
								}
								else {
									static_cast<PlayerInfo*>(peer->data)->magplantitemid = world->items[x + (y * world->width)].mid;
									static_cast<PlayerInfo*>(peer->data)->magplantx = x;
									static_cast<PlayerInfo*>(peer->data)->magplanty = y;
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wYou received a MAGPLANT 5000 Remote.", 0, true);
								}
							}
						}
						if (btn == "retrieveitem") {
							if (world == nullptr || static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT" || serverIsFrozen) continue;
							if (static_cast<PlayerInfo*>(peer->data)->rawName != world->owner && !isMod(peer)) continue;
							int x = static_cast<PlayerInfo*>(peer->data)->lastPunchX;
							int y = static_cast<PlayerInfo*>(peer->data)->lastPunchY;
							int suckerid = static_cast<PlayerInfo*>(peer->data)->suckerid;
							string suckername = static_cast<PlayerInfo*>(peer->data)->suckername;
							if (world->items[x + (y * world->width)].mid == 112) {
								bool iscontainss = false;
								SearchInventoryItem(peer, 5640, 1, iscontainss);
								if (iscontainss) {
									static_cast<PlayerInfo*>(peer->data)->magplantitemid = 0;
									RemoveInventoryItem(5640, 1, peer, true);
								}
								int currentgems = 0;
								ifstream fs("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
								fs >> currentgems;
								fs.close();
								currentgems += world->items[x + (y * world->width)].mc;
								GamePacket psa = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), currentgems));
								ENetPacket* packetsa = enet_packet_create(psa.data, psa.len, ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packetsa);
								ofstream of("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
								of << currentgems;
								of.close();
								Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`oCollected `2" + to_string(world->items[x + (y * world->width)].mc) + " `5" + getItemDef(world->items[x + (y * world->width)].mid).name + " `oFrom the " + getItemDef(suckerid).name + "!", 0, true);
								ENetPeer* currentPeer;
								for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
									if (isHere(peer, currentPeer)) {
										SendItemSucker(currentPeer, suckerid, x, y, world->items[x + (y * world->width)].mid, 0, true, true, world->items[x + (y * world->width)].background);
									}
								}
								if (isMod(peer) && !isWorldOwner(peer, world)) LogAccountActivity(peer, "Collected " + to_string(world->items[x + (y * world->width)].mc) + " " + getItemDef(world->items[x + (y * world->width)].mid).name + " from " + getItemDef(world->items[x + (y * world->width)].foreground).name + " (" + world->name + ")");
								world->items[x + (y * world->width)].mc = 0;
								continue;
							}
							if (world->items[x + (y * world->width)].mc > 250) {
								if (CheckItemMaxed(peer, world->items[x + (y * world->width)].mid, 250)) {
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wI dont have a free space to pickup `2250 `$" + getItemDef(world->items[x + (y * world->width)].mid).name + "`w!", 0, true);
									continue;
								} else {
									world->items[x + (y * world->width)].mc -= 250;
									bool success = true;
									SaveItemMoreTimes(world->items[x + (y * world->width)].mid, 250, peer, success, static_cast<PlayerInfo*>(peer->data)->rawName + " withdraw from MAGPLANT 5000");
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`oCollected `2250 `5" + getItemDef(world->items[x + (y * world->width)].mid).name + " `oFrom the " + getItemDef(suckerid).name + "!", 0, true);
									ENetPeer* currentPeer;
									for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
										if (isHere(peer, currentPeer)) {
											SendItemSucker(currentPeer, suckerid, x, y, world->items[x + (y * world->width)].mid, 1, true, true, world->items[x + (y * world->width)].background);
										}
									}
									if (isMod(peer) && !isWorldOwner(peer, world)) LogAccountActivity(peer, "Collected 250 " + getItemDef(world->items[x + (y * world->width)].mid).name + " from " + getItemDef(world->items[x + (y * world->width)].foreground).name + " (" + world->name + ")");
								}
							} else {
								if (CheckItemMaxed(peer, world->items[x + (y * world->width)].mid, world->items[x + (y * world->width)].mc)) {
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wI dont have a free space to pickup `2" + to_string(world->items[x + (y * world->width)].mc) + " `$" + getItemDef(world->items[x + (y * world->width)].mid).name + "`w!", 0, true);
									continue;
								} else {
									bool iscontainss = false;
									SearchInventoryItem(peer, 5640, 1, iscontainss);
									if (iscontainss) {
										static_cast<PlayerInfo*>(peer->data)->magplantitemid = 0;
										RemoveInventoryItem(5640, 1, peer, true);
									}
									bool success = true;
									SaveItemMoreTimes(world->items[x + (y * world->width)].mid, world->items[x + (y * world->width)].mc, peer, success, static_cast<PlayerInfo*>(peer->data)->rawName + " withdraw from MAGPLANT 5000");
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`oCollected `2" + to_string(world->items[x + (y * world->width)].mc) + " `5" + getItemDef(world->items[x + (y * world->width)].mid).name + " `oFrom the " + getItemDef(suckerid).name + "!", 0, true);
									ENetPeer* currentPeer;
									for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
										if (isHere(peer, currentPeer)) {
											SendItemSucker(currentPeer, suckerid, x, y, world->items[x + (y * world->width)].mid, 0, true, true, world->items[x + (y * world->width)].background);
										}
									}
									if (isMod(peer) && !isWorldOwner(peer, world)) LogAccountActivity(peer, "Collected " + to_string(world->items[x + (y * world->width)].mc) + " " + getItemDef(world->items[x + (y * world->width)].mid).name + " from " + getItemDef(world->items[x + (y * world->width)].foreground).name + " (" + world->name + ")");
									world->items[x + (y * world->width)].mc = 0;
								}
							}
						}	
						if (btn.substr(0, 17) == "showuseractivity_") {
							if (!isMod(peer)) continue;
							string user = btn.substr(17, cch.length() - 17 - 1);
							MYSQL_ROW row;
							string q = "SELECT * FROM PlayerDatabase WHERE username = '" + user + "' LIMIT 1";
							if (mysql_query(conn, q.c_str())) {
								cout << mysql_error(conn) << endl;								
								continue;
							}
							string activitylog;
							res = mysql_store_result(conn);
							while (row = mysql_fetch_row(res)) {
								activitylog = row[59];
							}
							//if (res) mysql_free_result(res);
						}	
						if (btn.substr(0, 25) == "showuserinventoryoffline_") {
							if (!isMod(peer)) continue;
							string user = btn.substr(25, cch.length() - 25 - 1);
							try {
								MYSQL_ROW row;
								string q = "SELECT * FROM PlayerDatabase WHERE username = '" + user + "' LIMIT 1";
								if (mysql_query(conn, q.c_str())) {
									cout << mysql_error(conn) << endl;								
									continue;
								}
								string inventorydata;
								string inventorysizedata;
								res = mysql_store_result(conn);
								while (row = mysql_fetch_row(res)) {
									inventorysizedata = row[27];
									inventorydata = row[59];
								}
								//if (res) mysql_free_result(res);
								json j = toJson(inventorydata.c_str());
								int inventorySize = atoi(inventorysizedata.c_str());
								string appendItems = "";
								int itemid = 0;
								int itemCount = 0;
								for (int i = 0; i < inventorySize; i++) {
									itemid = j["items"][i]["itemid"];
									itemCount = j["items"][i]["quantity"];
									if (itemid == 0) continue;
									if (i % 6 == 0 && i != 0) {
										appendItems += "\nadd_button_with_icon||END_LIST|noflags|0|0|\nadd_button_with_icon|||staticBlueFrame|" + to_string(itemid) + "|" + to_string(itemCount) + "|";
									} else {
										appendItems += "\nadd_button_with_icon|||staticBlueFrame|" + to_string(itemid) + "|" + to_string(itemCount) + "|";
									}
								}
								Player::OnDialogRequest(peer, "set_default_color|\nadd_label|mid|`wViewing " + static_cast<PlayerInfo*>(peer->data)->lastInfo + " `winventory|right|\nadd_spacer|small|" + appendItems + "|\nadd_button_with_icon||END_LIST|noflags|0|0|\nadd_button|punishview|Back|");
							} catch (std::exception&) {
								SendConsole("showuserinventoryoffline_ Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
							}
						}
						if (btn == "warptosb")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->isCursed == true)
							{
								GamePacket p0 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4You are cursed now!"));
								ENetPacket* packet0 = enet_packet_create(p0.data,
									p0.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet0);
								delete p0.data;
								continue;
							}
							string act = static_cast<PlayerInfo*>(peer->data)->lastSdbWorld;
							if (act == "")
							{
								GamePacket po = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "Unable to track down the location of the broadcast."));
								ENetPacket* packet = enet_packet_create(po.data,
									po.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
							}
							else if (act == static_cast<PlayerInfo*>(peer->data)->currentWorld)
							{
								GamePacket po = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "Sorry, but you are already in the world!"));
								ENetPacket* packet = enet_packet_create(po.data,
									po.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
							}
							else
							{
								handle_world(peer, act);
							}
						}
						if (btn == "okgo")
						{
							static_cast<PlayerInfo*>(peer->data)->isBot = false;
						}
						if (btn == "inviteguildbutton")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->guild != "")
							{
								int number = static_cast<PlayerInfo*>(peer->data)->guildmatelist.size();
								if (number > 9)
								{
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`3FRIEND ERROR: `oYou already have `450 `ofriends! Please remove some before adding new ones!"));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									continue;
								}
								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (isHere(peer, currentPeer))
									{
										if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == static_cast<PlayerInfo*>(peer->data)->lastInfo)
										{
											string name = static_cast<PlayerInfo*>(currentPeer->data)->rawName;
											if (static_cast<PlayerInfo*>(currentPeer->data)->guild != "")
											{
												GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`3GUILD ERROR: `w" + static_cast<PlayerInfo*>(currentPeer->data)->displayName + "`o is already in a Guild!"));
												ENetPacket* packet = enet_packet_create(p.data,
													p.len,
													ENET_PACKET_FLAG_RELIABLE);
												enet_peer_send(peer, 0, packet);
												delete p.data;
											}
											else
											{
												GamePacket p4 = packetEnd(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"), static_cast<PlayerInfo*>(peer->data)->netID), "`5[`wGuild request sent to `2" + static_cast<PlayerInfo*>(currentPeer->data)->displayName + "`5]"));
												ENetPacket* packet4 = enet_packet_create(p4.data,
													p4.len,
													ENET_PACKET_FLAG_RELIABLE);
												enet_peer_send(peer, 0, packet4);
												delete p4.data;
												string text = "action|play_sfx\nfile|audio/tip_start.wav\ndelayMS|0\n";
												BYTE* data = new BYTE[5 + text.length()];
												BYTE zero = 0;
												int type = 3;
												memcpy(data, &type, 4);
												memcpy(data + 4, text.c_str(), text.length());
												memcpy(data + 4 + text.length(), &zero, 1);
												ENetPacket* packet2 = enet_packet_create(data,
													5 + text.length(),
													ENET_PACKET_FLAG_RELIABLE);
												enet_peer_send(currentPeer, 0, packet2);
												delete data;
												static_cast<PlayerInfo*>(currentPeer->data)->guildlast = static_cast<PlayerInfo*>(peer->data)->guild;
												static_cast<PlayerInfo*>(currentPeer->data)->isinvited = true;
												GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5[GUILD REQUEST] `oYou've been invited to join `2" + static_cast<PlayerInfo*>(peer->data)->guild + "`o by `w" + static_cast<PlayerInfo*>(peer->data)->displayName + "`o! To accept, `wwrench yourself `oand then choose `2Join " + static_cast<PlayerInfo*>(peer->data)->guild + "`o."));
												ENetPacket* packet = enet_packet_create(p.data,
													p.len,
													ENET_PACKET_FLAG_RELIABLE);
												enet_peer_send(currentPeer, 0, packet);
												delete p.data;
											}
										}
									}
								}
							}
							else
							{
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5[GUILD ERROR] `oYou must be in a Guild as a Elder or higher in order to invite players!"));
								ENetPacket* packet = enet_packet_create(p.data,
									p.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
						}
						if (btn == "manage_audio") {
							Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label|big|Select a song|right|\nadd_label|small|Just a quick note there none of these songs are owned by us they are suggested by server players and were added by the developer's Once you start playing song there is no way to stop it!|left|\nadd_spacer|small|\nadd_checkbox|checkbox_ahrix|Ahrix Nova (Ahrix)|0|\nadd_checkbox|checkbox_phut|Phut Hon (Vietnam)|0|\nadd_checkbox|checkbox_stopme|Don't stop me now (QUEEN)|0|\nadd_checkbox|checkbox_feelit|Can you feel it (NCS)|0|\nadd_checkbox|checkbox_sayso|Say So! (MEP)|0|\nadd_checkbox|checkbox_bealone|Never be alone (Cursed Sheep)|0|\nadd_button|Cancel|Play|noflags|0|0|\nend_dialog|song_edit||");
						}
						if (btn == "manage_title")
						{
							string titlecreatedialog = "";
							if (static_cast<PlayerInfo*>(peer->data)->Subscriber)
							{
								titlecreatedialog = "\nadd_button|edit_title|`oEdit Title``|";
							}
							Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label|big|No Titles Obtained|right|\nadd_spacer|small|" + titlecreatedialog + "\nadd_button||OK|noflags|0|0|\nend_dialog|title_edit||");
						}
						if (btn == "edit_title")
						{
							if (!static_cast<PlayerInfo*>(peer->data)->Subscriber) continue;
							Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label|big|`oEdit Your Title``|\nadd_textbox|`oHow to create a `$Title`o? Firstly make sure what `$Color `oYou want to use for example `2Green `oOr `4Red `oThen in the `$Input Box `oWrite your new `$Title `oLets say we want to use `4King `oAnd then simply press `$Save`o!|\nadd_spacer|small|\nadd_text_input|title_name|`$Title``||8|\nend_dialog|title_save|Cancel|Save|");
						}
						if (btn == "notebook_edit")
						{
							Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label|big|Notebook|left|0|\nadd_text_box_input|personal_note||" + static_cast<PlayerInfo*>(peer->data)->notebook + "|128|5|\nadd_spacer|small|\nadd_button|save|Save|noflags|0|0|\nadd_button|notebook_clear|Clear|noflags|0|0|\nadd_button|cancel|Cancel|noflags|0|0|\nend_dialog|notebook_edit||\nadd_quick_exit|");
						}
						if (btn == "worlds_view") {
							std::sort(static_cast<PlayerInfo*>(peer->data)->worldsowned.begin(), static_cast<PlayerInfo*>(peer->data)->worldsowned.end());
							auto it = std::unique(static_cast<PlayerInfo*>(peer->data)->worldsowned.begin(), static_cast<PlayerInfo*>(peer->data)->worldsowned.end());
							static_cast<PlayerInfo*>(peer->data)->worldsowned.erase(it, static_cast<PlayerInfo*>(peer->data)->worldsowned.end());
							string worlds_owned = "";
							for (int i = 0; i < static_cast<PlayerInfo*>(peer->data)->worldsowned.size(); i++) {
								if (i == static_cast<PlayerInfo*>(peer->data)->worldsowned.size() - 1) {
									worlds_owned += static_cast<PlayerInfo*>(peer->data)->worldsowned[i] + "";
								}
								else {
									worlds_owned += static_cast<PlayerInfo*>(peer->data)->worldsowned[i] + ", ";
								}
							}
							if (worlds_owned == "") worlds_owned = "You dont have any worlds locked!";
							Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label|big|Worlds Locked|right\nadd_spacer|small|\nadd_textbox|" + worlds_owned + "``|left|\nadd_spacer|small|\nadd_button||Close|noflags|0|0|\nend_dialog|my_worlds||");			
						}
						if (btn == "notebook_clear")
						{
							if (!static_cast<PlayerInfo*>(peer->data)->haveGrowId) continue;
							auto qstate = 0;
							if (conn == nullptr)
							{
								cout << "conn was nullptr" << endl;
								continue;
							}
							if (conn != nullptr)
							{
								stringstream ss;
								ss << "UPDATE PlayerDatabase SET notebook = '' WHERE username = '" + static_cast<PlayerInfo*>(peer->data)->rawName + "'";
								auto query = ss.str();
								const auto q = query.c_str();
								if (mysql_query(conn, q))
								{
									cout << mysql_error(conn) << endl;
									


									enet_peer_disconnect_later(peer, 0);
									continue;
								}
							}
							static_cast<PlayerInfo*>(peer->data)->notebook = "";
							Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`2Text cleared.", 0, true);
						}
						if (btn == "joinguild")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							vector<string> gmembers;
							string guildname = PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->guildlast);
							if (guildname != "")
							{
								try
								{
									std::ifstream ifff("guilds/" + guildname + ".json");
									if (ifff.fail())
									{
										ifff.close();
										continue;
									}
									json j;
									ifff >> j;
									int glevel;
									glevel = j["GuildLevel"];
									for (int i = 0; i < j["Member"].size(); i++)
									{
										gmembers.push_back(j["Member"][i]);
									}
									ifff.close();
									int membercount = gmembers.size();
									int maxmembers = 15;
									if (glevel == 2)
									{
										maxmembers = 20;
									}
									else if (glevel == 3)
									{
										maxmembers = 25;
									}
									else if (glevel == 4)
									{
										maxmembers = 30;
									}
									else if (glevel == 5)
									{
										maxmembers = 35;
									}
									else if (glevel == 6)
									{
										maxmembers = 40;
									}
									else if (glevel == 7)
									{
										maxmembers = 45;
									}
									else if (glevel == 8)
									{
										maxmembers = 50;
									}
									if (membercount >= maxmembers)
									{
										Player::OnConsoleMessage(peer, "`5[GUILD ALERT] `oThat guild is already full!");
										continue;
									}
									else
									{
										static_cast<PlayerInfo*>(peer->data)->guild = static_cast<PlayerInfo*>(peer->data)->guildlast;
										static_cast<PlayerInfo*>(peer->data)->guildlast = "";
										static_cast<PlayerInfo*>(peer->data)->isinvited = false;
										static_cast<PlayerInfo*>(peer->data)->joinguild = true;
										updateInvis(peer);
										std::ifstream ifff("guilds/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->guild) + ".json");
										if (ifff.fail())
										{
											ifff.close();
											GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4Error: `oGuild does not exist! If you are seeing this message, please take a screenshot and send it to a developer!"));
											ENetPacket* packet = enet_packet_create(ps.data,
												ps.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet);
											delete ps.data;
											continue;
										}
										if (ifff.is_open())
										{
										}
										json j;
										ifff >> j; //load
										vector<string> gmlist;
										for (int i = 0; i < j["Member"].size(); i++)
										{
											gmlist.push_back(j["Member"][i]);
										}
										gmlist.push_back(static_cast<PlayerInfo*>(peer->data)->rawName);
										j["Member"] = gmlist; //edit
										std::ofstream o("guilds/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->guild) + ".json"); //save
										if (!o.is_open()) continue;
										o << j << std::endl;
										auto qstate = 0;
										if (conn == nullptr)
										{
											cout << "conn was nullptr" << endl;
											continue;
										}
										if (conn != nullptr)
										{
											stringstream ss;
											ss << "UPDATE PlayerDatabase SET guild = '" + static_cast<PlayerInfo*>(peer->data)->guild + "', joinguild = 'true' WHERE username = '" + static_cast<PlayerInfo*>(peer->data)->rawName + "'";
											auto query = ss.str();
											const auto q = query.c_str();
											if (mysql_query(conn, q))
											{
												cout << mysql_error(conn) << endl;
												


												enet_peer_disconnect_later(peer, 0);
												continue;
											}
										}
										ENetPeer* currentPeer;
										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
												continue;
											if (static_cast<PlayerInfo*>(currentPeer->data)->guild == static_cast<PlayerInfo*>(peer->data)->guild)
											{
												updateGuild(peer);
												updateGuild(currentPeer);
												GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5[GUILD ALERT] `2" + static_cast<PlayerInfo*>(peer->data)->displayName + " `ojoined the guild!"));
												ENetPacket* packet = enet_packet_create(p.data,
													p.len,
													ENET_PACKET_FLAG_RELIABLE);
												enet_peer_send(currentPeer, 0, packet);
												delete p.data;
												updateInvis(peer);
											}
										}
									}
								}
								catch (std::exception&)
								{
									SendConsole("joinguild Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_later(peer, 0);
								}
								catch (std::runtime_error&)
								{
									SendConsole("joinguild Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_later(peer, 0);
								}
								catch (...)
								{
									SendConsole("joinguild Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_later(peer, 0);
								}
							}
						}
						if (btn == "showguild") {						
							string onlinegmlist = "";
							string grole = "";
							int onlinecount = 0;
							string guildname = PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->guild);
							if (guildname != "")
							{
								try
								{
									std::ifstream ifff("guilds/" + guildname + ".json");
									if (ifff.fail())
									{
										ifff.close();
										static_cast<PlayerInfo*>(peer->data)->guild = "";
										continue;
									}
									json j;
									ifff >> j;
									int gfbg, gffg, guildlvl, guildxp;
									string gstatement, gleader;
									vector<string> gmembers;
									gfbg = j["backgroundflag"];
									gffg = j["foregroundflag"];
									gstatement = j["GuildStatement"].get<std::string>();
									gleader = j["Leader"].get<std::string>();
									guildlvl = j["GuildLevel"];
									guildxp = j["GuildExp"];
									for (int i = 0; i < j["Member"].size(); i++)
									{
										gmembers.push_back(j["Member"][i]);
									}
									static_cast<PlayerInfo*>(peer->data)->guildlevel = guildlvl;
									static_cast<PlayerInfo*>(peer->data)->guildexp = guildxp;
									static_cast<PlayerInfo*>(peer->data)->guildBg = gfbg;
									static_cast<PlayerInfo*>(peer->data)->guildFg = gffg;
									static_cast<PlayerInfo*>(peer->data)->guildStatement = gstatement;
									static_cast<PlayerInfo*>(peer->data)->guildLeader = gleader;
									static_cast<PlayerInfo*>(peer->data)->guildMembers = gmembers;
									ifff.close();
								}
								catch (std::exception&)
								{
									SendConsole("showguild Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_later(peer, 0);
								}
								catch (std::runtime_error&)
								{
									SendConsole("showguild Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_later(peer, 0);
								}
								catch (...)
								{
									SendConsole("showguild Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_later(peer, 0);
								}
							}
							ENetPeer* currentPeer;
							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;
								string name = static_cast<PlayerInfo*>(currentPeer->data)->rawName;
								if (find(static_cast<PlayerInfo*>(peer->data)->guildMembers.begin(), static_cast<PlayerInfo*>(peer->data)->guildMembers.end(), name) != static_cast<PlayerInfo*>(peer->data)->guildMembers.end())
								{
									if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == static_cast<PlayerInfo*>(peer->data)->guildLeader)
									{
										onlinegmlist += "\nadd_button|onlinegm_" + static_cast<PlayerInfo*>(currentPeer->data)->rawName + "|`2ONLINE: `o" + static_cast<PlayerInfo*>(currentPeer->data)->displayName + " `e(GL)``|0|0|";
										onlinecount++;
									}
									else
									{
										onlinegmlist += "\nadd_button|onlinegm_" + static_cast<PlayerInfo*>(currentPeer->data)->rawName + "|`2ONLINE: `o" + static_cast<PlayerInfo*>(currentPeer->data)->displayName + " " + grole + "``|0|0|";
										onlinecount++;
									}
								}
							}
							int guildsize = 15;
							if (static_cast<PlayerInfo*>(peer->data)->guildlevel == 2)
							{
								guildsize = 20;
							}
							else if (static_cast<PlayerInfo*>(peer->data)->guildlevel == 3)
							{
								guildsize = 25;
							}
							else if (static_cast<PlayerInfo*>(peer->data)->guildlevel == 4)
							{
								guildsize = 30;
							}
							else if (static_cast<PlayerInfo*>(peer->data)->guildlevel == 5)
							{
								guildsize = 35;
							}
							else if (static_cast<PlayerInfo*>(peer->data)->guildlevel == 6)
							{
								guildsize = 40;
							}
							else if (static_cast<PlayerInfo*>(peer->data)->guildlevel == 7)
							{
								guildsize = 45;
							}
							else if (static_cast<PlayerInfo*>(peer->data)->guildlevel == 8)
							{
								guildsize = 50;
							}
							if (static_cast<PlayerInfo*>(peer->data)->rawName == static_cast<PlayerInfo*>(peer->data)->guildLeader)
							{
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"),
									"set_default_color|`o\n\nadd_dual_layer_icon_label|big|`wGuild Home|left|" + std::to_string(static_cast<PlayerInfo*>(peer->data)->guildBg) + "|" + std::to_string(static_cast<PlayerInfo*>(peer->data)->guildFg) + "|1.0|0|\n\nadd_spacer|small|\nadd_textbox|" + static_cast<PlayerInfo*>(peer->data)->guildStatement + "``|\nadd_textbox|`oGuild size: " + to_string(guildsize) + " members|\nadd_textbox|`oGuild Level: " + std::to_string(static_cast<PlayerInfo*>(peer->data)->guildlevel) + "|\n\nadd_spacer|small|\nadd_button|guildoffline|`wShow offline too``|0|0|\nadd_button|goguildhome|`wGo to Guild Home``|0|0|\nadd_button|guildleveluper|`wUpgrade Guild``|0|0|\nadd_button|leavefromguild|`4Abandon Guild``|0|0|\n\nadd_spacer|small|\nadd_textbox|`5" + std::to_string(onlinecount) + " of " + std::to_string(static_cast<PlayerInfo*>(peer->data)->guildMembers.size()) + " `wGuild Members Online|" + onlinegmlist + "\n\nadd_spacer|small|\nadd_button||`wClose``|0|0|\nadd_quick_exit|"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
							else
							{
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"),
									"set_default_color|`o\n\nadd_dual_layer_icon_label|big|`wGuild Home|left|" + std::to_string(static_cast<PlayerInfo*>(peer->data)->guildBg) + "|" + std::to_string(static_cast<PlayerInfo*>(peer->data)->guildFg) + "|1.0|0|\n\nadd_spacer|small|\nadd_textbox|" + static_cast<PlayerInfo*>(peer->data)->guildStatement + "``|\nadd_textbox|`oGuild size: " + to_string(guildsize) + " members|\nadd_textbox|`oGuild Level: " + std::to_string(static_cast<PlayerInfo*>(peer->data)->guildlevel) + "|\n\nadd_spacer|small|\nadd_button|guildoffline|`wShow offline too``|0|0|\nadd_button|goguildhome|`wGo to Guild Home``|0|0|\nadd_button|leavefromguild|`4Leave from guild``|0|0|\n\nadd_spacer|small|\nadd_textbox|`5" + std::to_string(onlinecount) + " of " + std::to_string(static_cast<PlayerInfo*>(peer->data)->guildMembers.size()) + " `wGuild Members Online|" + onlinegmlist + "\n\nadd_spacer|small|\nadd_button||`wClose``|0|0|\nadd_quick_exit|"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
						}
						if (btn == "grewards")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->guild == "")
							{
								continue;
							}
							int gpoints = 0;
							ifstream guildstream1("guildrewards/guildpoints/" + static_cast<PlayerInfo*>(peer->data)->guild + ".txt");
							guildstream1 >> gpoints;
							guildstream1.close();
							Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`9Spend Guild Points``|left|752|\nadd_spacer|small|\nadd_textbox|`5Guild Rewards|\nadd_button_with_icon|pirmasitemas||staticBlueFrame|1432|\nadd_button_with_icon|antrasitemas||staticBlueFrame|1432|\nadd_button_with_icon|treciasitemas||staticBlueFrame|1432|\nadd_button_with_icon|ketvirtasitemas||staticBlueFrame|1432|\nadd_button_with_icon|penktasitemas||staticBlueFrame|1432|\nadd_button_with_icon||END_LIST|noflags|0|0||\nadd_textbox|`5Personal Guild Rewards|\nadd_button_with_icon|pirmasitemasp||staticBlueFrame|10022|\nadd_button_with_icon|antrasitemasp||staticBlueFrame|1432|\nadd_button_with_icon|treciasitemasp||staticBlueFrame|1432|\nadd_button_with_icon|ketvirtasitemasp||staticBlueFrame|1432|\nadd_button_with_icon|penktasitemasp||staticBlueFrame|1432|\nadd_quick_exit|");
						}
						if (btn == "gcontribution")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->guild == "")
							{
								continue;
							}
							int gpoints = 0;
							try
							{
								ifstream guildstream1("guildrewards/guildpoints/" + static_cast<PlayerInfo*>(peer->data)->guild + ".txt");
								guildstream1 >> gpoints;
								guildstream1.close();
							}
							catch (std::exception& e)
							{
								SendConsole("Button (gcontribution) Failed to Execute!", "ERROR");
								std::cerr << e.what() << std::endl;
							}
							try
							{
								vector<string> allMembers = static_cast<PlayerInfo*>(peer->data)->guildMembers;
								vector<string> names;
								vector<int> points;
								int point = 0;
								int kiekYra = 0;
								for (int i = 0; i < allMembers.size(); i++)
								{
									if (std::experimental::filesystem::exists("guildrewards/contribution/" + static_cast<PlayerInfo*>(peer->data)->guild + "/" + allMembers[i] + ".txt"))
									{
										ifstream get("guildrewards/contribution/" + static_cast<PlayerInfo*>(peer->data)->guild + "/" + allMembers[i] + ".txt");
										get >> point;
										get.close();
										names.push_back(allMembers[i]);
										points.push_back(point);
										kiekYra++;
									}
								}
								for (int i = 0; i < kiekYra; i++)
								{
									for (int j = i + 1; j < kiekYra; j++)
									{
										if (points[j] > points[i])
										{
											swap(points[j], points[i]);
											swap(names[j], names[i]);
										}
									}
								}
								string allList = "";
								int topCount = 0;
								for (int i = 0; i < kiekYra; i++)
								{
									if (names[i] != "")
									{
										topCount++;
										if (topCount == 1)
										{
											allList += "|\n\nadd_label_with_icon|small|`2" + names[i] + " `9Contribution: `^" + std::to_string(points[i]) + " `9Points.|left|6138||";
										}
										else if (topCount == 2)
										{
											allList += "|\n\nadd_label_with_icon|small|`2" + names[i] + " `9Contribution: `^" + std::to_string(points[i]) + " `9Points.|left|6136||";
										}
										else if (topCount == 3)
										{
											allList += "|\n\nadd_label_with_icon|small|`2" + names[i] + " `9Contribution: `^" + std::to_string(points[i]) + " `9Points.|left|6134||";
										}
										else
										{
											allList += "|\n\nadd_label_with_icon|small|`2" + names[i] + " `oContribution: `^" + std::to_string(points[i]) + " `9Points.|left|7970||";
										}
									}
								}
								Player::OnDialogRequest(peer, "set_default_color|\nadd_label_with_icon|big|`9Guild Members Contribution``|left|7340|\nadd_label|small|`5Your guild currently have: `^" + std::to_string(gpoints) + " `5Points.|left|4||\nadd_spacer|small|" + allList + "\nadd_quick_exit|");
							}
							catch (...)
							{
								SendConsole("Button (gcontribution) Failed to Execute!", "ERROR");
							}
						}
						if (btn == "guildleveluper")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->guild == "")
							{
								continue;
							}
							int needdls = static_cast<PlayerInfo*>(peer->data)->guildlevel * 30;
							if (static_cast<PlayerInfo*>(peer->data)->guildlevel <= 6)
							{
								Player::OnDialogRequest(peer, "set_default_color|`o\nadd_dual_layer_icon_label|big|`wUpgrade Your Guild|left|" + std::to_string(static_cast<PlayerInfo*>(peer->data)->guildBg) + "|" + std::to_string(static_cast<PlayerInfo*>(peer->data)->guildFg) + "|1.0|0|\n\nadd_spacer|small|\nadd_textbox|`5Upgrading your guild unlocks new features such as increased member slots and various boosts, buffs!|\nadd_textbox|`5Your current guild level: `^" + to_string(static_cast<PlayerInfo*>(peer->data)->guildlevel) + "``|\nadd_spacer|small|\nadd_textbox|`5To `^Upgrade `5Your `9Guild `5You Need:|\nadd_label_with_icon|small|`2" + std::to_string(needdls) + " `!Diamond Locks``|left|1796|\nadd_spacer|small|\nadd_button|upgradeguildnow|`9Upgrade!``|0|0||\nadd_button||`wClose``|0|0|\nadd_quick_exit|");
							}
							else
							{
								Player::OnTextOverlay(peer, "your guild at max level!");
							}
						}
						if (btn == "upgradeguildnow")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->guild == "")
							{
								continue;
							}
							int needdls = static_cast<PlayerInfo*>(peer->data)->guildlevel * 30;
							bool iscontains = false;
							SearchInventoryItem(peer, 1796, needdls, iscontains);
							if (!iscontains)
							{
								Player::OnTextOverlay(peer, "`9You `@Don't `9Have enought `eDiamond Locks`9!");
							}
							else
							{
								RemoveInventoryItem(1796, needdls, peer, true);
								int guildlevelnow = static_cast<PlayerInfo*>(peer->data)->guildlevel;
								guildlevelnow += 1;
								if (guildlevelnow == 7)
								{
									Player::OnTextOverlay(peer, "`9Your guild is at `2max level`9!");
									continue;
								}
								static_cast<PlayerInfo*>(peer->data)->guildlevel = guildlevelnow;
								Player::OnTextOverlay(peer, "`0You have `9Upgraded your `^Guild `0To `9Level `2" + std::to_string(guildlevelnow) + "`0!");
								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (static_cast<PlayerInfo*>(currentPeer->data)->guild == static_cast<PlayerInfo*>(peer->data)->guild)
									{
										try
										{
											std::ifstream ifff("guilds/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->guild) + ".json");
											if (ifff.fail())
											{
												ifff.close();
												GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4Error: `oGuild does not exist! If you are seeing this message, please take a screenshot and send it to a developer!"));
												ENetPacket* packet = enet_packet_create(ps.data,
													ps.len,
													ENET_PACKET_FLAG_RELIABLE);
												enet_peer_send(peer, 0, packet);
												delete ps.data;
												continue;
											}
											if (ifff.is_open())
											{
											}
											json j;
											ifff >> j; //load
											j["GuildLevel"] = guildlevelnow; //edit
											std::ofstream o("guilds/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->guild) + ".json"); //save
											if (!o.is_open()) continue;
											o << j << std::endl;
											updateGuild(currentPeer);
											Player::OnConsoleMessage(currentPeer, "`5[GUILD ALERT] `2Your guild have been upgraded to level " + std::to_string(guildlevelnow) + "!");
										}
										catch (std::exception&)
										{
											SendConsole("upgradeguildnow Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_later(peer, 0);
										}
										catch (std::runtime_error&)
										{
											SendConsole("upgradeguildnow Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_later(peer, 0);
										}
										catch (...)
										{
											SendConsole("upgradeguildnow Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
											enet_peer_disconnect_later(peer, 0);
										}
									}
								}
							}
						}
						if (btn == "leavefromguild")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->rawName == static_cast<PlayerInfo*>(peer->data)->guildLeader)
							{
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|\nadd_label_with_icon|big|`8Are you sure?``|left|6204|\nadd_spacer|small|\nadd_label|small|\nadd_textbox|`oAfter `4Abandon `ofrom the guild, all guild's members will be `4kicked out `oand the guild will be `4destroyed`o!|left|8|\nadd_spacer|small|\nadd_button|confirmguildleaderleave|`4Yes, Abandon!|0|0|\nadd_spacer|0|0|\n\nadd_quick_exit|\nnend_dialog|gazette||OK|"));
								ENetPacket* packet = enet_packet_create(p.data,
									p.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else
							{
								try
								{
									std::ifstream ifff("guilds/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->guild) + ".json");
									if (ifff.fail())
									{
										ifff.close();
										GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4Error: `oGuild does not exist! If you are seeing this message, please take a screenshot and send it to a developer!"));
										ENetPacket* packet = enet_packet_create(ps.data,
											ps.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete ps.data;
										continue;
									}
									if (ifff.is_open())
									{
									}
									remove(("guildrewards/contribution/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->guild) + "/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt").c_str());
									json j;
									ifff >> j; //load
									vector<string> gmlist;
									for (int i = 0; i < j["Member"].size(); i++)
									{
										gmlist.push_back(j["Member"][i]);
									}
									gmlist.erase(std::remove(gmlist.begin(), gmlist.end(), static_cast<PlayerInfo*>(peer->data)->rawName), gmlist.end());
									j["Member"] = gmlist; //edit
									std::ofstream o("guilds/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->guild) + ".json"); //save
									if (!o.is_open()) continue;
									o << j << std::endl;
									ENetPeer* currentPeer;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
											continue;
										if (static_cast<PlayerInfo*>(currentPeer->data)->guild == static_cast<PlayerInfo*>(peer->data)->guild)
										{
											updateGuild(currentPeer);
											updateInvis(currentPeer);
										}
									}
									static_cast<PlayerInfo*>(peer->data)->guildBg = 0;
									static_cast<PlayerInfo*>(peer->data)->guildFg = 0;
									static_cast<PlayerInfo*>(peer->data)->guildLeader = "";
									static_cast<PlayerInfo*>(peer->data)->guild = "";
									static_cast<PlayerInfo*>(peer->data)->guildStatement = "";
									static_cast<PlayerInfo*>(peer->data)->guildlast = "";
									static_cast<PlayerInfo*>(peer->data)->lastgm = "";
									static_cast<PlayerInfo*>(peer->data)->lastgmname = "";
									static_cast<PlayerInfo*>(peer->data)->joinguild = false;
									static_cast<PlayerInfo*>(peer->data)->lastgmworld = "";
									static_cast<PlayerInfo*>(peer->data)->guildMembers.clear();
									updateInvis(peer);
									auto qstate = 0;
									if (conn == nullptr)
									{
										cout << "conn was nullptr" << endl;
										continue;
									}
									if (conn != nullptr)
									{
										stringstream ss;
										ss << "UPDATE PlayerDatabase SET guild = '', joinguild = 'false' WHERE username = '" + static_cast<PlayerInfo*>(peer->data)->rawName + "'";
										auto query = ss.str();
										const auto q = query.c_str();
										if (mysql_query(conn, q))
										{
											cout << mysql_error(conn) << endl;
											


											enet_peer_disconnect_later(peer, 0);
											continue;
										}
									}
								}
								catch (std::exception&)
								{
									SendConsole("leavefromguild Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_later(peer, 0);
								}
								catch (std::runtime_error&)
								{
									SendConsole("leavefromguild Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_later(peer, 0);
								}
								catch (...)
								{
									SendConsole("leavefromguild Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_later(peer, 0);
								}
							}
						}
						if (btn == "confirmguildleaderleave")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							try
							{
								std::ifstream ifff("guilds/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->guild) + ".json");
								if (ifff.fail())
								{
									ifff.close();
									GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4Error: `oGuild does not exist! If you are seeing this message, please take a screenshot and send it to a developer!"));
									ENetPacket* packet = enet_packet_create(ps.data,
										ps.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete ps.data;
									continue;
								}
								json j;
								ifff >> j; //load
								ifff.close();
								vector<string> gmlist;
								for (int i = 0; i < j["Member"].size(); i++)
								{
									gmlist.push_back(j["Member"][i]);
								}
								const int result = remove(("guilds/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->guild) + ".json").c_str());
								remove(("guildrewards/guildpoints/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->guild) + ".txt").c_str());
								namespace fs = std::experimental::filesystem;
								fs::remove_all("guildrewards/contribution/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->guild));
								if (result == 0)
								{
								}
								else
								{
									SendConsole("Button (confirmguildleaderleave) Failed to execute!", "ERROR");
								}
								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (find(gmlist.begin(), gmlist.end(), static_cast<PlayerInfo*>(currentPeer->data)->rawName) != gmlist.end())
									{
										static_cast<PlayerInfo*>(currentPeer->data)->guildBg = 0;
										static_cast<PlayerInfo*>(currentPeer->data)->guildFg = 0;
										static_cast<PlayerInfo*>(currentPeer->data)->guildLeader = "";
										static_cast<PlayerInfo*>(currentPeer->data)->guild = "";
										static_cast<PlayerInfo*>(currentPeer->data)->guildStatement = "";
										//static_cast<PlayerInfo*>(currentPeer->data)->guildRole = 0;
										static_cast<PlayerInfo*>(currentPeer->data)->guildlast = "";
										static_cast<PlayerInfo*>(currentPeer->data)->lastgm = "";
										static_cast<PlayerInfo*>(currentPeer->data)->lastgmname = "";
										static_cast<PlayerInfo*>(currentPeer->data)->joinguild = false;
										static_cast<PlayerInfo*>(currentPeer->data)->lastgmworld = "";
										static_cast<PlayerInfo*>(currentPeer->data)->guildMembers.clear();
										updateInvis(currentPeer);
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5[GUILD ALERT] `4Unfortunately, `obut guild's leader `4abandoned `ofrom the guild and you were `4kicked out`o."));
										ENetPacket* packet = enet_packet_create(p.data,
											p.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeer, 0, packet);
										delete p.data;
									}
								}
								for (int i = 0; i < gmlist.size(); i++)
								{
									auto qstate = 0;
									if (conn == nullptr)
									{
										cout << "conn was nullptr" << endl;
										continue;
									}
									if (conn != nullptr)
									{
										stringstream ss;
										ss << "UPDATE PlayerDatabase SET guild = '', joinguild = 'false' WHERE username = '" + gmlist[i] + "'";
										auto query = ss.str();
										const auto q = query.c_str();
										if (mysql_query(conn, q))
										{
											cout << mysql_error(conn) << endl;
											


											enet_peer_disconnect_later(peer, 0);
											continue;
										}
									}
								}
							}
							catch (std::exception&)
							{
								SendConsole("confirmguildleaderleave Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
								enet_peer_disconnect_later(peer, 0);
							}
							catch (std::runtime_error&)
							{
								SendConsole("confirmguildleaderleave Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
								enet_peer_disconnect_later(peer, 0);
							}
							catch (...)
							{
								SendConsole("confirmguildleaderleave Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
								enet_peer_disconnect_later(peer, 0);
							}
						}
						if (btn == "guildoffline")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							string onlinegmlist = "";
							string offname, offlinegm;
							string grole = "";
							int onlinecount = 0;
							int totalcount = static_cast<PlayerInfo*>(peer->data)->guildMembers.size();
							string gstatement = static_cast<PlayerInfo*>(peer->data)->guildLeader;
							string bg = std::to_string(static_cast<PlayerInfo*>(peer->data)->guildBg);
							string fg = std::to_string(static_cast<PlayerInfo*>(peer->data)->guildFg);
							string guildname = static_cast<PlayerInfo*>(peer->data)->guild;
							string guildleader = static_cast<PlayerInfo*>(peer->data)->guildLeader;
							string guildlvl = "0";
							string guildexp = "0";
							ENetPeer* currentPeer;
							vector<string> offlineguild = static_cast<PlayerInfo*>(peer->data)->guildMembers;
							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;
								string name = static_cast<PlayerInfo*>(currentPeer->data)->rawName;
								if (find(static_cast<PlayerInfo*>(peer->data)->guildMembers.begin(), static_cast<PlayerInfo*>(peer->data)->guildMembers.end(), name) != static_cast<PlayerInfo*>(peer->data)->guildMembers.end())
								{
									if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == static_cast<PlayerInfo*>(peer->data)->guildLeader)
									{
										onlinegmlist += "\nadd_button|onlinegm_" + static_cast<PlayerInfo*>(currentPeer->data)->rawName + "|`2ONLINE: `o" + static_cast<PlayerInfo*>(currentPeer->data)->displayName + " `e(GL)``|0|0|";
										onlinecount++;
									}
									else
									{
										onlinegmlist += "\nadd_button|onlinegm_" + static_cast<PlayerInfo*>(currentPeer->data)->rawName + "|`2ONLINE: `o" + static_cast<PlayerInfo*>(currentPeer->data)->displayName + " " + grole + "``|0|0|";
										onlinecount++;
										offlineguild.erase(std::remove(offlineguild.begin(), offlineguild.end(), name), offlineguild.end());
									}
								}
							}
							for (std::vector<string>::const_iterator i = offlineguild.begin(); i != offlineguild.end(); ++i)
							{
								offname = *i;
								offlinegm += "\nadd_button|offlinegm_" + offname + "|`4OFFLINE: `o" + offname + "``|0|0|";
							}
							int guildsize = 15;
							if (static_cast<PlayerInfo*>(peer->data)->guildlevel == 2)
							{
								guildsize = 20;
							}
							else if (static_cast<PlayerInfo*>(peer->data)->guildlevel == 3)
							{
								guildsize = 25;
							}
							else if (static_cast<PlayerInfo*>(peer->data)->guildlevel == 4)
							{
								guildsize = 30;
							}
							else if (static_cast<PlayerInfo*>(peer->data)->guildlevel == 5)
							{
								guildsize = 35;
							}
							else if (static_cast<PlayerInfo*>(peer->data)->guildlevel == 6)
							{
								guildsize = 40;
							}
							else if (static_cast<PlayerInfo*>(peer->data)->guildlevel == 7)
							{
								guildsize = 45;
							}
							else if (static_cast<PlayerInfo*>(peer->data)->guildlevel == 8)
							{
								guildsize = 50;
							}
							GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\nadd_dual_layer_icon_label|big|`wGuild Home|left|" + std::to_string(static_cast<PlayerInfo*>(peer->data)->guildBg) + "|" + std::to_string(static_cast<PlayerInfo*>(peer->data)->guildFg) + "|1.0|0|\n\nadd_spacer|small|\nadd_textbox|" + static_cast<PlayerInfo*>(peer->data)->guildStatement + "``|\nadd_textbox|`oGuild size: " + std::to_string(guildsize) + " members|\nadd_textbox|`oGuild Level: " + std::to_string(static_cast<PlayerInfo*>(peer->data)->guildlevel) + "|\n\nadd_spacer|small|\nadd_button|goguildhome|`wGo to Guild Home``|0|0|\nadd_button|leavefromguild|`4Leave from guild``|0|0|\n\nadd_spacer|small|\nadd_textbox|`5" + std::to_string(onlinecount) + " of " + std::to_string(static_cast<PlayerInfo*>(peer->data)->guildMembers.size()) + " `wGuild Members Online|" + offlinegm + "\n\nadd_spacer|small|\nadd_button||`wClose``|0|0|\nadd_quick_exit|"));
							ENetPacket* packet2 = enet_packet_create(p2.data,
								p2.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet2);
							delete p2.data;
						}
						if (btn == "goguildhome")
						{
							continue;
							/*if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT") {
								continue;
							}
							bool guildexist = std::experimental::filesystem::exists("guilds/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->guild) + ".json");
							if (guildexist) {
								string gworld;
								string guildName = static_cast<PlayerInfo*>(peer->data)->guild;
								std::ifstream ifs("guilds/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->guild) + ".json");
								if (ifs.is_open()) {
									json j;
									ifs >> j;
									gworld = j["GuildWorld"].get<std::string>();
								}
								sendPlayerLeave(peer);
								joinWorld(peer, gworld, 0, 0);
							}
							else {
								Player::OnTextOverlay(peer, "Errorx434");
							}*/
						}
						if (btn == "createguildinfo")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`wGrow Guilds|left|242|\nadd_label|small|`9Welcome to Grow Guilds where you can create a Guild! With a Guild you can level up the Guild to add more members!``|left|4|\n\nadd_spacer|small|\nadd_textbox|`9You will be charged `6250,000 `9Gems!``|\nadd_spacer|small|\nadd_button|createguild|`oCreate a Guild``|0|0|\nend_dialog||Close||\nadd_quick_exit|"));
							ENetPacket* packet2 = enet_packet_create(p2.data,
								p2.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet2);
							delete p2.data;
						}
						if (btn == "createguild")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`wGrow Guild Creation``|left|242|\nadd_spacer|small|\nadd_text_input|gname|Guild Name: ||20|\nadd_text_input|gstatement|Guild Statement: ||100|\nadd_text_input|ggcflagbg|`oGuild Flag Background ID:``||5|\nadd_text_input|ggcflagfg|`oGuild Flag Foreground ID:``||5|\nadd_spacer|small|\nadd_textbox|`oConfirm your guild settings by selecting `2Create Guild `obelow to create your guild.|\nadd_spacer|small|\nadd_textbox|`8Remember`o: A guild can only be created in a world owned by you and locked with a `5World Lock`o!|\nadd_spacer|small|\nadd_textbox|`4Warning! `oThe guild name cannot be changed once you have confirmed the guild settings!|\nadd_quick_exit|\nadd_spacer|small|\nend_dialog|guildconfirm|Cancel|Create Guild|\n"));
							ENetPacket* packet2 = enet_packet_create(p2.data,
								p2.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet2);
							delete p2.data;
						}
						if (btn.substr(0, 10) == "offlinegm_")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							static_cast<PlayerInfo*>(peer->data)->lastgm = btn.substr(10, cch.length() - 10 - 1);
							if (btn.substr(10, cch.length() - 10 - 1) == static_cast<PlayerInfo*>(peer->data)->guildLeader)
							{
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_dual_layer_icon_label|big|`w" + static_cast<PlayerInfo*>(peer->data)->lastgm + "|left|" + std::to_string(static_cast<PlayerInfo*>(peer->data)->guildBg) + "|" + std::to_string(static_cast<PlayerInfo*>(peer->data)->guildFg) + "|1.0|0|\n\nadd_spacer|small|\nadd_textbox|`oRank: Leader|\nadd_spacer|small|\nadd_textbox|`o" + static_cast<PlayerInfo*>(peer->data)->lastgm + " is `4offline`o.``|\nadd_spacer|small|\nadd_button|guildoffline|`oBack``|0|0|\nadd_quick_exit|"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
							else
							{
								if (static_cast<PlayerInfo*>(peer->data)->rawName == static_cast<PlayerInfo*>(peer->data)->guildLeader)
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_dual_layer_icon_label|big|`w" + static_cast<PlayerInfo*>(peer->data)->lastgm + "|left|" + std::to_string(static_cast<PlayerInfo*>(peer->data)->guildBg) + "|" + std::to_string(static_cast<PlayerInfo*>(peer->data)->guildFg) + "|1.0|0|\n\nadd_spacer|small|\nadd_textbox|`oRank: Member|\nadd_spacer|small|\nadd_textbox|`o" + static_cast<PlayerInfo*>(peer->data)->lastgm + " is `4offline`o.``|\nadd_spacer|small|\nadd_button|removegmoffline|`oKick from the guild``|0|0|\nadd_button|guildoffline|`oBack``|0|0|\nadd_quick_exit|"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
								else
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_dual_layer_icon_label|big|`w" + static_cast<PlayerInfo*>(peer->data)->lastgm + "|left|" + std::to_string(static_cast<PlayerInfo*>(peer->data)->guildBg) + "|" + std::to_string(static_cast<PlayerInfo*>(peer->data)->guildFg) + "|1.0|0|\n\nadd_spacer|small|\nadd_textbox|`oRank: Member|\nadd_spacer|small|\nadd_textbox|`o" + static_cast<PlayerInfo*>(peer->data)->lastgm + " is `4offline`o.``|\nadd_spacer|small|\nadd_button|guildoffline|`oBack``|0|0|\nadd_quick_exit|"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
							}
						}
						if (btn == "removegmoffline")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							ENetPeer* currentPeer;
							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;
								if (static_cast<PlayerInfo*>(currentPeer->data)->guild == static_cast<PlayerInfo*>(peer->data)->guild)
								{
									try
									{
										std::ifstream ifff("guilds/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->guild) + ".json");
										if (ifff.fail())
										{
											ifff.close();
											GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4Error: `oGuild does not exist! If you are seeing this message, please take a screenshot and send it to a developer!"));
											ENetPacket* packet = enet_packet_create(ps.data,
												ps.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet);
											delete ps.data;
											continue;
										}
										if (ifff.is_open())
										{
										}
										json j;
										ifff >> j; //load
										vector<string> gmlist;
										for (int i = 0; i < j["Member"].size(); i++)
										{
											gmlist.push_back(j["Member"][i]);
										}
										gmlist.erase(std::remove(gmlist.begin(), gmlist.end(), static_cast<PlayerInfo*>(peer->data)->lastgm), gmlist.end());
										j["Member"] = gmlist; //edit
										std::ofstream o("guilds/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->guild) + ".json"); //save
										if (!o.is_open()) continue;
										o << j << std::endl;
										auto qstate = 0;
										if (conn == nullptr)
										{
											cout << "conn was nullptr" << endl;
											continue;
										}
										if (conn != nullptr)
										{
											stringstream ss;
											ss << "UPDATE PlayerDatabase SET guild = '', joinguild = 'false' WHERE username = '" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->lastgm) + "'";
											auto query = ss.str();
											const auto q = query.c_str();
											if (mysql_query(conn, q))
											{
												cout << mysql_error(conn) << endl;
												


												enet_peer_disconnect_later(peer, 0);
												continue;
											}
										}
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5[GUILD ALERT] `2" + static_cast<PlayerInfo*>(peer->data)->lastgm + "`o has been kicked from the guild!"));
										ENetPacket* packet = enet_packet_create(p.data,
											p.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeer, 0, packet);
										delete p.data;
									}
									catch (std::exception&)
									{
										SendConsole("removegmoffline Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_later(peer, 0);
									}
									catch (std::runtime_error&)
									{
										SendConsole("removegmoffline Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_later(peer, 0);
									}
									catch (...)
									{
										SendConsole("removegmoffline Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_later(peer, 0);
									}
								}
							}
							GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`4Guild Member removed``|left|1366|\n\nadd_spacer|small|\nadd_textbox|`o" + static_cast<PlayerInfo*>(peer->data)->lastgm + " is no longer in the guild.``|\n\nadd_spacer|small|\nadd_button|guildportalbutton|`oOK``|0|0|\nadd_quick_exit|"));
							ENetPacket* packet2 = enet_packet_create(p2.data,
								p2.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet2);
							delete p2.data;
						}
						if (btn == "removegmonline")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							ENetPeer* currentPeer;
							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;
								if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == static_cast<PlayerInfo*>(peer->data)->lastgm)
								{
									try
									{
										std::ifstream ifff("guilds/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->guild) + ".json");
										if (ifff.fail())
										{
											ifff.close();
											GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4Error: `oGuild does not exist! If you are seeing this message, please take a screenshot and send it to a developer!"));
											ENetPacket* packet = enet_packet_create(ps.data,
												ps.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet);
											delete ps.data;
											continue;
										}
										if (ifff.is_open())
										{
										}
										json j;
										ifff >> j; //load
										vector<string> gmlist;
										for (int i = 0; i < j["Member"].size(); i++)
										{
											gmlist.push_back(j["Member"][i]);
										}
										gmlist.erase(std::remove(gmlist.begin(), gmlist.end(), static_cast<PlayerInfo*>(peer->data)->lastgm), gmlist.end());
										j["Member"] = gmlist; //edit
										std::ofstream o("guilds/" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->guild) + ".json"); //save
										if (!o.is_open()) continue;
										o << j << std::endl;
										static_cast<PlayerInfo*>(currentPeer->data)->guildBg = 0;
										static_cast<PlayerInfo*>(currentPeer->data)->guildFg = 0;
										static_cast<PlayerInfo*>(currentPeer->data)->guildLeader = "";
										static_cast<PlayerInfo*>(currentPeer->data)->guild = "";
										static_cast<PlayerInfo*>(currentPeer->data)->guildStatement = "";
										//static_cast<PlayerInfo*>(currentPeer->data)->guildRole = 0;
										static_cast<PlayerInfo*>(currentPeer->data)->guildlast = "";
										static_cast<PlayerInfo*>(currentPeer->data)->lastgm = "";
										static_cast<PlayerInfo*>(currentPeer->data)->lastgmname = "";
										static_cast<PlayerInfo*>(currentPeer->data)->joinguild = false;
										static_cast<PlayerInfo*>(currentPeer->data)->lastgmworld = "";
										static_cast<PlayerInfo*>(currentPeer->data)->guildMembers.clear();
										updateInvis(currentPeer);
										updateInvis(peer);
										auto qstate = 0;
										if (conn == nullptr)
										{
											cout << "conn was nullptr" << endl;
											continue;
										}
										if (conn != nullptr)
										{
											stringstream ss;
											ss << "UPDATE PlayerDatabase SET guild = '', joinguild = 'false' WHERE username = '" + static_cast<PlayerInfo*>(currentPeer->data)->rawName + "'";
											auto query = ss.str();
											const auto q = query.c_str();
											if (mysql_query(conn, q))
											{
												cout << mysql_error(conn) << endl;
												


												enet_peer_disconnect_later(peer, 0);
												continue;
											}
										}
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5[GUILD ALERT] `oYou have been kicked from the guild by `2" + static_cast<PlayerInfo*>(peer->data)->displayName + "`o."));
										ENetPacket* packet = enet_packet_create(p.data,
											p.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeer, 0, packet);
										delete p.data;
									}
									catch (std::exception&)
									{
										SendConsole("removegmonline Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_later(peer, 0);
									}
									catch (std::runtime_error&)
									{
										SendConsole("removegmonline Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_later(peer, 0);
									}
									catch (...)
									{
										SendConsole("removegmonline Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
										enet_peer_disconnect_later(peer, 0);
									}
								}
								if (static_cast<PlayerInfo*>(currentPeer->data)->guild == static_cast<PlayerInfo*>(peer->data)->guild)
								{
									updateGuild(currentPeer);
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`5[GUILD ALERT] `2" + static_cast<PlayerInfo*>(peer->data)->lastgmname + "`o has been kicked from the guild!"));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(currentPeer, 0, packet);
									delete p.data;
								}
							}
							GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`4Guild Member removed``|left|1366|\n\nadd_spacer|small|\nadd_textbox|`o" + static_cast<PlayerInfo*>(peer->data)->lastgmname + " is no longer in the guild.``|\n\nadd_spacer|small|\nadd_button|guildportalbutton|`oOK``|0|0|\nadd_quick_exit|"));
							ENetPacket* packet2 = enet_packet_create(p2.data,
								p2.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet2);
							delete p2.data;
						}
						if (btn == "confirmcreateguild")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							std::ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
							std::string content((std::istreambuf_iterator<char>(ifsz)),
								(std::istreambuf_iterator<char>()));
							int b = atoi(content.c_str());
							if (b > 249000)
							{
								int gemcalc10k = b - 250000;
								ofstream myfile2;
								myfile2.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
								myfile2 << std::to_string(gemcalc10k);
								myfile2.close();
								std::ifstream ifszi("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
								std::string contentx((std::istreambuf_iterator<char>(ifszi)),
									(std::istreambuf_iterator<char>()));
								int updgem = atoi(contentx.c_str());
								GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
								ENetPacket* packetpp = enet_packet_create(pp.data,
									pp.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packetpp);
								delete pp.data;
								GamePacket pto = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "You created guild!"));
								ENetPacket* packetto = enet_packet_create(pto.data,
									pto.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packetto);
								delete pto.data;
								string guildName = static_cast<PlayerInfo*>(peer->data)->createGuildName;
								string guildStatement = static_cast<PlayerInfo*>(peer->data)->createGuildStatement;
								string fixedguildName = PlayerDB::getProperName(guildName);
								string guildFlagbg = static_cast<PlayerInfo*>(peer->data)->createGuildFlagBg;
								string guildFlagfg = static_cast<PlayerInfo*>(peer->data)->createGuildFlagFg;
								try
								{
									std::ofstream o("guilds/" + fixedguildName + ".json");
									if (!o.is_open()) continue;
									json j;
									vector<string> test1s;
									vector<string> test2s;
									static_cast<PlayerInfo*>(peer->data)->guildMembers.push_back(static_cast<PlayerInfo*>(peer->data)->rawName);
									j["GuildName"] = static_cast<PlayerInfo*>(peer->data)->createGuildName;
									j["GuildRawName"] = fixedguildName;
									j["GuildStatement"] = static_cast<PlayerInfo*>(peer->data)->createGuildStatement;
									j["Leader"] = static_cast<PlayerInfo*>(peer->data)->rawName;
									j["Co-Leader"] = test1s;
									j["Elder-Leader"] = test2s;
									j["Member"] = static_cast<PlayerInfo*>(peer->data)->guildMembers;
									j["GuildLevel"] = 1;
									j["GuildExp"] = 0;
									j["GuildWorld"] = static_cast<PlayerInfo*>(peer->data)->currentWorld;
									j["backgroundflag"] = atoi(static_cast<PlayerInfo*>(peer->data)->createGuildFlagBg.c_str());
									j["foregroundflag"] = atoi(static_cast<PlayerInfo*>(peer->data)->createGuildFlagFg.c_str());
									o << j << std::endl;
								}
								catch (std::exception&)
								{
									SendConsole("confirmcreateguild Critical error details: rawName(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_later(peer, 0);
								}
								catch (std::runtime_error&)
								{
									SendConsole("confirmcreateguild Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_later(peer, 0);
								}
								catch (...)
								{
									SendConsole("confirmcreateguild Critical error details: name(" + static_cast<PlayerInfo*>(peer->data)->rawName + ")", "ERROR");
									enet_peer_disconnect_later(peer, 0);
								}
								auto qstate = 0;
								if (conn == nullptr)
								{
									cout << "conn was nullptr" << endl;
									continue;
								}
								if (conn != nullptr)
								{
									stringstream ss;
									ss << "UPDATE PlayerDatabase SET guild = '" + guildName + "', joinguild = 'true' WHERE username = '" + static_cast<PlayerInfo*>(peer->data)->rawName + "'";
									auto query = ss.str();
									const auto q = query.c_str();
									if (mysql_query(conn, q))
									{
										cout << mysql_error(conn) << endl;
										


										enet_peer_disconnect_later(peer, 0);
										continue;
									}
								}
								static_cast<PlayerInfo*>(peer->data)->guild = guildName;
								static_cast<PlayerInfo*>(peer->data)->joinguild = true;
								static_cast<PlayerInfo*>(peer->data)->guildFg = atoi(static_cast<PlayerInfo*>(peer->data)->createGuildFlagFg.c_str());
								static_cast<PlayerInfo*>(peer->data)->guildBg = atoi(static_cast<PlayerInfo*>(peer->data)->createGuildFlagBg.c_str());
								updateInvis(peer);
							}
							else
							{
								GamePacket pto = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "You don't have enough gems."));
								ENetPacket* packetto = enet_packet_create(pto.data,
									pto.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packetto);
								delete pto.data;
							}
						}
						if (isFindDialog && btn.substr(0, 4) == "tool")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							if (btn.substr(4, btn.length() - 4).size() > 5 || btn.substr(4, btn.length() - 4).size() <= 0)
							{
								continue;
							}
							int id = atoi(btn.substr(4, btn.length() - 4).c_str());
							if (id > maxItems || id <= 0)
							{
								continue;
							}
							size_t invsize = static_cast<PlayerInfo*>(peer->data)->currentInventorySize;
							if (getItemDef(id).name.find("Mooncake") != string::npos || getItemDef(id).name.find("Harvest") != string::npos && id != 1830 || getItemDef(id).name.find("Autumn") != string::npos || id == 1056 || id == 1804 || getItemDef(id).blockType == BlockTypes::COMPONENT || getItemDef(id).properties & Property_Chemical || id == 6920 || id == 6922 || id == 1874 || id == 3402 || id == 1876 || id == 1904 || id == 1932 || id == 1900 || id == 1986 || id == 1996 || id == 2970 || id == 3140 || id == 3174 || id == 6028 || id == 6846 || id == 8962 || id == 2408 || id == 4428 || id == 5086 || id == 9240 || id == 9306 || id == 9290 || id == 7328 || id == 9416 || id == 10386 || id == 9410 || id == 1458 || id == 9408 || id == 9360 || id == 6866 || id == 6868 || id == 6870 || id == 6872 || id == 6874 || id == 6876 || id == 6878 || id == 2480 || id == 8452 || id == 5132 || id == 7166 || id == 5126 || id == 5128 || id == 5130 || id == 5144 || id == 5146 || id == 5148 || id == 5150 || id == 5162 || id == 5164 || id == 5166 || id == 5168 || id == 5180 || id == 5182 || id == 5184 || id == 5186 || id == 7168 || id == 7170 || id == 7172 || id == 7174 || id == 8834 || id == 7912 || id == 9212 || id == 5134 || id == 5152 || id == 5170 || id == 5188 || id == 980 || id == 9448 || id == 9310 || id == 10034 || id == 10036 || id == 8470 || id == 8286 || id == 6026 || id == 1970 || id == 1784 || id == 9356 || id == 10022 || id == 902 || id == 10032 || id == 834 || id == 6 || id == 5640 || id == 9492 || id == 1782 || id == 9288 || id == 1780 || id == 8306 || id == 202 || id == 204 || id == 206 || id == 2950 || id == 4802 || id == 4994 || id == 5260 || id == 5814 || id == 5980 || id == 7734 || id == 2592 || id == 2242 || id == 1794 || id == 1792 || id == 778 || id == 9510 || id == 8774 || id == 2568 || id == 9512 || id == 9502 || id == 9482 || id == 2250 || id == 2248 || id == 2244 || id == 2246 || id == 2286 || id == 9508 || id == 9504 || id == 9506 || id == 274 || id == 276 || id == 9476 || id == 1486 || id == 9498 || id == 4426 || id == 9496 || id == 278 || id == 9490 || id == 2410 || id == 9488 || id == 9452 || id == 9454 || id == 9472 || id == 9456 || id == 732 || id == 9458 || id == 6336 || id == 112 || id == 8 || id == 3760 || getItemDef(id).blockType == BlockTypes::FISH || id == 7372 || id == 9438 || id == 9462 || id == 9440 || id == 9442 || id == 9444 || id == 7960 || id == 7628 || id == 8552) continue;
							int kaina;
							ItemDefinition itemDef = getItemDef(id);
							if (getItemDef(id).blockType == BlockTypes::FOREGROUND || getItemDef(id).blockType == BlockTypes::BACKGROUND || getItemDef(id).blockType == BlockTypes::GROUND_BLOCK)
							{
								if (getItemDef(id).rarity <= 10)
								{
									kaina = 1;
								}
								else if (getItemDef(id).rarity <= 20)
								{
									kaina = 5;
								}
								else if (getItemDef(id).rarity <= 40)
								{
									kaina = 15;
								}
								else if (getItemDef(id).rarity <= 60)
								{
									kaina = 20;
								}
								else if (getItemDef(id).rarity <= 80)
								{
									kaina = 25;
								}
								else if (getItemDef(id).rarity <= 100)
								{
									kaina = 30;
								}
								else
								{
									kaina = 35;
								}
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `410`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (getItemDef(id).rarity == 999 && getItemDef(id).name.find("Golden") != string::npos)
							{
								kaina = 9000;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item is Very Rare`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (getItemDef(id).rarity == 999 && getItemDef(id).name.find("Phoenix") != string::npos)
							{
								kaina = 5000;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item is Very Rare`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (getItemDef(id).rarity == 999 && getItemDef(id).name.find("Nightmare") != string::npos)
							{
								kaina = 4000;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item is Very Rare`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (getItemDef(id).name.find("Subscription") != string::npos || id == 6260)
							{
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5Sorry, but this item is only available for premium subscribers`5!|\nadd_textbox|`5Subscriptions gives you many benefits including increased daily gems, new titles, and many other. They can be only obtained from `cWebsite Store`5, or `cThe Dark Stones`5`5!|\nadd_spacer|small|\nend_dialog|buyitembyrarity|`wCancel||");
							}
							else if (id == 9644)
							{
								kaina = 25000;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5By consuming this item you will receive 5x of all surgery tools and a Surg-E`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$Gems|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 2204)
							{
								kaina = 60000;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item allows you to hunt for geiger stuff! Find the crystals and a lot of more to explore`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$Gems|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (itemDef.properties & Property_Untradable)
							{
								kaina = 3000;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item is Rare`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (getItemDef(id).blockType == BlockTypes::CLOTHING)
							{
								ifstream infile("pricedata.txt");
								for (string line; getline(infile, line);)
								{
									if (line.length() > 3 && line[0] != '/' && line[1] != '/')
									{
										auto ex = explode("|", line);
										if (ex[0] == to_string(id))
										{
											kaina = atoi(ex[1].c_str());
											break;
										}
									}
								}
								if (kaina == 0) continue;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 1662)
							{
								kaina = 30;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item allows you to walk on spikes for 3 seconds`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 1452)
							{
								kaina = 10;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item allows you and other players to place something into it`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 8878)
							{
								kaina = 80;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item allows you to store any kind of items in it, also ability to protect it with password`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							/*Mails*/
							else if (id == 1006)
							{
								kaina = 15;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item allows players to leave message for the owners`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 656)
							{
								kaina = 15;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item allows players to leave message for the owners`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							/*Storage*/
							else if (id == 6286)
							{
								kaina = 20;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item allows you to store any kind of items in it, has 20 capacity`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 6288)
							{
								kaina = 50;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item allows you to store any kind of items in it, has 40 capacity`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 6290)
							{
								kaina = 120;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item allows you to store any kind of items in it, has 90 capacity`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							/*Fishing Things*/
							else if (id == 2912)
							{
								kaina = 10;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This rod allows you to fish, able to catch small fishes`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 3010)
							{
								kaina = 120;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This rod allows you to fish, able to catch medium fishes and low rarity gear`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 3040)
							{
								kaina = 690;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This rod allows you to fish, able to catch big fishes and medium rarity gear`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 3100)
							{
								kaina = 3200;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This rod allows you to fish, able to catch huge fishes and high rarity gear`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 5740)
							{
								kaina = 9600;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This thing is so magical...`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							/*Baits*/
							else if (id == 2914)
							{
								kaina = 1;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5Simple regular worm bait for small fishes`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `45`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 3098)
							{
								kaina = 5;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This bait gives you faster strike time and bigger luck`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 3218)
							{
								kaina = 8;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5Its so sticky that probably stuff will stick to it`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 3432)
							{
								kaina = 90;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5Ever dreamed of becoming a champion of fishing? Try your luck, able to catch high tier gear`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 4246)
							{
								kaina = 3;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5Bait for medium fishes`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 4248)
							{
								kaina = 3;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5Bait for medium fishes`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 5528)
							{
								kaina = 15;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5Woah, this bait is large it must catch something greater`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							/*End*/
							else if (id == 6924)
							{
								kaina = 60;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item gives you triple place ability for all farmable blocks 5 minutes when consumed`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 6918)
							{
								kaina = 80;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item gives you 1 HIT ability for all farmable blocks 5 minutes when consumed`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 6840)
							{
								kaina = 1200;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item gives you 30% chance to obtain extra blocks when harvesting trees`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 1436)
							{
								kaina = 5;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item allows you to prevent moderators abuse by logging every action into this camera`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 2978)
							{
								kaina = 5;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item is used to sell your stuff directly for world locks, works totally like in real growtopia with full visuals`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 898)
							{
								kaina = 60;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item allows you to harvest trees`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 1966)
							{
								kaina = 800;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item allows you to harvest trees, with a chance to get bonus drop`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 5022)
							{
								kaina = 350;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item allows you to plant trees`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 528)
							{
								kaina = 25;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item gives you extra gem drop for 30 minutes when consumed`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 5638)
							{
								kaina = 3500;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item can collect any blocks, capacity 5000 and remote included`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 6946)
							{
								kaina = 900;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item can collect any seeds, capacity 1500`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 6948)
							{
								kaina = 300;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item can collect any foreground or background, capacity 1500`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 10012)
							{
								kaina = 1800;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item is made by Shirogane`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 10016)
							{
								kaina = 3500;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item is made by Fads`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 10018)
							{
								kaina = 1200;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item is made by Shiina`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (getItemDef(id).clothType == ClothTypes::BACK && getItemDef(id).rarity == 999)
							{
								kaina = 900;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 10014)
							{
								kaina = 1500;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item is made by Shiina`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 2946)
							{
								kaina = 5;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This block can store blocks and items in it`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 1404)
							{
								kaina = 15;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item allows you to move white door`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (id == 874)
							{
								kaina = 3;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_textbox|`5This item can be used as ingredient for other items`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else if (getItemDef(id).rarity == 999)
							{
								kaina = 600;
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
							else
							{
								kaina = round(static_cast<float>(getItemDef(id).rarity) / 10 * 5);
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Purchase `c" + getItemDef(id).name + " `9(`c" + to_string(getItemDef(id).rarity) + "`9)|left|" + to_string(id) + "|\nadd_spacer|small|\nadd_textbox|`5You are preparing to buy `c" + getItemDef(id).name + "`5!|\nadd_spacer|small||\nadd_textbox|`5This item cost `41`c/`4" + to_string(kaina) + " `$World Locks|\nadd_spacer|small||\nadd_textbox|`5How much you want to buy? |\nadd_text_input|buyitembyrarityid_" + to_string(id) + "|||7||\nend_dialog|buyitembyrarity|`wCancel|`^Purchase!|");
							}
						}
						else if (isFindDialog)
						{
							string itemLower2;
							vector<ItemDefinition> itemDefsfind;
							for (char c : itemFind) if (c < 0x20 || c > 0x7A) goto SKIPFind;
							if (itemFind.length() < 3) goto SKIPFind3;
							for (const ItemDefinition& item : itemDefs)
							{
								string itemLower;
								for (char c : item.name) if (c < 0x20 || c > 0x7A) goto SKIPFind2;
								if (!(item.id % 2 == 0)) goto SKIPFind2;
								itemLower2 = item.name;
								std::transform(itemLower2.begin(), itemLower2.end(), itemLower2.begin(), ::tolower);
								if (itemLower2.find(itemLower) != std::string::npos)
								{
									itemDefsfind.push_back(item);
								}
							SKIPFind2:;
							}
						SKIPFind3:;
							string listMiddle = "";
							string listFull = "";
							for (const ItemDefinition& item : itemDefsfind)
							{
								string kys = item.name;
								std::transform(kys.begin(), kys.end(), kys.begin(), ::tolower);
								string kms = itemFind;
								std::transform(kms.begin(), kms.end(), kms.begin(), ::tolower);
								if (kys.find(kms) != std::string::npos)
									listMiddle += "add_button_with_icon|tool" + to_string(item.id) + "|`$" + item.name + "``|left|" + to_string(item.id) + "||\n";
							}
							if (itemFind.length() < 3)
							{
								listFull = "add_textbox|`4Word is less than 3 letters!``|\n";
								showWrong(peer, listFull, itemFind);
							}
							else if (itemDefsfind.size() == 0)
							{
								showWrong(peer, listFull, itemFind);
							}
							else
							{
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Found item : " + itemFind + "``|left|3146|\nadd_textbox|Enter a word below to find the item|\nadd_text_input|item|Item Name||20|\nend_dialog|findid|Cancel|Find the item!|\nadd_spacer|big|\n" + listMiddle + "add_quick_exit|\n");
							}
						}
					SKIPFind:;
						if (btn == "ipbanwrench") {
							if (isMod(peer)) {
								Player::OnTextOverlay(peer, "IP Ban mod applied to " + static_cast<PlayerInfo*>(peer->data)->lastInfo + "!");
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
									if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == static_cast<PlayerInfo*>(peer->data)->lastInfo) {
										if (static_cast<PlayerInfo*>(currentPeer->data)->haveGrowId == false) continue;
										autoBan(currentPeer, true, 100000, "ip ban wrench");
									}
								}
								SendPunishView(peer, static_cast<PlayerInfo*>(peer->data)->lastInfo);
							}
						}
						if (btn == "suspend8w") {
							if (isMod(peer)) {
								Player::OnTextOverlay(peer, "8 Week Ban mod applied to " + static_cast<PlayerInfo*>(peer->data)->lastInfo + "!");
								MYSQL_ROW row;
								int konvertuotasInt = 86400;
								string q = "UPDATE PlayerDatabase SET timebanned = '" + to_string((GetCurrentTimeInternalSeconds() + (konvertuotasInt * 60))) + "' WHERE username = '" + static_cast<PlayerInfo*>(peer->data)->lastInfo + "'";
								if (mysql_query(conn, q.c_str())) {
									cout << mysql_error(conn) << endl;
									continue;
								}
								string userdisplay = "";
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
									if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == static_cast<PlayerInfo*>(peer->data)->lastInfo) {
										userdisplay = static_cast<PlayerInfo*>(currentPeer->data)->displayName;
									}
								}
								if (userdisplay == "") userdisplay = static_cast<PlayerInfo*>(peer->data)->lastInfo;
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
									Player::OnConsoleMessage(currentPeer, "`#** `$The Ancients `ohave used `#Ban `oon `w" + userdisplay + "`o! `#**");
									if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == static_cast<PlayerInfo*>(peer->data)->lastInfo) {
										Player::OnAddNotification(currentPeer, "`wWarning from `4System`w: You've been `4BANNED `wfor " + OutputBanTime(konvertuotasInt * 60) + "", "audio/hub_open.wav", "interface/atomic_button.rttex");
										Player::OnConsoleMessage(currentPeer, "`wWarning from `4System`w: You've been `4BANNED `wfor " + OutputBanTime(konvertuotasInt * 60) + "");
										enet_peer_disconnect_later(currentPeer, 0);
									}
								}
								string qss = "SELECT * FROM PlayerDatabase WHERE username = '" + static_cast<PlayerInfo*>(peer->data)->lastInfo + "' LIMIT 1";
								string account_history;
								mysql_query(conn, qss.c_str());
								res = mysql_store_result(conn);
								while (row = mysql_fetch_row(res)) {
									account_history = row[68];
								}
								//if (res) mysql_free_result(res);
								time_t currentTime;
								time(&currentTime);
								const auto localTime = localtime(&currentTime);
								const auto Hour = localTime->tm_hour;
								const auto Min = localTime->tm_min;
								const auto Sec = localTime->tm_sec;
								const auto Year = localTime->tm_year + 1900;
								const auto Day = localTime->tm_mday;
								const auto Month = localTime->tm_mon + 1;
								account_history += "" + to_string(Month) + "/" + to_string(Day) + "/" + to_string(Year) + " " + to_string(Hour) + ":" + to_string(Min) + ":" + to_string(Sec) + ": " + static_cast<PlayerInfo*>(peer->data)->rawName + " - >> Ban for " + OutputBanTime(konvertuotasInt * 60) + " (DGH)|";
								string stringsa = "UPDATE PlayerDatabase SET accountnotes = '" + account_history + "' WHERE username = '" + static_cast<PlayerInfo*>(peer->data)->lastInfo + "' LIMIT 1";
								mysql_query(conn, stringsa.c_str());
								SendPunishView(peer, static_cast<PlayerInfo*>(peer->data)->lastInfo);
							}
						}
						if (btn == "suspend4w")
						{
							if (isMod(peer)) {
								Player::OnTextOverlay(peer, "4 Week Ban mod applied to " + static_cast<PlayerInfo*>(peer->data)->lastInfo + "!");
								MYSQL_ROW row;
								int konvertuotasInt = 43200;
								string q = "UPDATE PlayerDatabase SET timebanned = '" + to_string((GetCurrentTimeInternalSeconds() + (konvertuotasInt * 60))) + "' WHERE username = '" + static_cast<PlayerInfo*>(peer->data)->lastInfo + "'";
								if (mysql_query(conn, q.c_str())) {
									cout << mysql_error(conn) << endl;
									continue;
								}
								string userdisplay = "";
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
									if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == static_cast<PlayerInfo*>(peer->data)->lastInfo) {
										userdisplay = static_cast<PlayerInfo*>(currentPeer->data)->displayName;
									}
								}
								if (userdisplay == "") userdisplay = static_cast<PlayerInfo*>(peer->data)->lastInfo;
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
									Player::OnConsoleMessage(currentPeer, "`#** `$The Ancients `ohave used `#Ban `oon `w" + userdisplay + "`o! `#**");
									if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == static_cast<PlayerInfo*>(peer->data)->lastInfo) {
										Player::OnAddNotification(currentPeer, "`wWarning from `4System`w: You've been `4BANNED `wfor " + OutputBanTime(konvertuotasInt * 60) + "", "audio/hub_open.wav", "interface/atomic_button.rttex");
										Player::OnConsoleMessage(currentPeer, "`wWarning from `4System`w: You've been `4BANNED `wfor " + OutputBanTime(konvertuotasInt * 60) + "");
										enet_peer_disconnect_later(currentPeer, 0);
									}
								}
								string qss = "SELECT * FROM PlayerDatabase WHERE username = '" + static_cast<PlayerInfo*>(peer->data)->lastInfo + "' LIMIT 1";
								string account_history;
								mysql_query(conn, qss.c_str());
								res = mysql_store_result(conn);
								while (row = mysql_fetch_row(res)) {
									account_history = row[68];
								}
								//if (res) mysql_free_result(res);
								time_t currentTime;
								time(&currentTime);
								const auto localTime = localtime(&currentTime);
								const auto Hour = localTime->tm_hour;
								const auto Min = localTime->tm_min;
								const auto Sec = localTime->tm_sec;
								const auto Year = localTime->tm_year + 1900;
								const auto Day = localTime->tm_mday;
								const auto Month = localTime->tm_mon + 1;
								account_history += "" + to_string(Month) + "/" + to_string(Day) + "/" + to_string(Year) + " " + to_string(Hour) + ":" + to_string(Min) + ":" + to_string(Sec) + ": " + static_cast<PlayerInfo*>(peer->data)->rawName + " - >> Ban for " + OutputBanTime(konvertuotasInt * 60) + " (DGH)|";
								string stringsa = "UPDATE PlayerDatabase SET accountnotes = '" + account_history + "' WHERE username = '" + static_cast<PlayerInfo*>(peer->data)->lastInfo + "' LIMIT 1";
								mysql_query(conn, stringsa.c_str());
								SendPunishView(peer, static_cast<PlayerInfo*>(peer->data)->lastInfo);
							}
						}
						if (btn == "suspend2w") {
							if (isMod(peer)) {
								Player::OnTextOverlay(peer, "2 Week Ban mod applied to " + static_cast<PlayerInfo*>(peer->data)->lastInfo + "!");
								MYSQL_ROW row;
								int konvertuotasInt = 20160;
								string q = "UPDATE PlayerDatabase SET timebanned = '" + to_string((GetCurrentTimeInternalSeconds() + (konvertuotasInt * 60))) + "' WHERE username = '" + static_cast<PlayerInfo*>(peer->data)->lastInfo + "'";
								if (mysql_query(conn, q.c_str())) {
									cout << mysql_error(conn) << endl;
									continue;
								}
								string userdisplay = "";
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
									if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == static_cast<PlayerInfo*>(peer->data)->lastInfo) {
										userdisplay = static_cast<PlayerInfo*>(currentPeer->data)->displayName;
									}
								}
								if (userdisplay == "") userdisplay = static_cast<PlayerInfo*>(peer->data)->lastInfo;
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
									Player::OnConsoleMessage(currentPeer, "`#** `$The Ancients `ohave used `#Ban `oon `w" + userdisplay + "`o! `#**");
									if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == static_cast<PlayerInfo*>(peer->data)->lastInfo) {
										Player::OnAddNotification(currentPeer, "`wWarning from `4System`w: You've been `4BANNED `wfor " + OutputBanTime(konvertuotasInt * 60) + "", "audio/hub_open.wav", "interface/atomic_button.rttex");
										Player::OnConsoleMessage(currentPeer, "`wWarning from `4System`w: You've been `4BANNED `wfor " + OutputBanTime(konvertuotasInt * 60) + "");
										enet_peer_disconnect_later(currentPeer, 0);
									}
								}
								string qss = "SELECT * FROM PlayerDatabase WHERE username = '" + static_cast<PlayerInfo*>(peer->data)->lastInfo + "' LIMIT 1";
								string account_history;
								mysql_query(conn, qss.c_str());
								res = mysql_store_result(conn);
								while (row = mysql_fetch_row(res)) {
									account_history = row[68];
								}
								//if (res) mysql_free_result(res);
								time_t currentTime;
								time(&currentTime);
								const auto localTime = localtime(&currentTime);
								const auto Hour = localTime->tm_hour;
								const auto Min = localTime->tm_min;
								const auto Sec = localTime->tm_sec;
								const auto Year = localTime->tm_year + 1900;
								const auto Day = localTime->tm_mday;
								const auto Month = localTime->tm_mon + 1;
								account_history += "" + to_string(Month) + "/" + to_string(Day) + "/" + to_string(Year) + " " + to_string(Hour) + ":" + to_string(Min) + ":" + to_string(Sec) + ": " + static_cast<PlayerInfo*>(peer->data)->rawName + " - >> Ban for " + OutputBanTime(konvertuotasInt * 60) + " (DGH)|";
								string stringsa = "UPDATE PlayerDatabase SET accountnotes = '" + account_history + "' WHERE username = '" + static_cast<PlayerInfo*>(peer->data)->lastInfo + "' LIMIT 1";
								mysql_query(conn, stringsa.c_str());
								SendPunishView(peer, static_cast<PlayerInfo*>(peer->data)->lastInfo);
							}
						}
						if (btn == "suspend")
						{
							if (isMod(peer))
							{
								Player::OnTextOverlay(peer, "Ban mod applied to " + static_cast<PlayerInfo*>(peer->data)->lastInfo + "!");
								SendConsole("" + static_cast<PlayerInfo*>(peer->data)->lastInfo + " for permanent banned by " + static_cast<PlayerInfo*>(peer->data)->rawName + "", "MUTE");
								GamePacket p7 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`#** `$The Ancient Ones `ohave `4banned `w" + static_cast<PlayerInfo*>(peer->data)->lastInfo + " `#** `o(`4/rules `oto see the rules!)"));
								ENetPeer* currentPeer;
								time_t now = time(nullptr);
								char* dt = ctime(&now);
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == static_cast<PlayerInfo*>(peer->data)->lastInfo)
									{
										if (static_cast<PlayerInfo*>(currentPeer->data)->haveGrowId == false) continue;
										GamePacket ps2 = packetEnd(appendInt(appendString(appendString(appendString(appendString(createPacket(), "OnAddNotification"), "interface/atomic_button.rttex"), "`0Warning from `4System`0: You've been `4BANNED `0from GrowtopiaOS for 730 days"), "audio/hub_open.wav"), 0));
										ENetPacket* packet2 = enet_packet_create(ps2.data,
											ps2.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeer, 0, packet2);
										GamePacket ps3 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oWarning from `4System`o: You've been `4BANNED `ofrom GrowtopiaOS for 730 days"));
										ENetPacket* packet3 = enet_packet_create(ps3.data,
											ps3.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeer, 0, packet3);
										GamePacket pto = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "Applied punishment on " + static_cast<PlayerInfo*>(peer->data)->lastInfo + "."));
										ENetPacket* packetto = enet_packet_create(pto.data,
											pto.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packetto);
										enet_peer_disconnect_later(currentPeer, 0);
									}
									ENetPacket* packet7 = enet_packet_create(p7.data,
										p7.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(currentPeer, 0, packet7);
								}

								static_cast<PlayerInfo*>(peer->data)->ban = 1;
								string username = PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->rawName);
								auto qstate = 0;
								stringstream ss;
								ss << "UPDATE PlayerDatabase SET isBanned = '1' WHERE username = '" + static_cast<PlayerInfo*>(peer->data)->lastInfo + "' LIMIT 1";
								auto query = ss.str();
								const auto q = query.c_str();
								if (mysql_query(conn, q)) {
									cout << mysql_error(conn) << endl;						
									continue;
								}
								MYSQL_ROW row;
								string qsa = "SELECT * FROM PlayerDatabase WHERE username = '" + static_cast<PlayerInfo*>(peer->data)->lastInfo + "' LIMIT 1";
								string account_history;
								mysql_query(conn, qsa.c_str());
								res = mysql_store_result(conn);
								while (row = mysql_fetch_row(res)) {
									account_history = row[68];
								}
								//if (res) mysql_free_result(res);
								time_t currentTime;
								time(&currentTime);
								const auto localTime = localtime(&currentTime);
								const auto Hour = localTime->tm_hour;
								const auto Min = localTime->tm_min;
								const auto Sec = localTime->tm_sec;
								const auto Year = localTime->tm_year + 1900;
								const auto Day = localTime->tm_mday;
								const auto Month = localTime->tm_mon + 1;
								account_history += "" + to_string(Month) + "/" + to_string(Day) + "/" + to_string(Year) + " " + to_string(Hour) + ":" + to_string(Min) + ":" + to_string(Sec) + ": " + static_cast<PlayerInfo*>(peer->data)->rawName + " - >> Ban permanent (hacking/DGH)|";
								string string = "UPDATE PlayerDatabase SET accountnotes = '" + account_history + "' WHERE username = '" + static_cast<PlayerInfo*>(peer->data)->lastInfo + "' LIMIT 1";
								mysql_query(conn, string.c_str());
								SendPunishView(peer, static_cast<PlayerInfo*>(peer->data)->lastInfo);
							}
						}
						if (btn == "fakeautoban") {
							if (isMod(peer)) {
								bool Found = false;
								Player::OnTextOverlay(peer, "Fake auto ban used! Only works if they are online");
								string userdisplay = "";
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
									if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == static_cast<PlayerInfo*>(peer->data)->lastInfo) {
										Found = true;
										userdisplay = static_cast<PlayerInfo*>(currentPeer->data)->displayName;
										autoBan(currentPeer, true, 0, "");
										break;
									}
								}
								if (userdisplay == "") userdisplay = static_cast<PlayerInfo*>(peer->data)->lastInfo;
								if (Found) {
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
										Player::OnConsoleMessage(currentPeer, "`#** `$The Ancients `ohave used `#Ban `oon `w" + userdisplay + "`o! `#**");
									}
								}
								SendPunishView(peer, static_cast<PlayerInfo*>(peer->data)->lastInfo);
							}
						}
						if (btn == "suspendalts") {
							if (isMod(peer)) {
								MYSQL_ROW row;
								if (conn == nullptr) continue;
								if (conn != nullptr)
								{
									stringstream sse;
									string code = (str.substr(8).c_str());
									sse << "SELECT * FROM PlayerDatabase WHERE username = '" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->lastInfo) + "' LIMIT 1";
									auto query = sse.str();
									auto q = query.c_str();
									if (mysql_query(conn, q))
									{
										cout << mysql_error(conn) << endl;
										


										enet_peer_disconnect_later(peer, 0);
										continue;
									}
									string tip;
									string email;
									string ipid;
									res = mysql_store_result(conn);
									while (row = mysql_fetch_row(res))
									{
										email = row[3];
										ipid = row[15];
										tip = row[38];
									}
									//if (res) mysql_free_result(res);
									if (tip == "") tip = "-1";
									if (ipid == "8421376") ipid = "-1";
									stringstream sse1;
									sse1 << "SELECT * FROM PlayerDatabase WHERE ip = '" + tip + "' OR email = '" + email + "' OR ipID = '" + ipid + "'";
									auto query321 = sse1.str();
									auto q321 = query321.c_str();
									if (mysql_query(conn, q321))
									{
										cout << mysql_error(conn) << endl;
										


										enet_peer_disconnect_later(peer, 0);
										continue;
									}
									string test;
									string isbanned;
									res = mysql_store_result(conn);
									while (row = mysql_fetch_row(res))
									{
										test = row[1];
										isbanned = row[14];
										if (isbanned == "1")
										{
											Player::OnConsoleMessage(peer, test + " was already banned, skipped!");
											continue;
										}
										if (conn == nullptr)
										{
											cout << "conn was nullptr" << endl;
											continue;
										}
										if (conn != nullptr)
										{
											stringstream ss;
											ss << "UPDATE PlayerDatabase SET isBanned = '1' WHERE username = '" + test + "' OR email = '" + email + "' OR ipID = '" + ipid + "'";
											auto query = ss.str();
											const auto q = query.c_str();
											if (mysql_query(conn, q))
											{
												cout << mysql_error(conn) << endl;
												


												enet_peer_disconnect_later(peer, 0);
												continue;
											}
											SendConsole("" + test + " for permanent banned by " + static_cast<PlayerInfo*>(peer->data)->rawName + "", "BAN");
											Player::OnTextOverlay(peer, "Applied punishment on " + test + ".");
											ENetPeer* currentPeer;
											for (currentPeer = server->peers;
												currentPeer < &server->peers[server->peerCount];
												++currentPeer)
											{
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
												Player::OnConsoleMessage(currentPeer, "`#** `$The Ancient Ones `ohave `4banned `w" + test + " `#** `o(`4/rules `oto see the rules!)");
												if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == static_cast<PlayerInfo*>(peer->data)->lastInfo)
												{
													if (static_cast<PlayerInfo*>(currentPeer->data)->haveGrowId == false) continue;
													Player::OnAddNotification(currentPeer, "`0Warning from `4System`0: You've been `4BANNED `0from GrowtopiaOS for 730 days", "audio/hub_open.wav", "interface/atomic_button.rttex");
													Player::OnConsoleMessage(currentPeer, "`oWarning from `4System`o: You've been `4BANNED `ofrom GrowtopiaOS for 730 days");
													enet_peer_disconnect_later(currentPeer, 0);
												}
											}
											string qsa = "SELECT * FROM PlayerDatabase WHERE username = '" + test + "' LIMIT 1";
											string account_history;
											mysql_query(conn, qsa.c_str());
											res = mysql_store_result(conn);
											while (row = mysql_fetch_row(res)) {
												account_history = row[68];
											}
											//if (res) mysql_free_result(res);
											time_t currentTime;
											time(&currentTime);
											const auto localTime = localtime(&currentTime);
											const auto Hour = localTime->tm_hour;
											const auto Min = localTime->tm_min;
											const auto Sec = localTime->tm_sec;
											const auto Year = localTime->tm_year + 1900;
											const auto Day = localTime->tm_mday;
											const auto Month = localTime->tm_mon + 1;
											account_history += "" + to_string(Month) + "/" + to_string(Day) + "/" + to_string(Year) + " " + to_string(Hour) + ":" + to_string(Min) + ":" + to_string(Sec) + ": " + static_cast<PlayerInfo*>(peer->data)->rawName + " - >> Ban permanent on alt(s)|";
											string stringsss = "UPDATE PlayerDatabase SET accountnotes = '" + account_history + "' WHERE username = '" + test + "' LIMIT 1";
											mysql_query(conn, stringsss.c_str());
										}
										else
										{
											cout << "conn was nullptr3" << endl;
											continue;
										}
									}
									//if (res) mysql_free_result(res);
								}
								SendPunishView(peer, static_cast<PlayerInfo*>(peer->data)->lastInfo);
							}
						}
						if (btn == "punishview") {
							if (isMod(peer)) SendPunishView(peer, static_cast<PlayerInfo*>(peer->data)->lastInfo);
						}
						if (btn == "wban")
						{
							if (world == nullptr || static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT" || serverIsFrozen) continue;
							if (static_cast<PlayerInfo*>(peer->data)->lastInfo == static_cast<PlayerInfo*>(peer->data)->rawName)
							{
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->rawName == world->owner || isMod(peer))
							{
								ENetPeer* currentPeerp;
								for (currentPeerp = server->peers;
									currentPeerp < &server->peers[server->peerCount];
									++currentPeerp)
								{
									if (currentPeerp->state != ENET_PEER_STATE_CONNECTED)
										continue;
									string name = static_cast<PlayerInfo*>(peer->data)->displayName;
									string kickname = static_cast<PlayerInfo*>(peer->data)->lastDisplayname;
									//string kickname = static_cast<PlayerInfo*>(peer->data)->displayName;
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), name + " `4world bans " + "`o" + kickname + " from `w" + world->name + "`o!"));
									string text = "action|play_sfx\nfile|audio/repair.wav\ndelayMS|0\n";
									BYTE* data = new BYTE[5 + text.length()];
									BYTE zero = 0;
									int type = 3;
									memcpy(data, &type, 4);
									memcpy(data + 4, text.c_str(), text.length());
									memcpy(data + 4 + text.length(), &zero, 1);
									if (isHere(peer, currentPeerp))
									{
										ENetPacket* packetsou = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										ENetPacket* packet = enet_packet_create(p.data,
											p.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeerp, 0, packetsou);
										enet_peer_send(currentPeerp, 0, packet);
										delete data;
										delete p.data;
										if (static_cast<PlayerInfo*>(currentPeerp->data)->rawName == static_cast<PlayerInfo*>(peer->data)->lastInfo) // if last wrench
										{
											namespace fs = std::experimental::filesystem;
											if (!fs::is_directory("worldbans/" + world->name) || !fs::exists("worldbans/" + world->name))
											{
												fs::create_directory("worldbans/" + world->name);
												std::ofstream outfile("worldbans/" + world->name + "/" + static_cast<PlayerInfo*>(currentPeerp->data)->rawName);
												outfile << "worldbanned by: " + static_cast<PlayerInfo*>(peer->data)->rawName;
												outfile.close();
											}
											else
											{
												std::ofstream outfile("worldbans/" + world->name + "/" + static_cast<PlayerInfo*>(currentPeerp->data)->rawName);
												outfile << "worldbanned by: " + static_cast<PlayerInfo*>(peer->data)->rawName;
												outfile.close();
											}
											sendPlayerLeave(currentPeerp);
											static_cast<PlayerInfo*>(currentPeerp->data)->currentWorld = "EXIT";
											sendWorldOffers(currentPeerp);
										}
									}
								}
							}
						}
						if (btn == "kick") {
							if (world == nullptr || static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT" || serverIsFrozen) continue;
							if (static_cast<PlayerInfo*>(peer->data)->lastInfo == static_cast<PlayerInfo*>(peer->data)->rawName) continue;
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
								if (isHere(peer, currentPeer)) {
									if (static_cast<PlayerInfo*>(peer->data)->rawName == world->owner || isMod(peer) || !RestrictedArea(peer, world, static_cast<PlayerInfo*>(currentPeer->data)->x / 32, static_cast<PlayerInfo*>(currentPeer->data)->y / 32) && world->owner == "") {
										Player::OnConsoleMessage(currentPeer, static_cast<PlayerInfo*>(peer->data)->displayName + " `4kicks " + "`o" + static_cast<PlayerInfo*>(peer->data)->lastDisplayname + "`o!");
										if (static_cast<PlayerInfo*>(peer->data)->lastInfo == static_cast<PlayerInfo*>(currentPeer->data)->rawName) playerRespawn(world, currentPeer, false);
									}
								}
							}
						}
						if (btn == "pull")
						{
							if (world == nullptr || static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT" || serverIsFrozen) continue;
							if (static_cast<PlayerInfo*>(peer->data)->lastInfo == static_cast<PlayerInfo*>(peer->data)->rawName)
							{
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->rawName == world->owner || isMod(peer))
							{
								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
									string name = static_cast<PlayerInfo*>(currentPeer->data)->rawName;
									int pullX = static_cast<PlayerInfo*>(peer->data)->x;
									int pullY = static_cast<PlayerInfo*>(peer->data)->y;
									if (name == static_cast<PlayerInfo*>(peer->data)->lastInfo)
									{
										if (isHere(peer, currentPeer) && world->name != "EXIT")
										{
											string name = static_cast<PlayerInfo*>(peer->data)->displayName;
											string pullname = static_cast<PlayerInfo*>(currentPeer->data)->displayName;
											GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), name + " `5pulls " + "`o" + pullname + "`o!"));
											string text = "action|play_sfx\nfile|audio/object_spawn.wav\ndelayMS|0\n";
											BYTE* data = new BYTE[5 + text.length()];
											BYTE zero = 0;
											int type = 3;
											memcpy(data, &type, 4);
											memcpy(data + 4, text.c_str(), text.length());
											memcpy(data + 4 + text.length(), &zero, 1);
											ENetPacket* packet = enet_packet_create(p.data,
												p.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeer, 0, packet);
											enet_peer_send(peer, 0, packet);
											ENetPacket* packetsou = enet_packet_create(data,
												5 + text.length(),
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeer, 0, packetsou);
											enet_peer_send(peer, 0, packetsou);
											GamePacket p2 = packetEnd(appendFloat(appendString(createPacket(), "OnSetPos"), pullX, pullY));
											memcpy(p2.data + 8, &(static_cast<PlayerInfo*>(currentPeer->data)->netID), 4);
											ENetPacket* packet2 = enet_packet_create(p2.data,
												p2.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeer, 0, packet2);
											if (isWorldOwner(peer, world)) Player::OnTextOverlay(currentPeer, "You were pulled by " + static_cast<PlayerInfo*>(peer->data)->displayName + "");
											else if (isMod(peer)) Player::OnTextOverlay(currentPeer, "You were summoned by a mod");
											delete p2.data;
											delete p.data;
										}
									}
								}
							}
						}
						if (btn == "backsocialportal") {
							string ShowGuildDialog = "Create Guild";
							if (static_cast<PlayerInfo*>(peer->data)->joinguild == true) {
								ShowGuildDialog = "Show Guild Members";
							}
							Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big| `wSocial Portal`` |left|1366|\nadd_spacer|small|\nadd_button|showfriend|`wShow Friends``|noflags|0|0|\nadd_button|showguild|`w" + ShowGuildDialog + "``|noflags|0|0|\nadd_quick_exit|\nend_dialog|friends_guilds|OK||");
						}
						if (btn == "showfriend")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							string onlinefrnlist = "";
							int onlinecount = 0;
							int totalcount = static_cast<PlayerInfo*>(peer->data)->friendinfo.size();
							ENetPeer* currentPeer;
							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;
								string name = static_cast<PlayerInfo*>(currentPeer->data)->rawName;
								if (find(static_cast<PlayerInfo*>(peer->data)->friendinfo.begin(), static_cast<PlayerInfo*>(peer->data)->friendinfo.end(), name) != static_cast<PlayerInfo*>(peer->data)->friendinfo.end())
								{
									onlinefrnlist += "\nadd_button|onlinefrns_" + static_cast<PlayerInfo*>(currentPeer->data)->rawName + "|`2ONLINE: `o" + static_cast<PlayerInfo*>(currentPeer->data)->tankIDName + "``|0|0|";
									onlinecount++;
								}
							}
							if (totalcount == 0)
							{
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`o" + std::to_string(onlinecount) + " of " + std::to_string(totalcount) + " `wFriends Online``|left|1366|\n\nadd_spacer|small|\nadd_label|small|`1To add friends in `4GTOS `1Click on someone's name and click add as a friend!`o.``|left|4|\n\nadd_spacer|small|\nadd_button||`5Close``|0|0|\nadd_quick_exit|"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
							else if (onlinecount == 0)
							{
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`o" + std::to_string(onlinecount) + " of " + std::to_string(totalcount) + " `wFriends Online``|left|1366|\n\nadd_spacer|small|\nadd_button|chc0|`wClose``|0|0|\nadd_label|small|`oNone of your friends are currently online.``|left|4|\n\nadd_spacer|small|\nadd_button|showoffline|`5Show offline``|0|0|\nadd_button||`5Close``|0|0|\nadd_quick_exit|"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
							else
							{
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`o" + std::to_string(onlinecount) + " of " + std::to_string(totalcount) + " `wFriends Online``|left|1366|\n\nadd_spacer|small|\nadd_button|chc0|`wClose``|0|0|" + onlinefrnlist + "\n\nadd_spacer|small|\nadd_button|showoffline|`5Show offline``|0|0|\nadd_button||`oClose``|0|0|\nadd_quick_exit|"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
						}
						if (btn.substr(0, 18) == "clearaccountnotes_") {
							if (isMod(peer)) {
								string username = btn.substr(18, cch.length() - 18 - 1);
								string string = "UPDATE PlayerDatabase SET accountnotes = '' WHERE username = '" + username + "' LIMIT 1";
								mysql_query(conn, string.c_str());
								Player::OnTextOverlay(peer, "Account notes cleared for " + username + "!");
								SendPunishView(peer, username);
							}
						}
						if (btn.substr(0, 7) == "warpto_") {
							if (isMod(peer)) handle_world(peer, btn.substr(7, cch.length() - 7 - 1));
						}
						if (btn.substr(0, 9) == "viewinfo_") {
							if (isMod(peer)) SendPunishView(peer, btn.substr(9, cch.length() - 9 - 1));
						}
						if (btn.substr(0, 9) == "onlinegm_")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							ENetPeer* currentPeer;
							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;
								if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == btn.substr(9, cch.length() - 9 - 1))
								{
									static_cast<PlayerInfo*>(peer->data)->lastgmworld = static_cast<PlayerInfo*>(currentPeer->data)->currentWorld;
									static_cast<PlayerInfo*>(peer->data)->lastgmname = static_cast<PlayerInfo*>(currentPeer->data)->displayName;
									static_cast<PlayerInfo*>(peer->data)->lastgm = static_cast<PlayerInfo*>(currentPeer->data)->rawName;
								}
							}
							if (btn.substr(9, cch.length() - 9 - 1) == static_cast<PlayerInfo*>(peer->data)->rawName)
							{
								GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`w" + static_cast<PlayerInfo*>(peer->data)->lastgmname + "``|left|1366|\n\nadd_spacer|small|\nadd_textbox|This is you!|\n\nadd_spacer|small|\nadd_button|showguild|`oBack``|0|0|\nadd_quick_exit|"));
								ENetPacket* packet2 = enet_packet_create(p2.data,
									p2.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet2);
								delete p2.data;
							}
							else
							{
								if (static_cast<PlayerInfo*>(peer->data)->rawName == static_cast<PlayerInfo*>(peer->data)->guildLeader)
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`w" + static_cast<PlayerInfo*>(peer->data)->lastgmname + "``|left|1366|\n\nadd_spacer|small|\nadd_textbox|`o" + static_cast<PlayerInfo*>(peer->data)->lastgmname + " is `2online `onow in the world `5" + static_cast<PlayerInfo*>(peer->data)->lastgmworld + "`o.|\n\nadd_spacer|small|\nadd_button|gmwarpbutton|`oWarp to `5" + static_cast<PlayerInfo*>(peer->data)->lastgmworld + "``|0|0|\nadd_button|gmmsgbutton|`5Send message``|0|0|\n\nadd_spacer|small|\nadd_button|removegmonline|Kick from guild|0|0|\nadd_button|showguild|`oBack``|0|0|\nadd_quick_exit|"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
								else
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`w" + static_cast<PlayerInfo*>(peer->data)->lastgmname + "``|left|1366|\n\nadd_spacer|small|\nadd_textbox|`o" + static_cast<PlayerInfo*>(peer->data)->lastgmname + " is `2online `onow in the world `5" + static_cast<PlayerInfo*>(peer->data)->lastgmworld + "`o.|\n\nadd_spacer|small|\nadd_button|gmwarpbutton|`oWarp to `5" + static_cast<PlayerInfo*>(peer->data)->lastgmworld + "``|0|0|\nadd_button|gmmsgbutton|`5Send message``|0|0|\n\nadd_spacer|small|\nadd_button|showguild|`oBack``|0|0|\nadd_quick_exit|"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
								}
							}
						}
						if (btn == "showoffline")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							string onlinelist = "";
							string offlinelist = "";
							string offname = "";
							int onlinecount = 0;
							int totalcount = static_cast<PlayerInfo*>(peer->data)->friendinfo.size();
							vector<string> offliness = static_cast<PlayerInfo*>(peer->data)->friendinfo;
							ENetPeer* currentPeer;
							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;
								string name = static_cast<PlayerInfo*>(currentPeer->data)->rawName;
								if (find(static_cast<PlayerInfo*>(peer->data)->friendinfo.begin(), static_cast<PlayerInfo*>(peer->data)->friendinfo.end(), name) != static_cast<PlayerInfo*>(peer->data)->friendinfo.end())
								{
									onlinelist += "\nadd_button|onlinefrns_" + static_cast<PlayerInfo*>(currentPeer->data)->rawName + "|`2ONLINE: `o" + static_cast<PlayerInfo*>(currentPeer->data)->displayName + "``|0|0|";
									onlinecount++;
									offliness.erase(std::remove(offliness.begin(), offliness.end(), name), offliness.end());
								}
							}
							for (std::vector<string>::const_iterator i = offliness.begin(); i != offliness.end(); ++i)
							{
								offname = *i;
								offlinelist += "\nadd_button|offlinefrns_" + offname + "|`4OFFLINE: `o" + offname + "``|0|0|";
							}
							GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`o" + std::to_string(onlinecount) + " of " + std::to_string(totalcount) + " `wFriends Online|left|1366|\n\nadd_spacer|small|\nadd_button|chc0|`wClose``|0|0|\nadd_spacer|small|" + offlinelist + "\nadd_spacer|small|\n\nadd_button|frnoption|`oFriend Options``|0|0|\nadd_button|showfriend|Back``|0|0|\nadd_button||`oClose``|0|0|\nadd_quick_exit|"));
							ENetPacket* packet2 = enet_packet_create(p2.data,
								p2.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet2);
							delete p2.data;
						}
						if (btn == "removecon")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->haveGrowId == false)
							{
								continue;
							}
							ENetPeer* currentPeer;
							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;
								if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == static_cast<PlayerInfo*>(peer->data)->lastFrn)
								{
									static_cast<PlayerInfo*>(peer->data)->friendinfo.erase(std::remove(static_cast<PlayerInfo*>(peer->data)->friendinfo.begin(), static_cast<PlayerInfo*>(peer->data)->friendinfo.end(), static_cast<PlayerInfo*>(peer->data)->lastFrn), static_cast<PlayerInfo*>(peer->data)->friendinfo.end());
									static_cast<PlayerInfo*>(currentPeer->data)->friendinfo.erase(std::remove(static_cast<PlayerInfo*>(currentPeer->data)->friendinfo.begin(), static_cast<PlayerInfo*>(currentPeer->data)->friendinfo.end(), static_cast<PlayerInfo*>(peer->data)->rawName), static_cast<PlayerInfo*>(currentPeer->data)->friendinfo.end());

									string friends_string = "";
									for (int i = 0; i < static_cast<PlayerInfo*>(peer->data)->friendinfo.size(); i++)
									{
										friends_string += static_cast<PlayerInfo*>(peer->data)->friendinfo[i] + ",";
									}

									auto qstate = 0;
									if (conn == nullptr)
									{
										cout << "conn was nullptr" << endl;
										continue;
									}
									if (conn != nullptr)
									{
										stringstream ss;
										ss << "UPDATE PlayerDatabase SET friends = '" + friends_string + "' WHERE username = '" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->rawName) + "'";
										auto query = ss.str();
										const auto q = query.c_str();
										if (mysql_query(conn, q))
										{
											cout << mysql_error(conn) << endl;
											


											enet_peer_disconnect_later(peer, 0);
											continue;
										}
									}


									string friends_string2 = "";
									for (int i = 0; i < static_cast<PlayerInfo*>(currentPeer->data)->friendinfo.size(); i++)
									{
										friends_string2 += static_cast<PlayerInfo*>(currentPeer->data)->friendinfo[i] + ",";
									}

									auto qstate2 = 0;
									if (conn == nullptr)
									{
										cout << "conn was nullptr" << endl;
										continue;
									}
									if (conn != nullptr)
									{
										stringstream ss;
										ss << "UPDATE PlayerDatabase SET friends = '" + friends_string2 + "' WHERE username = '" + PlayerDB::getProperName(static_cast<PlayerInfo*>(currentPeer->data)->rawName) + "'";
										auto query = ss.str();
										const auto q = query.c_str();
										if (mysql_query(conn, q))
										{
											cout << mysql_error(conn) << endl;
											


											enet_peer_disconnect_later(peer, 0);
											continue;
										}
									}

									Player::OnConsoleMessage(currentPeer, "`3FRIEND ALERT: `2" + static_cast<PlayerInfo*>(peer->data)->displayName + " `ohas removed you as a friend.");
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`4Friend removed``|left|1366|\n\nadd_spacer|small|\nadd_textbox|`oOk, you are no longer friends with `o" + static_cast<PlayerInfo*>(peer->data)->lastFrnName + ".``|\n\nadd_spacer|small|\nadd_button||`oOK``|0|0|\nadd_quick_exit|"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
									break;
								}
							}
						}
						if (btn == "removeconoff") {
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT") {
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->haveGrowId == false) {
								continue;
							}
							static_cast<PlayerInfo*>(peer->data)->friendinfo.erase(std::remove(static_cast<PlayerInfo*>(peer->data)->friendinfo.begin(), static_cast<PlayerInfo*>(peer->data)->friendinfo.end(), static_cast<PlayerInfo*>(peer->data)->lastFrn), static_cast<PlayerInfo*>(peer->data)->friendinfo.end());
							cout << "last friend " + static_cast<PlayerInfo*>(peer->data)->lastFrn << endl;
							MYSQL_ROW row;
							string qds = "SELECT * FROM PlayerDatabase WHERE username = '" + static_cast<PlayerInfo*>(peer->data)->lastFrn + "'";
							if (mysql_query(conn, qds.c_str())) {
								cout << mysql_error(conn) << endl;
								continue;
							}
							string Friends = "";
							res = mysql_store_result(conn);
							while (row = mysql_fetch_row(res)) {
								Friends = row[17];
							}
							stringstream ss(Friends);
							vector<string> result;
							while (ss.good()) {
								string substr;
								getline(ss, substr, ',');
								if (substr.size() == 0) continue;
								result.push_back(substr);
							}
							result.erase(std::remove(result.begin(), result.end(), static_cast<PlayerInfo*>(peer->data)->rawName), result.end());
							string friends_string = "";
							for (int i = 0; i < result.size(); i++) {
								friends_string += result[i] + ",";
							}
							auto qstate = 0;
							string qq = "UPDATE PlayerDatabase SET friends = '" + friends_string + "' WHERE username = '" + static_cast<PlayerInfo*>(peer->data)->lastFrn + "'";
							if (mysql_query(conn, qq.c_str())) {
								cout << mysql_error(conn) << endl;
								continue;
							}
							friends_string = "";
							for (int i = 0; i < static_cast<PlayerInfo*>(peer->data)->friendinfo.size(); i++) {
								friends_string += static_cast<PlayerInfo*>(peer->data)->friendinfo[i] + ",";
							}
							string q = "UPDATE PlayerDatabase SET friends = '" + friends_string + "' WHERE username = '" + static_cast<PlayerInfo*>(peer->data)->rawName + "'";
							if (mysql_query(conn, q.c_str())) {
								cout << mysql_error(conn) << endl;
								continue;
							}
							Player::OnDialogRequest(peer, "set_default_color|`o\n\nadd_label_with_icon|big|`4Friend removed``|left|1366|\n\nadd_spacer|small|\nadd_textbox|`oOk, you are no longer friends with `o" + static_cast<PlayerInfo*>(peer->data)->lastFrn + ".``|\n\nadd_spacer|small|\nadd_button||`oOK``|0|0|\nadd_quick_exit|");
						}
						if (btn.substr(0, 11) == "onlinefrns_")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							ENetPeer* currentPeer;
							for (currentPeer = server->peers;
								currentPeer < &server->peers[server->peerCount];
								++currentPeer)
							{
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
									continue;
								if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == btn.substr(11, cch.length() - 11 - 1))
								{
									static_cast<PlayerInfo*>(peer->data)->lastFrnWorld = static_cast<PlayerInfo*>(currentPeer->data)->currentWorld;
									static_cast<PlayerInfo*>(peer->data)->lastFrnName = static_cast<PlayerInfo*>(currentPeer->data)->tankIDName;
									static_cast<PlayerInfo*>(peer->data)->lastFrn = static_cast<PlayerInfo*>(currentPeer->data)->rawName;
								}
							}
							GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`w" + static_cast<PlayerInfo*>(peer->data)->lastFrnName + "``|left|1366|\n\nadd_spacer|small|\nadd_textbox|`o" + static_cast<PlayerInfo*>(peer->data)->lastFrnName + " is `2online `onow in the world `5" + static_cast<PlayerInfo*>(peer->data)->lastFrnWorld + "`o.|\n\nadd_spacer|small|\nadd_button|frnwarpbutton|`oWarp to `5" + static_cast<PlayerInfo*>(peer->data)->lastFrnWorld + "``|0|0|\nadd_button|msgbutton|`5Send message``|0|0|\n\nadd_spacer|small|\nadd_button|removecon|`oRemove as friend``|0|0|\nadd_button|showfriend|`oBack``|0|0|\nadd_quick_exit|"));
							ENetPacket* packet2 = enet_packet_create(p2.data,
								p2.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet2);
							delete p2.data;
						}
						if (btn == "frnwarpbutton")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							/*if (static_cast<PlayerInfo*>(peer->data)->isCursed == true)
							{
								GamePacket p0 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4You are cursed now!"));
								ENetPacket* packet0 = enet_packet_create(p0.data,
									p0.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet0);
								delete p0.data;
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->lastFrnWorld == "SERVER")
							{
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4 You cannot warp to your friend now! `7Try it later."));
								ENetPacket* packet = enet_packet_create(p.data,
									p.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else if (static_cast<PlayerInfo*>(peer->data)->lastFrnWorld == "EXIT" || static_cast<PlayerInfo*>(peer->data)->lastFrnWorld == "exit")
							{
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4 You cannot warp to your friend because he is in `2EXIT `4world."));
								ENetPacket* packet = enet_packet_create(p.data,
									p.len,
									ENET_PACKET_FLAG_RELIABLE);
								enet_peer_send(peer, 0, packet);
								delete p.data;
							}
							else
							{
								sendPlayerLeave(peer);
								joinWorld(peer, static_cast<PlayerInfo*>(peer->data)->lastFrnWorld, 0, 0);
							}*/
						}
						if (btn == "msgbutton")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "add_label_with_icon|big|`5Message to `o" + static_cast<PlayerInfo*>(peer->data)->lastFrnName + "|left|660|\nadd_spacer|small|\nadd_text_input|msgtext|||50|\nend_dialog|msgdia|Cancel|`5Send``| \nadd_spacer|big|\nadd_button|showfriend|`oBack``|0|0|\nadd_quick_exit|\n"));
							ENetPacket* packet2 = enet_packet_create(p2.data,
								p2.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet2);
							delete p2.data;
						}
						if (btn.substr(0, 12) == "offlinefrns_")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							static_cast<PlayerInfo*>(peer->data)->lastFrn = btn.substr(12, cch.length() - 12 - 1);
							GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`w" + static_cast<PlayerInfo*>(peer->data)->lastFrn + "``|left|1366|\n\nadd_spacer|small|\nadd_textbox|`o" + static_cast<PlayerInfo*>(peer->data)->lastFrn + " is `4offline`o.``|\nadd_spacer|small|\nadd_button|removeconoff|`oRemove as friend``|0|0|\nadd_button|showoffline|`oBack``|0|0|\nadd_quick_exit|"));
							ENetPacket* packet2 = enet_packet_create(p2.data,
								p2.len,
								ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet2);
							delete p2.data;
						}
						if (btn == "addfriendrnbutton")
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT")
							{
								continue;
							}
							if (static_cast<PlayerInfo*>(peer->data)->haveGrowId == true)
							{
								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == static_cast<PlayerInfo*>(peer->data)->lastInfo)
									{
										// if last wrench
										if (static_cast<PlayerInfo*>(peer->data)->lastfriend == static_cast<PlayerInfo*>(currentPeer->data)->rawName)
										{
											// last  h friend
											static_cast<PlayerInfo*>(peer->data)->friendinfo.push_back(static_cast<PlayerInfo*>(currentPeer->data)->rawName); //add
											static_cast<PlayerInfo*>(currentPeer->data)->friendinfo.push_back(static_cast<PlayerInfo*>(peer->data)->rawName);

											string friends_string = "";
											for (int i = 0; i < static_cast<PlayerInfo*>(peer->data)->friendinfo.size(); i++)
											{
												friends_string += static_cast<PlayerInfo*>(peer->data)->friendinfo[i] + ",";
											}

											auto qstate = 0;
											if (conn == nullptr)
											{
												cout << "conn was nullptr" << endl;
												continue;
											}
											if (conn != nullptr)
											{
												stringstream ss;
												ss << "UPDATE PlayerDatabase SET friends = '" + friends_string + "' WHERE username = '" + PlayerDB::getProperName(static_cast<PlayerInfo*>(peer->data)->rawName) + "'";
												auto query = ss.str();
												const auto q = query.c_str();
												if (mysql_query(conn, q))
												{
													cout << mysql_error(conn) << endl;
													


													enet_peer_disconnect_later(peer, 0);
													continue;
												}
											}


											string friends_string2 = "";
											for (int i = 0; i < static_cast<PlayerInfo*>(currentPeer->data)->friendinfo.size(); i++)
											{
												friends_string2 += static_cast<PlayerInfo*>(currentPeer->data)->friendinfo[i] + ",";
											}

											auto qstate2 = 0;
											if (conn == nullptr)
											{
												cout << "conn was nullptr" << endl;
												continue;
											}
											if (conn != nullptr)
											{
												stringstream ss;
												ss << "UPDATE PlayerDatabase SET friends = '" + friends_string2 + "' WHERE username = '" + PlayerDB::getProperName(static_cast<PlayerInfo*>(currentPeer->data)->rawName) + "'";
												auto query = ss.str();
												const auto q = query.c_str();
												if (mysql_query(conn, q))
												{
													cout << mysql_error(conn) << endl;
													


													enet_peer_disconnect_later(peer, 0);
													continue;
												}
											}


											string text = "action|play_sfx\nfile|audio/love_in.wav\ndelayMS|0\n";
											BYTE* data = new BYTE[5 + text.length()];
											BYTE zero = 0;
											int type = 3;
											memcpy(data, &type, 4);
											memcpy(data + 4, text.c_str(), text.length());
											memcpy(data + 4 + text.length(), &zero, 1);
											ENetPacket* packet2 = enet_packet_create(data,
												5 + text.length(),
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeer, 0, packet2);
											enet_peer_send(peer, 0, packet2);
											delete data;
											GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`3FRIEND ADDED: `oYou're now friends with `w" + static_cast<PlayerInfo*>(peer->data)->displayName + "`o!"));
											ENetPacket* packet = enet_packet_create(p.data,
												p.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeer, 0, packet);
											delete p.data;
											GamePacket p3 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`3FRIEND ADDED: `oYou're now friends with `w" + static_cast<PlayerInfo*>(currentPeer->data)->displayName + "`o!"));
											ENetPacket* packet3 = enet_packet_create(p3.data,
												p3.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet3);
											delete p3.data;
										}
										else
										{
											GamePacket p4 = packetEnd(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"), static_cast<PlayerInfo*>(peer->data)->netID), "`5[`wFriend request sent to " + static_cast<PlayerInfo*>(currentPeer->data)->displayName + "`5]"));
											ENetPacket* packet4 = enet_packet_create(p4.data,
												p4.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet4);
											delete p4.data;
											string text = "action|play_sfx\nfile|audio/tip_start.wav\ndelayMS|0\n";
											BYTE* data = new BYTE[5 + text.length()];
											BYTE zero = 0;
											int type = 3;
											memcpy(data, &type, 4);
											memcpy(data + 4, text.c_str(), text.length());
											memcpy(data + 4 + text.length(), &zero, 1);
											ENetPacket* packet2 = enet_packet_create(data,
												5 + text.length(),
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeer, 0, packet2);
											delete data;
											static_cast<PlayerInfo*>(currentPeer->data)->lastfriend = static_cast<PlayerInfo*>(peer->data)->rawName;
											GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`3FRIEND REQUEST: `oYou've received a `wfriend request `ofrom `w" + static_cast<PlayerInfo*>(peer->data)->displayName + "`o! To accept, click the `wwrench by his/her name `oand then choose `wAdd as friend`o."));
											ENetPacket* packet = enet_packet_create(p.data,
												p.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeer, 0, packet);
											delete p.data;
										}
									}
								}
							}
							else
							{
								SendRegisterDialog(peer);
							}
						}
					}
					string dropText = "action|drop\n|itemID|";
					if (cch.find(dropText) == 0)
					{
						if (static_cast<PlayerInfo*>(peer->data)->haveGrowId == true)
						{
							if (static_cast<PlayerInfo*>(peer->data)->isCursed == true)
							{
								Player::OnConsoleMessage(peer, "`4You are cursed now!");
								continue;
							}
							std::stringstream ss(cch);
							std::string to;
							int idx = -1;
							int count = -1;
							while (std::getline(ss, to, '\n'))
							{
								vector<string> infoDat = explode("|", to);
								if (infoDat.size() == 3)
								{
									if (infoDat[1] == "itemID") idx = atoi(infoDat[2].c_str());
									if (infoDat[1] == "count") count = atoi(infoDat[2].c_str());
								}
							}
							static_cast<PlayerInfo*>(peer->data)->lastdropitem = idx;
							static_cast<PlayerInfo*>(peer->data)->lastdropitemcount = count;
							if (idx == -1) continue;
							if (itemDefs.size() < idx || idx < 0) continue;
							/*int x = static_cast<PlayerInfo*>(peer->data)->x / 32;
							x -= 1;
							int y = static_cast<PlayerInfo*>(peer->data)->y / 32;
							y += 1;
							cout << "x yra " + to_string(x) << endl;
							cout << "y yra " + to_string(y) << endl;*/
							if (getItemDef(static_cast<PlayerInfo*>(peer->data)->lastdropitem).properties & Property_Untradable || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 18 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 32 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 6336 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 8552 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 9472 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 9482 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 9356 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 9492 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 9498 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 8774 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 1790 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 2592 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 1784 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 1792 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 1794 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 7734 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 8306 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 9458 || static_cast<PlayerInfo*>(peer->data)->lastdropitem == 5640)
							{
								Player::OnTextOverlay(peer, "You can't drop that.");
								continue;
							}
							/*if (getItemDef(world->items[x + (y * world->width)].foreground).blockType == BlockTypes::FOREGROUND && world->items[x + (y * world->width)].foreground != 0)
							{
								Player::OnTextOverlay(peer, "You can't drop that here, face somewhere with open space.");
								continue;
							}*/
							auto KiekTuri = 0;
							for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++)
							{
								if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == static_cast<PlayerInfo*>(peer->data)->lastdropitem && static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount >= 1)
								{
									KiekTuri = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
								}
							}
							Player::OnDialogRequest(peer, "add_label_with_icon|big|`wDrop " + itemDefs.at(idx).name + "``|left|" + std::to_string(idx) + "|\nadd_textbox|`oHow many to drop?|\nadd_text_input|dropitemcount||" + to_string(KiekTuri) + "|3|||\nadd_textbox|`4Warning:`` Any player who asks you to drop items is scamming you. We cannot restore scammed items.|left|\nend_dialog|dropdialog|Cancel|OK|\n");
							continue;
						}
						else
						{
							Player::OnTextOverlay(peer, "`^This Feature Only `9Available `^For Registered Players!");
						}
					}
					string trashText = "action|trash\n|itemID|"; // drop funkcianalumas
					if (cch.find(trashText) == 0) {
						std::stringstream ss(cch);
						std::string to;
						int idx = -1;
						int count = -1;
						while (std::getline(ss, to, '\n')) {
							vector<string> infoDat = explode("|", to);
							if (infoDat.size() == 3) {
								if (infoDat[1] == "itemID") idx = atoi(infoDat[2].c_str());
								if (infoDat[1] == "count") count = atoi(infoDat[2].c_str());
							}
						}
						static_cast<PlayerInfo*>(peer->data)->lasttrashitem = idx;
						static_cast<PlayerInfo*>(peer->data)->lasttrashitemcount = count;
						if (idx == -1) continue;
						if (itemDefs.size() < idx || idx < 0) continue;
						if (static_cast<PlayerInfo*>(peer->data)->lasttrashitem == 18 || static_cast<PlayerInfo*>(peer->data)->lasttrashitem == 32 || static_cast<PlayerInfo*>(peer->data)->lasttrashitem == 6336 || static_cast<PlayerInfo*>(peer->data)->lasttrashitem == 8552 || static_cast<PlayerInfo*>(peer->data)->lasttrashitem == 9472 || static_cast<PlayerInfo*>(peer->data)->lasttrashitem == 9482 || static_cast<PlayerInfo*>(peer->data)->lasttrashitem == 9356 || static_cast<PlayerInfo*>(peer->data)->lasttrashitem == 9492 || static_cast<PlayerInfo*>(peer->data)->lasttrashitem == 9498 || static_cast<PlayerInfo*>(peer->data)->lasttrashitem == 8774 || static_cast<PlayerInfo*>(peer->data)->lasttrashitem == 1790 || static_cast<PlayerInfo*>(peer->data)->lasttrashitem == 2592 || static_cast<PlayerInfo*>(peer->data)->lasttrashitem == 1784 || static_cast<PlayerInfo*>(peer->data)->lasttrashitem == 1792 || static_cast<PlayerInfo*>(peer->data)->lasttrashitem == 1794 || static_cast<PlayerInfo*>(peer->data)->lasttrashitem == 7734 || static_cast<PlayerInfo*>(peer->data)->lasttrashitem == 8306 || static_cast<PlayerInfo*>(peer->data)->lasttrashitem == 9458) {
							Player::OnTextOverlay(peer, "You can't trash that.");
							continue;
						} else {
							auto KiekTuri = 0;
							for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++) {
								if (static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID == static_cast<PlayerInfo*>(peer->data)->lasttrashitem && static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount >= 1) {
									KiekTuri = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
								}
							}
							if (idx == 242) {
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`4Recycle `w" + itemDefs.at(idx).name + "``|left|" + std::to_string(idx) + "|\nadd_label|small|You will get up to 2000 gems per item.|left|\nadd_textbox|`oHow many to `4destroy`o? (you have " + to_string(KiekTuri) + ")|\nadd_text_input|trashitemcount||0|3|\nend_dialog|trashdialog|Cancel|OK|\n");
							} else if (idx == 1796) {
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`4Recycle `w" + itemDefs.at(idx).name + "``|left|" + std::to_string(idx) + "|\nadd_label|small|You will get up to 200000 gems per item.|left|\nadd_textbox|`oHow many to `4destroy`o? (you have " + to_string(KiekTuri) + ")|\nadd_text_input|trashitemcount||0|3|\nend_dialog|trashdialog|Cancel|OK|\n");
							} else if (idx == 7188) {
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`4Recycle `w" + itemDefs.at(idx).name + "``|left|" + std::to_string(idx) + "|\nadd_label|small|You will get up to 20000000 gems per item.|left|\nadd_textbox|`oHow many to `4destroy`o? (you have " + to_string(KiekTuri) + ")|\nadd_text_input|trashitemcount||0|3|\nend_dialog|trashdialog|Cancel|OK|\n");
							} else if (getItemDef(idx).blockType == BlockTypes::FISH) {
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`4Recycle `w" + itemDefs.at(idx).name + "``|left|" + std::to_string(idx) + "|\nadd_label|small|You will get up to 5 gems per item.|left|\nadd_textbox|`oHow many to `4destroy`o? (you have " + to_string(KiekTuri) + ")|\nadd_text_input|trashitemcount||0|3|\nend_dialog|trashdialog|Cancel|OK|\n");
							} else {
								Player::OnDialogRequest(peer, "add_label_with_icon|big|`4Trash `w" + itemDefs.at(idx).name + "``|left|" + std::to_string(idx) + "|\nadd_textbox|`oHow many to `4destroy`o? (you have " + to_string(KiekTuri) + ")|\nadd_text_input|trashitemcount||0|3|\nend_dialog|trashdialog|Cancel|OK|\n");
							}
						}
					}
					if (cch.find("text|") != std::string::npos) {
						bool canchat = true;
						if (str.length() > 120) continue;
						if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT" || world == nullptr) continue;
						if (str.length() && str[0] == '/') {
							sendAction(peer, static_cast<PlayerInfo*>(peer->data)->netID, str);
							if (str.find("/msg ") != string::npos) {
								Player::OnConsoleMessage(peer, "CP:_PL:0_OID:_CT:[MSG]_ `6" + str);
							} else if (str.find("/r ") != string::npos) {
								Player::OnConsoleMessage(peer, "CP:_PL:0_OID:_CT:[MSG]_ `6" + str);
							} else if (str.find("/sb ") != string::npos) {
								Player::OnConsoleMessage(peer, "CP:_PL:0_OID:_CT:[SB]_ `6" + str);
							} else if (str.find("/ssb ") != string::npos) {
								Player::OnConsoleMessage(peer, "CP:_PL:0_OID:_CT:[CB]_ `6" + str);
							} else {
								Player::OnConsoleMessage(peer, "`6" + str);
							}
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
								if (static_cast<PlayerInfo*>(currentPeer->data)->GlobalChat) {
									Player::OnConsoleMessage(currentPeer, "CP:_PL:0_OID:_CT:[W]_ `6<`w" + static_cast<PlayerInfo*>(peer->data)->displayName + "`6> `" + static_cast<PlayerInfo*>(peer->data)->chatcolor + str);
								}
							}
						}
						else if (static_cast<PlayerInfo*>(peer->data)->taped == false) {
							if (world->silence == true && !isWorldOwner(peer, world)) {
								Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`1(Peasants must not to talk)", 0, true);
								continue;
							}
							SendChat(peer, static_cast<PlayerInfo*>(peer->data)->netID, str);
							SendConsole("" + static_cast<PlayerInfo*>(peer->data)->rawName + ": " + str, "CHAT");
						} else {
							for (char c : str) {
								if (str.find(" ")) canchat = false;
							}
							if (canchat) {
								if (static_cast<PlayerInfo*>(peer->data)->cantsay) {
									const string mf[4] = { "mf ff mf fm", "f fmf fmfmf fmm", "mfm ff mf mf", "mff ffmf mf " };
									string word = mf[rand() % 4];
									if (world->silence == true && !isWorldOwner(peer, world)) {
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`1(Peasants must not to talk)", 0, true);
										continue;
									}
									SendChat(peer, static_cast<PlayerInfo*>(peer->data)->netID, word);
									continue;
								} else {
									static_cast<PlayerInfo*>(peer->data)->taped = false;
									static_cast<PlayerInfo*>(peer->data)->isDuctaped = false;
									static_cast<PlayerInfo*>(peer->data)->cantsay = false;
									send_state(peer);
									sendClothes(peer);
								}
							}
						}
						if (str == "/ghost") {
							if (!isMod(peer)) {
								sendWrongCmd(peer);
								continue;
							}
							SendGhost(peer);
						} else if (str == "/mods") {
							string x;
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
								if (isMod(currentPeer) && !static_cast<PlayerInfo*>(currentPeer->data)->isinv && !static_cast<PlayerInfo*>(currentPeer->data)->isNicked) x.append("" + static_cast<PlayerInfo*>(currentPeer->data)->displayName + "`w, ");
							}
							x = x.substr(0, x.length() - 2);
							if (x == "") x = "(All are hidden)";
							Player::OnConsoleMessage(peer, "`oMods online: " + x);
						} else if (str == "/go") {
							if (static_cast<PlayerInfo*>(peer->data)->isCursed == true) continue;
							if (static_cast<PlayerInfo*>(peer->data)->lastSbbWorld == "") {
								Player::OnTextOverlay(peer, "Unable to track down the location of the message.");
								continue;
							} 
							if (static_cast<PlayerInfo*>(peer->data)->lastSbbWorld == static_cast<PlayerInfo*>(peer->data)->currentWorld) {
								Player::OnTextOverlay(peer, "Sorry, but you are already in the world!");
								continue;
							}
							handle_world(peer, static_cast<PlayerInfo*>(peer->data)->lastSbbWorld);
						} else if (str == "/online") {
							if (!isMod(peer)) {
								sendWrongCmd(peer);
								continue;
							}
							string online = "";
							int total = 0;
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
								if (static_cast<PlayerInfo*>(currentPeer->data)->adminLevel >= 0 && static_cast<PlayerInfo*>(currentPeer->data)->isinv == false) {
									if (static_cast<PlayerInfo*>(currentPeer->data)->displayName == "" || static_cast<PlayerInfo*>(currentPeer->data)->rawName == "") continue;
									online += static_cast<PlayerInfo*>(currentPeer->data)->displayName + "`o ";
									total++;
								}
							}
							Player::OnConsoleMessage(peer, "Currently online players " + online);
						} else if (str == "/kickall") {
								if (isMod(peer) || static_cast<PlayerInfo*>(peer->data)->rawName == world->owner)
								{
									ENetPeer* currentPeer;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
											continue;
										if (isHere(peer, currentPeer))
										{
											if (static_cast<PlayerInfo*>(currentPeer->data)->rawName != world->owner)
											{
												GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`@You have been kicked by `2" + static_cast<PlayerInfo*>(peer->data)->rawName + "!"));
												ENetPacket* packet = enet_packet_create(p.data,
													p.len,
													ENET_PACKET_FLAG_RELIABLE);
												enet_peer_send(currentPeer, 0, packet);
												delete p.data;
												playerRespawn(world, currentPeer, false);
											}
										}
									}
								}
								else
								{
									sendWrongCmd(peer);
									continue;
								}
							}
							else if (str.substr(0, 6) == "/pull ") {
								if (static_cast<PlayerInfo*>(peer->data)->rawName != world->owner && !isMod(peer)) continue;
								string pull_name = PlayerDB::getProperName(str.substr(6, cch.length() - 6 - 1));
								if (pull_name.size() < 3) {
									Player::OnConsoleMessage(peer, "You'll need to enter at least the first three characters of the person's name.");
									continue;
								}
								bool Found = false, Block = false;
								int Same_name = 0, Sub_worlds_name = 0;
								string Intel_sense_nick = "";
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
									if (isHere(peer, currentPeer)) {
										if (getStrLower(static_cast<PlayerInfo*>(currentPeer->data)->displayName).find(getStrLower(pull_name)) != string::npos) Same_name++;
									} else if (isMod(peer)) {
										if (getStrLower(static_cast<PlayerInfo*>(currentPeer->data)->displayName).find(getStrLower(pull_name)) != string::npos) Sub_worlds_name++;
									}
								}
								if (Same_name > 1) {
									Player::OnConsoleMessage(peer, "`oThere are more than two players in this world starting with " + pull_name + " `obe more specific!");
									continue;
								}
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
									if (isHere(peer, currentPeer) && getStrLower(static_cast<PlayerInfo*>(currentPeer->data)->displayName).find(getStrLower(pull_name)) != string::npos) {
										if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == static_cast<PlayerInfo*>(peer->data)->rawName) {
											Player::OnConsoleMessage(peer, "Ouch!");
											Block = true;
											break;
										}
										Found = true;
										Intel_sense_nick = static_cast<PlayerInfo*>(currentPeer->data)->displayName;
										PlayerMoving data;
										data.packetType = 0x0;
										data.characterState = 0x924;
										data.x = static_cast<PlayerInfo*>(peer->data)->x;
										data.y = static_cast<PlayerInfo*>(peer->data)->y;
										data.punchX = -1;
										data.punchY = -1;
										data.XSpeed = 0;
										data.YSpeed = 0;
										data.netID = static_cast<PlayerInfo*>(currentPeer->data)->netID;
										data.plantingTree = 0x0;
										SendPacketRaw(4, packPlayerMoving(&data), 56, nullptr, currentPeer, ENET_PACKET_FLAG_RELIABLE);
										GamePacket p2 = packetEnd(appendFloat(appendString(createPacket(), "OnSetPos"), static_cast<PlayerInfo*>(peer->data)->x, static_cast<PlayerInfo*>(peer->data)->y));
										memcpy(p2.data + 8, &(static_cast<PlayerInfo*>(currentPeer->data)->netID), 4);
										ENetPacket* packet2 = enet_packet_create(p2.data, p2.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeer, 0, packet2);
										delete p2.data;
										if (isWorldOwner(peer, world)) Player::OnTextOverlay(currentPeer, "You were pulled by " + static_cast<PlayerInfo*>(peer->data)->displayName + "");
										else if (isMod(peer)) Player::OnTextOverlay(currentPeer, "You were summoned by a mod");
										break;
									} 
								}
								if (Block) continue;
								if (!Found && isMod(peer)) {
									if (Sub_worlds_name > 1) {
										Player::OnConsoleMessage(peer, "`oThere are more than two players in the server starting with " + pull_name + " `obe more specific!");
										continue;
									}
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
										if (getStrLower(static_cast<PlayerInfo*>(currentPeer->data)->displayName).find(getStrLower(pull_name)) != string::npos) {
											Found = true;
											Intel_sense_nick = static_cast<PlayerInfo*>(currentPeer->data)->displayName;
											handle_world(currentPeer, static_cast<PlayerInfo*>(peer->data)->currentWorld, false, false, "", true, static_cast<PlayerInfo*>(peer->data)->x, static_cast<PlayerInfo*>(peer->data)->y);
											Player::OnTextOverlay(currentPeer, "You were summoned by a mod");
											break;
										}
									}
								}
								if (Found) {
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
										if (isHere(peer, currentPeer)) {
											Player::PlayAudio(currentPeer, "audio/object_spawn.wav", 0);
											Player::OnConsoleMessage(currentPeer, "`o" + static_cast<PlayerInfo*>(peer->data)->displayName + " `5pulls `o" + Intel_sense_nick + "`o!");
										}
									}
								} else {
									if (isMod(peer)) {
										Player::OnConsoleMessage(peer, "`4Oops:`` There is nobody currently in this server with a name starting with `w" + pull_name + "``.");
									} else {
										Player::OnConsoleMessage(peer, "`4Oops:`` There is nobody currently in this world with a name starting with `w" + pull_name + "``.");
									}
								}
							}
							else if (str.substr(0, 4) == "/me ")
							{
								if (world->silence == true && !isWorldOwner(peer, world))
								{
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`1(Peasants must not to talk)", 0, true);
									continue;
								}
								if (static_cast<PlayerInfo*>(peer->data)->isDuctaped == false && static_cast<PlayerInfo*>(peer->data)->haveGrowId == true)
								{
									string namer = static_cast<PlayerInfo*>(peer->data)->displayName;
									GamePacket p2 = packetEnd(appendIntx(appendString(appendIntx(appendString(createPacket(), "OnTalkBubble"), static_cast<PlayerInfo*>(peer->data)->netID), "`#<`w" + namer + " `#" + str.substr(3, cch.length() - 3 - 1).c_str() + "`5>"), 0));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									GamePacket p3 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`w<" + namer + " `#" + str.substr(3, cch.length() - 3 - 1).c_str() + "`w>"));
									ENetPacket* packet3 = enet_packet_create(p3.data,
										p3.len,
										ENET_PACKET_FLAG_RELIABLE);
									ENetPeer* currentPeer;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
											continue;
										if (isHere(peer, currentPeer))
										{
											enet_peer_send(currentPeer, 0, packet2);
											enet_peer_send(currentPeer, 0, packet3);
										}
									}
									delete p2.data;
									delete p3.data;
									continue;
								}
							}
							else if (str.substr(0, 6) == "/warn ") {
								if (!isMod(peer)) {
									sendWrongCmd(peer);
									continue;
								}
								string warn_info = str;
								size_t extra_space = warn_info.find("  ");
								if (extra_space != std::string::npos) warn_info.replace(extra_space, 2, " ");
								string delimiter = " ";
								size_t pos = 0;
								string warn_user;
								string warn_message;
								if ((pos = warn_info.find(delimiter)) != std::string::npos) warn_info.erase(0, pos + delimiter.length());
								else continue;
								if ((pos = warn_info.find(delimiter)) != std::string::npos) {
									warn_user = warn_info.substr(0, pos);
									warn_info.erase(0, pos + delimiter.length());
								}
								else continue;
								warn_message = warn_info;
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
									if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == warn_user) {
										Player::OnAddNotification(currentPeer, "`wWarning from `4System`w: " + warn_message + "", "audio/hub_open.wav", "interface/atomic_button.rttex");
										Player::OnConsoleMessage(currentPeer, "`oWarning from `4System`o: " + warn_message + "");
										MYSQL_ROW row;
										string q = "SELECT * FROM PlayerDatabase WHERE username = '" + PlayerDB::getProperName(warn_user) + "' LIMIT 1";
										string account_history;
										mysql_query(conn, q.c_str());
										res = mysql_store_result(conn);
										while (row = mysql_fetch_row(res)) {
											account_history = row[68];
										}
										//if (res) mysql_free_result(res);
										time_t currentTime;
										time(&currentTime);
										const auto localTime = localtime(&currentTime);
										const auto Hour = localTime->tm_hour;
										const auto Min = localTime->tm_min;
										const auto Sec = localTime->tm_sec;
										const auto Year = localTime->tm_year + 1900;
										const auto Day = localTime->tm_mday;
										const auto Month = localTime->tm_mon + 1;
										account_history += "" + to_string(Month) + "/" + to_string(Day) + "/" + to_string(Year) + " " + to_string(Hour) + ":" + to_string(Min) + ":" + to_string(Sec) + ": " + static_cast<PlayerInfo*>(peer->data)->rawName + " - >> Warning: " + warn_message + "|";
										string string = "UPDATE PlayerDatabase SET accountnotes = '" + account_history + "' WHERE username = '" + PlayerDB::getProperName(warn_user) + "' LIMIT 1";
										mysql_query(conn, string.c_str());
										break;
									}
								}
								Player::OnConsoleMessage(peer, "Warning sent (only works if the player is online)");
							}
							else if (str == "/rules") {
								Player::OnDialogRequest(peer, "set_default_color|`o\nadd_label_with_icon|big|`wHelp & Rules``|left|18|\nadd_spacer|small|\nadd_textbox|`wTo keep this place fun we've got some ground rules to check out:``|left|\nadd_spacer|small|\nadd_label_with_icon|small|`wKeep your password secret. Sharing your password will result in stolen items.``|left|24|\nadd_label_with_icon|small|`wUnprotected items are at risk of being stolen. Use doors, locks, and blocks wisely to protect your items.``|left|24|\nadd_label_with_icon|small|`wWe cannot return stolen items, so BE CAREFUL!``|left|24|\nadd_label_with_icon|small|`wBe civil. Bullying, racism, excessive profanity, sexual content, and abusive behavior are not allowed.``|left|24|\nadd_label_with_icon|small|`wPlayers that are harmful to the community may be banned. This includes accounts that use lies, fake games, or trickery to mistreat other players.``|left|24|\nadd_label_with_icon|small|`wPunishments may be applied to alt accounts as well as any devices and IP addresses used by the offender.``|left|24|\nadd_label_with_icon|small|`wTrying to get punished or asking for a punishment can earn you a worse punishment.``|left|24|\nadd_label_with_icon|small|`w'Hacking' the game - including client-side manipulation, auto-clickers, speed hacks, clock manipulation, bots, macroing, and autofarming - will result in a ban.``|left|24|\nadd_label_with_icon|small|`wDon't lie about mods or fake official Growtopia system messages.``|left|24|\nadd_label_with_icon|small|`w'Drop games' are illegal scams. You can be punished for hosting, playing, advertising or even watching.``|left|24|\nadd_label_with_icon|small|`wBetting or gambling (asking players to pay for a chance to win something) is not allowed.``|left|24|\nadd_label_with_icon|small|`wIf you find a world or player name that is in violation of our rules, message a @Mod. Do not /bc or /sb from an inappropriate world.``|left|24|\nadd_label_with_icon|small|`w@Moderators are here to enforce the rules. Abusing, spamming or harassing mods will have consequences.``|left|24|\nadd_label_with_icon|small|`wAccounts, locks, or worlds may be deleted after long periods of inactivity.``|left|24|\nadd_label_with_icon|small|`wOut of game buying/selling of Growtopia accounts, items or worlds is not allowed and may result in a ban.``|left|24|\nadd_label_with_icon|small|`wIAP fraud will result in permanent suspension.``|left|24|\nadd_label_with_icon|small|`wItem function and prices are subject to change without warning.``|left|24|\nadd_label_with_icon|small|`wYour creations and items could be deleted at any time. We do everything in our power to prevent this, but data loss may happen without warning. Lost items cannot be restored.``|left|24|\nadd_spacer|small|\nadd_label_with_icon|small|`wFor technical support, IAP issues, or to report a problem, please email support@gtosprivate.com``|left|24|\nadd_spacer|small|\nend_dialog|popup||Continue|");
							}
							else if (str.substr(0, 3) == "/r ") {
								if (static_cast<PlayerInfo*>(peer->data)->isDuctaped == true) continue;
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
									if (currentPeer->data == nullptr || currentPeer->data == NULL) {
										SendConsole("currentPeer was nullptr", "ERROR");
										continue;
									}
									if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == static_cast<PlayerInfo*>(peer->data)->lastMsger) {
										static_cast<PlayerInfo*>(currentPeer->data)->lastMsger = static_cast<PlayerInfo*>(peer->data)->rawName;
										Player::OnConsoleMessage(peer, "CP:_PL:0_OID:_CT:[MSG]_ `o(Sent to `$" + static_cast<PlayerInfo*>(currentPeer->data)->displayName + "`o)");
										Player::OnConsoleMessage(currentPeer, "CP:_PL:0_OID:_CT:[MSG]_ `c>> from (`w" + static_cast<PlayerInfo*>(peer->data)->displayName + "`c) in [`o" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "`c] > `o" + str.substr(3, cch.length() - 3 - 1));
										Player::PlayAudio(currentPeer, "audio/pay_time.wav", 0);
										break;
									}
								}
							}
							else if (str == "/rgo") {
								if (static_cast<PlayerInfo*>(peer->data)->isCursed == true) continue;
								if (static_cast<PlayerInfo*>(peer->data)->lastMsgWorld == "") {
									Player::OnTextOverlay(peer, "Unable to track down the location of the message.");
									continue;
								} 
								if (static_cast<PlayerInfo*>(peer->data)->lastMsgWorld == static_cast<PlayerInfo*>(peer->data)->currentWorld) {
									Player::OnTextOverlay(peer, "Sorry, but you are already in the world!");
									continue;
								}
								handle_world(peer, static_cast<PlayerInfo*>(peer->data)->lastMsgWorld);
							}
							else if (str == "/status") {
								Player::OnConsoleMessage(peer, "`w" + static_cast<PlayerInfo*>(peer->data)->displayName + "````'s Status:");
								Player::OnConsoleMessage(peer, "Current world: `w" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "`` (`w" + to_string(static_cast<PlayerInfo*>(peer->data)->x / 32) + "``, `w" + to_string(static_cast<PlayerInfo*>(peer->data)->y / 32) + "``) (`w" + to_string(getPlayersCountInWorld(static_cast<PlayerInfo*>(peer->data)->currentWorld)) + "`` people) Backpack slots: `w" + to_string(static_cast<PlayerInfo*>(peer->data)->currentInventorySize) + "``");
								string visited = "";
								for (int i = 0; i < static_cast<PlayerInfo*>(peer->data)->lastworlds.size(); i++) {
									if (i == static_cast<PlayerInfo*>(peer->data)->lastworlds.size() - 1) {
										visited += "`#" + static_cast<PlayerInfo*>(peer->data)->lastworlds[i] + "``";
									} else {
										visited += "`#" + static_cast<PlayerInfo*>(peer->data)->lastworlds[i] + "``, ";
									}
								}
								Player::OnConsoleMessage(peer, "Last visited: " + visited);
							}
							else if (str.substr(0, 9) == "/setchat ") {
								if (!isDev(peer) && !static_cast<PlayerInfo*>(peer->data)->Subscriber) {
									sendWrongCmd(peer);
									continue;
								}
								string chatcode = (str.substr(9).c_str());
								if (chatcode.size() >= 2 || chatcode.size() <= 0) continue;
								if (chatcode == "o") chatcode = "";
								stringstream basic_stringstream;
								basic_stringstream << "UPDATE PlayerDatabase SET chatcolor = '" + chatcode + "' WHERE username = '" + static_cast<PlayerInfo*>(peer->data)->rawName + "' LIMIT 1";
								const auto cs = basic_stringstream.str();
								const auto string = cs.c_str();
								mysql_query(conn, string);
								static_cast<PlayerInfo*>(peer->data)->chatcolor = chatcode;
								if (chatcode != "") Player::OnConsoleMessage(peer, "`oYour chat color have been changed to `" + chatcode + " color `o!");
								else Player::OnConsoleMessage(peer, "`oYour chat color have been reverted to default!");
							}
							else if (str == "/save") {
  								if (!isDev(peer)) {
                                    sendWrongCmd(peer);
                                    continue;
                                }
                                for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
                                    if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
									GlobalMaintenance = true;
                                    Player::OnConsoleMessage(currentPeer, "`5Server is saving and shutting down... (Maintenance)");
                                    Player::PlayAudio(currentPeer, "audio/boo_pke_warning_light.wav", 0);
									enet_peer_disconnect_later(currentPeer, 0);
                                }
							}
							else if (str.substr(0, 6) == "/give ") {
								if (!isDev(peer)) {
									sendWrongCmd(peer);
									continue;
								}
								string say_info = str;
								size_t extra_space = say_info.find("  ");
								if (extra_space != std::string::npos) say_info.replace(extra_space, 2, " ");
								string delimiter = " ";
								size_t pos = 0;
								string item_id;
								string item_count;
								if ((pos = say_info.find(delimiter)) != std::string::npos) {
									say_info.erase(0, pos + delimiter.length());
								} if ((pos = say_info.find(delimiter)) != std::string::npos) {
									item_id = say_info.substr(0, pos);
									say_info.erase(0, pos + delimiter.length());
								}
								item_count = say_info;
								if (item_id == "" && item_count != "") {
									bool contains_non_int2 = !std::regex_match(item_count, std::regex("^[0-9]+$"));
									if (contains_non_int2 == true) {
										continue;
									}
									if (item_count.length() > 5) {
										Player::OnConsoleMessage(peer, "`oThis item does not exist");
										continue;
									}
									int item_count_give = atoi(item_count.c_str());
									if (item_count_give > maxItems || item_count_give < 0) {
										Player::OnConsoleMessage(peer, "`oThis item does not exist");
										continue;
									}
									Player::OnConsoleMessage(peer, "`oYou got 1 '`$" + getItemDef(item_count_give).name + "`o'.");
									bool success = true;
									SaveItemMoreTimes(item_count_give, 1, peer, success);
									SendTradeEffect(peer, item_count_give, static_cast<PlayerInfo*>(peer->data)->netID, static_cast<PlayerInfo*>(peer->data)->netID, 150);
									continue;
								}
								bool contains_non_int2 = !std::regex_match(item_id, std::regex("^[0-9]+$"));
								if (contains_non_int2 == true) {
									continue;
								}
								PlayerInventory inventory;
								if (item_id.length() > 5) {
									Player::OnConsoleMessage(peer, "`oThis item does not exist");
									continue;
								}
								int item_id_give = atoi(item_id.c_str());
								if (item_id_give > maxItems || item_id_give < 0) {
									Player::OnConsoleMessage(peer, "`oThis item does not exist");
									continue;
								}
								int item_count_give = 1;
								if (item_count != "") {
									bool contains_non_int2 = !std::regex_match(item_count, std::regex("^[0-9]+$"));
									if (contains_non_int2 == true) {
										continue;
									}
									item_count_give = atoi(item_count.c_str());
									if (item_count_give > 250 || item_count_give <= 0) {
										Player::OnConsoleMessage(peer, "`oItem count must be between 0 and 250");
										continue;
									}
								}
								Player::OnConsoleMessage(peer, "`oYou got " + to_string(item_count_give) + " '`$" + getItemDef(item_id_give).name + "`o'.");
								bool success = true;
								SaveItemMoreTimes(item_id_give, item_count_give, peer, success);
								SendTradeEffect(peer, item_id_give, static_cast<PlayerInfo*>(peer->data)->netID, static_cast<PlayerInfo*>(peer->data)->netID, 150);
							}
							else if (str.substr(0, 6) == "/find ") {
								if (!isDev(peer)) {
									sendWrongCmd(peer);
									continue;
								}
								bool ScanNotFull = false;
								string item = (str.substr(6).c_str());
								vector<string> FoundItems;
								int foundkiek = 0;
								for (int i = 0; i < maxItems; i++) {
									string iname = getStrLower(getItemDef(i).name);
									if (iname.find(getStrLower(item)) != string::npos && !isSeed(i)) {
										if (foundkiek >= 100) {
											ScanNotFull = true;
											break;
										}
										foundkiek++;
										FoundItems.push_back("" + to_string(i) + ": " + getItemDef(i).name + "");
									}
								}
								Player::OnConsoleMessage(peer, "Items that matched the criteria:");
								if (FoundItems.size() == 0) {
									Player::OnConsoleMessage(peer, "no items found");
								} else {
									for (int i = 0; i < FoundItems.size(); i++) {
										Player::OnConsoleMessage(peer, FoundItems[i]);
									}
								}
								if (ScanNotFull) Player::OnConsoleMessage(peer, "Aborting search because found over 100+ items");
							}
							else if (str == "/regenerate")
							{
								if (!isDev(peer))
								{
									sendWrongCmd(peer);
									continue;
								}
								remove("pricedata.txt");
								auto itemid = 0;
								auto kaina = 0;
								for (int i = 0; i <= maxItems; i++)
								{
									itemid++;
									if (getItemDef(itemid).blockType == BlockTypes::CLOTHING)
									{
										kaina = -1;
										if (getItemDef(itemid).rarity <= 10) kaina = rand() % 60;
										else if (getItemDef(itemid).rarity <= 20) kaina = rand() % 190;
										else if (getItemDef(itemid).rarity <= 30) kaina = rand() % 250;
										else if (getItemDef(itemid).rarity <= 40) kaina = rand() % 310;
										else if (getItemDef(itemid).rarity <= 50) kaina = rand() % 430;
										else if (getItemDef(itemid).rarity <= 60) kaina = rand() % 660;
										else if (getItemDef(itemid).rarity <= 70) kaina = rand() % 850;
										else if (getItemDef(itemid).rarity <= 80) kaina = rand() % 1100;
										else if (getItemDef(itemid).rarity <= 600) kaina = rand() % 1300;
										else kaina = rand() % 1800;
										if (getItemDef(itemid).clothType == ClothTypes::BACK && getItemDef(itemid).rarity == 999) kaina = rand() % 2900;
										if (getItemDef(itemid).clothType == ClothTypes::SHIRT) kaina = rand() % 160;
										if (getItemDef(itemid).clothType == ClothTypes::HAIR) kaina = rand() % 620;
										if (getItemDef(itemid).clothType == ClothTypes::PANTS) kaina = rand() % 420;
										if (getItemDef(itemid).clothType == ClothTypes::FEET) kaina = rand() % 230;
										if (getItemDef(itemid).clothType == ClothTypes::FACE) kaina = rand() % 690;
										if (getItemDef(itemid).clothType == ClothTypes::HAND && getItemDef(itemid).rarity == 999) kaina = rand() % 2000;
										if (getItemDef(itemid).clothType == ClothTypes::NECKLACE) kaina = rand() % 730;
										if (getItemDef(itemid).clothType == ClothTypes::MASK) kaina = rand() % 680;
										if (getItemDef(itemid).name.find("Cape") != string::npos) kaina = rand() % 470;
										if (getItemDef(itemid).name.find("Riding") != string::npos) kaina = rand() % 1500;
										if (kaina % 10 < 5) kaina = (kaina / 10) * 10;
										else if (kaina % 10 == 5) {
											if (dec > 0) kaina = (((kaina + 10) / 10) * 10);
											else kaina = (kaina / 10) * 10;
										}
										else {
											kaina = (((kaina + 10) / 10) * 10);
										}
										if (kaina == 0) kaina = 10;
										if (itemid == 1966) kaina = 660;
										if (itemid == 1830) kaina = 520;
										if (itemid == 5022) kaina = 760;
										if (itemid == 6300) kaina = 960;
										if (itemid == 2912) kaina = 5;
										if (itemid == 3008) kaina = 75;
										if (itemid == 3010) kaina = 180;
										if (itemid == 5740) kaina = 390;
										ofstream breaklogs("pricedata.txt", ios::app);
										breaklogs << to_string(itemid) + "|" + to_string(kaina) << endl;
										breaklogs.close();
									}
								}
								ENetPeer* currentPeer;
								for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
									Player::OnConsoleMessage(currentPeer, "`5All prices were randomized!");
									Player::PlayAudio(currentPeer, "audio/boo_pke_warning_light.wav", 0);
								}
							}
							else if (str == "/buy")
							{
								Player::OnConsoleMessage(peer, "Usage /buy <name>");
							}
							else if (str.substr(0, 5) == "/buy ")
							{
								if (static_cast<PlayerInfo*>(peer->data)->haveGrowId)
								{
									//Player::OnDialogRequest(peer, "add_label_with_icon|big|`9Item Finder``|left|3146|\nadd_textbox|`^Enter a word below to Find the item!|\nadd_text_input|item|`^Item Name||30|\nend_dialog|findid|Cancel|Find the item!|\nadd_quick_exit|\n");

									string itemFind = str.substr(5, cch.length() - 5 - 1);
									if (itemFind.length() < 3)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wThis item name is too short!``", 0, false);
										break;
									}
								SKIPFinds:;

									string itemLower2;
									vector<ItemDefinition> itemDefsfind;
									for (char c : itemFind) if (c < 0x20 || c > 0x7A) goto SKIPFinds;
									if (itemFind.length() < 3) goto SKIPFinds3;
									for (const ItemDefinition& item : itemDefs)
									{
										string itemLower;
										for (char c : item.name) if (c < 0x20 || c > 0x7A) goto SKIPFinds2;
										if (!(item.id % 2 == 0)) goto SKIPFinds2;
										itemLower2 = item.name;
										std::transform(itemLower2.begin(), itemLower2.end(), itemLower2.begin(), ::tolower);
										if (itemLower2.find(itemLower) != std::string::npos)
										{
											itemDefsfind.push_back(item);
										}
									SKIPFinds2:;
									}
								SKIPFinds3:;
									string listMiddle = "";
									string listFull = "";



									for (const ItemDefinition& item : itemDefsfind)
									{
										if (item.name != "")
										{
											string kys = item.name;
											std::transform(kys.begin(), kys.end(), kys.begin(), ::tolower);
											string kms = itemFind;
											std::transform(kms.begin(), kms.end(), kms.begin(), ::tolower);
											if (kys.find(kms) != std::string::npos)
											{
												int id = item.id;
												int itemid = item.id;
												if (id == 10034 || getItemDef(id).name.find("null") != string::npos || id == 10036 || getItemDef(id).name.find("Mooncake") != string::npos || getItemDef(id).name.find("Harvest") != string::npos && id != 1830 || getItemDef(id).name.find("Autumn") != string::npos || id == 1056 || id == 1804 || getItemDef(id).blockType == BlockTypes::COMPONENT || getItemDef(id).properties & Property_Chemical || id == 6920 || id == 6922 || id == 1874 || id == 1876 || id == 1904 || id == 1932 || id == 1900 || id == 1986 || id == 1996 || id == 2970 || id == 3140 || id == 3174 || id == 6028 || id == 6846 || id == 8962 || id == 2408 || id == 4428 || id == 5086 || id == 9240 || id == 9306 || id == 9290 || id == 7328 || id == 9416 || id == 10386 || id == 9410 || id == 1458 || id == 9408 || id == 9360 || id == 6866 || id == 6868 || id == 6870 || id == 6872 || id == 6874 || id == 6876 || id == 6878 || id == 2480 || id == 8452 || id == 5132 || id == 7166 || id == 5126 || id == 5128 || id == 5130 || id == 5144 || id == 5146 || id == 5148 || id == 5150 || id == 5162 || id == 5164 || id == 5166 || id == 5168 || id == 5180 || id == 5182 || id == 5184 || id == 5186 || id == 7168 || id == 7170 || id == 7172 || id == 7174 || id == 8834 || id == 7912 || id == 9212 || id == 5134 || id == 5152 || id == 5170 || id == 5188 || id == 980 || id == 9448 || id == 9310 || id == 10034 || id == 10036 || id == 8470 || id == 8286 || id == 6026 || id == 1970 || id == 1784 || id == 9356 || id == 10022 || id == 902 || id == 10032 || id == 834 || id == 6 || id == 5640 || id == 9492 || id == 1782 || id == 9288 || id == 1780 || id == 8306 || id == 202 || id == 204 || id == 206 || id == 2950 || id == 4802 || id == 4994 || id == 5260 || id == 5814 || id == 5980 || id == 7734 || id == 2592 || id == 2242 || id == 1794 || id == 1792 || id == 778 || id == 9510 || id == 8774 || id == 2568 || id == 9512 || id == 9502 || id == 9482 || id == 2250 || id == 2248 || id == 2244 || id == 2246 || id == 2286 || id == 9508 || id == 9504 || id == 9506 || id == 274 || id == 276 || id == 9476 || id == 1486 || id == 9498 || id == 4426 || id == 9496 || id == 278 || id == 9490 || id == 2410 || id == 9488 || id == 9452 || id == 9454 || id == 9472 || id == 9456 || id == 732 || id == 9458 || id == 6336 || id == 112 || id == 8 || id == 3760 || getItemDef(id).blockType == BlockTypes::FISH || id == 7372 || id == 9438 || id == 9462 || id == 9440 || id == 9442 || id == 9444 || id == 7960 || id == 7628 || id == 8552) continue;
												if (itemid == 10246 || itemid == 4296 || itemid == 6212 || itemid == 1212 || itemid == 1190 || itemid == 1206 || itemid == 1166 || itemid == 1964 || itemid == 1976 || itemid == 1998 || itemid == 1946 || itemid == 2002 || itemid == 1958 || itemid == 1952 || itemid == 2030 || itemid == 3104 || itemid == 3112 || itemid == 3120 || itemid == 3092 || itemid == 3094 || itemid == 3096 || itemid == 4184 || itemid == 4178 || itemid == 4174 || itemid == 4180 || itemid == 4170 || itemid == 4168 || itemid == 4150 || itemid == 1180 || itemid == 1224 || itemid == 5226 || itemid == 5228 || itemid == 5230 || itemid == 5212 || itemid == 5246 || itemid == 5242 || itemid == 5234 || itemid == 7134 || itemid == 7118 || itemid == 7132 || itemid == 7120 || itemid == 7098 || itemid == 9018 || itemid == 9038 || itemid == 9026 || itemid == 9066 || itemid == 9058 || itemid == 9044 || itemid == 9024 || itemid == 9032 || itemid == 9036 || itemid == 9028 || itemid == 9030 || itemid == 9110 || itemid == 9112 || itemid == 10386 || itemid == 10326 || itemid == 10324 || itemid == 10322 || itemid == 10328 || itemid == 10316 || itemid == 1198 || itemid == 1208 || itemid == 1222 || itemid == 1200 || itemid == 1220 || itemid == 1202 || itemid == 1238 || itemid == 1168 || itemid == 1172 || itemid == 1230 || itemid == 1194 || itemid == 1192 || itemid == 1226 || itemid == 1196 || itemid == 1236 || itemid == 1182 || itemid == 1184 || itemid == 1186 || itemid == 1188 || itemid == 1170 || itemid == 1212 || itemid == 1214 || itemid == 1232 || itemid == 1178 || itemid == 1234 || itemid == 1250 || itemid == 1956 || itemid == 1990 || itemid == 1968 || itemid == 1960 || itemid == 1948 || itemid == 1966 || itemid == 3114 || itemid == 3118 || itemid == 3100 || itemid == 3122 || itemid == 3124 || itemid == 3126 || itemid == 3108 || itemid == 3098 || itemid == 1962 || itemid == 2000 || itemid == 1970 || itemid == 4186 || itemid == 4188 || itemid == 4246 || itemid == 4248 || itemid == 4192 || itemid == 4156 || itemid == 4136 || itemid == 4152 || itemid == 4166 || itemid == 4190 || itemid == 4172 || itemid == 4182 || itemid == 4144 || itemid == 4146 || itemid == 4148 || itemid == 4140 || itemid == 4138 || itemid == 4142 || itemid == 5256 || itemid == 5208 || itemid == 5216 || itemid == 5218 || itemid == 5220 || itemid == 5214 || itemid == 5210 || itemid == 5254 || itemid == 5250 || itemid == 5252 || itemid == 5244 || itemid == 5236 || itemid == 7104 || itemid == 7124 || itemid == 7122 || itemid == 7102 || itemid == 7100 || itemid == 7126 || itemid == 7104 || itemid == 7124 || itemid == 7122 || itemid == 7102 || itemid == 7100 || itemid == 9048 || itemid == 9056 || itemid == 9114 || itemid == 9034 || itemid == 1210 || itemid == 1216 || itemid == 1218 || itemid == 1992 || itemid == 1982 || itemid == 1994 || itemid == 1972 || itemid == 1980 || itemid == 1988 || itemid == 1984 || itemid == 3116 || itemid == 3102 || itemid == 3106 || itemid == 3110 || itemid == 4160 || itemid == 4162 || itemid == 4164 || itemid == 4154 || itemid == 4158 || itemid == 5224 || itemid == 5222 || itemid == 5232 || itemid == 5240 || itemid == 5248 || itemid == 5238 || itemid == 5256 || itemid == 7116 || itemid == 7108 || itemid == 7110 || itemid == 7128 || itemid == 7112 || itemid == 7114 || itemid == 7130) continue;
												if (itemid == 6398 || itemid == 6426 || itemid == 6340 || itemid == 6342 || itemid == 6350 || itemid == 6818 || itemid == 8244 || itemid == 8242 || itemid == 8240 || itemid == 8452 || itemid == 8454 || itemid == 8488 || itemid == 8498 || itemid == 8474 || itemid == 8476 || itemid == 8492 || itemid == 1498 || itemid == 1500 || itemid == 2804 || itemid == 2806 || itemid == 8270 || itemid == 8272 || itemid == 8274 || itemid == 3172 || itemid == 8478 || itemid == 8480 || itemid == 8486 || itemid == 8484 || itemid == 8482 || itemid == 8468 || itemid == 8494 || itemid == 8466 || itemid == 8490 || itemid == 8456 || itemid == 8458 || itemid == 8496 || itemid == 8472 || itemid == 5482 || itemid == 2240 || itemid == 3204 || itemid == 6114 || itemid == 4328 || itemid == 4326 || itemid == 4330 || itemid == 4324 || itemid == 4334 || itemid == 1242 || itemid == 1244 || itemid == 1246 || itemid == 1248 || itemid == 1282 || itemid == 1284 || itemid == 1286 || itemid == 1290 || itemid == 1288 || itemid == 1292 || itemid == 1294 || itemid == 1256 || itemid == 2586 || itemid == 782 || itemid == 3536 || itemid == 764 || itemid == 4176 || itemid == 4322 || itemid == 4080 || itemid == 2992 || itemid == 2976 || itemid == 3790 || itemid == 4990 || itemid == 1506 || itemid == 1274 || itemid == 9000 || itemid == 1252 || itemid == 8284 || itemid == 8954 || itemid == 8534 || itemid == 1460 || itemid == 1462 || itemid == 1466 || itemid == 1464 || itemid == 2386 || itemid == 2392 || itemid == 2394 || itemid == 4414 || itemid == 4420 || itemid == 4428 || itemid == 4426 || itemid == 5662 || itemid == 5642 || itemid == 5654 || itemid == 5646 || itemid == 5650 || itemid == 7828 || itemid == 7832 || itemid == 7834 || itemid == 9322 || itemid == 9344 || itemid == 9326 || itemid == 9316 || itemid == 9318 || itemid == 362 || itemid == 3398 || itemid == 386 || itemid == 4422 || itemid == 364 || itemid == 9340 || itemid == 9342 || itemid == 9332 || itemid == 9334 || itemid == 9336 || itemid == 9338 || itemid == 366 || itemid == 2388 || itemid == 7808 || itemid == 7810 || itemid == 4416 || itemid == 7818 || itemid == 7820 || itemid == 5652 || itemid == 7822 || itemid == 7824 || itemid == 5644 || itemid == 390 || itemid == 7826 || itemid == 7830 || itemid == 9324 || itemid == 5658 || itemid == 3396 || itemid == 2384 || itemid == 5660 || itemid == 3400 || itemid == 4418 || itemid == 4412 || itemid == 388 || itemid == 3408 || itemid == 1470 || itemid == 3404 || itemid == 3406 || itemid == 2390 || itemid == 5656 || itemid == 5648 || itemid == 2396 || itemid == 384 || itemid == 5664 || itemid == 4424 || itemid == 4400 || itemid == 9350 || itemid == 5040 || itemid == 5042 || itemid == 5044 || itemid == 392 || itemid == 3402 || itemid == 5032 || itemid == 5034 || itemid == 5036 || itemid == 5038 || itemid == 5018 || itemid == 5022 || itemid == 5060 || itemid == 5054 || itemid == 5058 || itemid == 5056 || itemid == 5050 || itemid == 5046 || itemid == 5052 || itemid == 5048 || itemid == 5070 || itemid == 5072 || itemid == 5074 || itemid == 5076 || itemid == 5066 || itemid == 5062 || itemid == 5068 || itemid == 5064 || itemid == 5080 || itemid == 5082 || itemid == 5084 || itemid == 5078 || itemid == 10236 || itemid == 10232 || itemid == 10194 || itemid == 10206 || itemid == 10184 || itemid == 10192 || itemid == 10190 || itemid == 10186 || itemid == 10212 || itemid == 10214 || itemid == 10216 || itemid == 10220 || itemid == 10222 || itemid == 10224 || itemid == 10226 || itemid == 10208 || itemid == 10210 || itemid == 10218 || itemid == 10196 || itemid == 10198 || itemid == 10200 || itemid == 10202 || itemid == 10204) continue;
												listMiddle += "add_button_with_icon|tool" + to_string(item.id) + "|`$" + item.name + "``|left|" + to_string(item.id) + "||\n";
											}
										}
									}
									if (itemFind.length() < 3)
									{
										listFull = "add_textbox|`4Word is less then 3 letters!``|\nadd_spacer|small|\n";

										showWrong(peer, listFull, itemFind);
									}
									else if (itemDefsfind.size() == 0)
									{
										//listFull = "add_textbox|`4Found no item match!``|\nadd_spacer|small|\n";
										showWrong(peer, listFull, itemFind);
									}
									else
									{
										if (listMiddle.size() == 0)
										{
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wNo items were found with that name!``", 0, false);
										}
										else
										{
											GamePacket fff = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "add_label_with_icon|big|`wFound item : " + itemFind + "``|left|6016|\nadd_spacer|small|\nend_dialog|findid|Cancel|\nadd_spacer|big|\n" + listMiddle + "add_quick_exit|\n"));
											ENetPacket* packetd = enet_packet_create(fff.data,
												fff.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packetd);

											//enet_host_flush(server);
											delete fff.data;
										}
									}
								}
							}
							else if (str == "/help" || str == "/?") {
								if (isDev(peer)) {
									Player::OnConsoleMessage(peer, "`o>> Commands: /regenerate /buy /find /ghost /mods /setchat /save /redeem /go /online /kickall /status /pull /me /warn /rules /r /rgo /give /warpto /warp /banworld /ssb /ban /pban /suspend /spk /unmute /mute /curse /time /uncurse /unban /msg /uba /gsm /info /infoex /banip /nick /invis /giverank /delstatus /jsb /sb /schat /sdb /g /radio /color /who /wave /dance /love /sleep /fp /yes /no /omg /idk /furious /rolleyes /fold /dab /sassy /dance2");
								} else if (isMod(peer)) {
									Player::OnConsoleMessage(peer, "`o>> Commands: /buy /ghost /mods /redeem /go /online /kickall /status /pull /me /warn /rules /r /rgo /warpto /warp /banworld /ssb /ban /pban /spk /mute /curse /time /msg /uba /info /infoex /nick /invis /jsb /sb /schat /sdb /g /radio /color /who /wave /dance /love /sleep /fp /yes /no /omg /idk /furious /rolleyes /fold /dab /sassy /dance2");
								} else if (static_cast<PlayerInfo*>(peer->data)->Subscriber) {
									Player::OnConsoleMessage(peer, "`o>> Commands: /buy /mods /go /setchat /invis /jsb /redeem /kickall /pull /me /rules /status /r /rgo /warp /ssb /ban /time /msg /uba /sb /sdb /g /radio /who /wave /dance /love /sleep /fp /yes /no /omg /idk /furious /rolleyes /fold /dab /sassy /dance2");
								} else {
									Player::OnConsoleMessage(peer, "`o>> Commands: /buy /mods /go /redeem /kickall /pull /me /rules /status /r /rgo /warp /ssb /ban /time /msg /uba /sb /sdb /g /radio /who /wave /dance /love /sleep /fp /yes /no /omg /idk /furious /rolleyes /fold /dab /sassy /dance2");
								}
							}
							else if (str.substr(0, 8) == "/redeem ") {
								MYSQL_ROW row;
								string code = (str.substr(8).c_str());
								string q = "SELECT * FROM Redeem WHERE code = '" + code + "' LIMIT 1";
								if (mysql_query(conn, q.c_str())) {
									cout << mysql_error(conn) << endl;
									continue;
								}
								string key, contains, activated, itemid, itemcount;
								res = mysql_store_result(conn);
								while (row = mysql_fetch_row(res)) {
									key = row[1];
									contains = row[2];
									activated = row[3];
									itemid = row[6];
									itemcount = row[7];
								}
								//if (res) mysql_free_result(res);
								if (code.size() <= 3 || code.size() >= 30) continue;
								if (code == key && activated == "false") {
									q = "UPDATE Redeem SET activated = 'true', activatedby = '" + static_cast<PlayerInfo*>(peer->data)->rawName + "' WHERE code = '" + code + "'";
									if (mysql_query(conn, q.c_str())) {
										cout << mysql_error(conn) << endl;
										continue;
									}
									if (contains == "modrank" || contains == "devrank") {
										string type, prefix, fullname;
										if (contains == "modrank") {
											type = "mod";
											prefix = "`#@";
											fullname = "Moderator";
										} else if (contains == "devrank") {
											type = "dev";
											prefix = "`6@";
											fullname = "Developer";
										}
										bool success = true;
										GiveRank(type, static_cast<PlayerInfo*>(peer->data)->rawName, success);
										string name2 = prefix + static_cast<PlayerInfo*>(peer->data)->tankIDName;
										GamePacket p7 = packetEnd(appendString(appendString(createPacket(), "OnNameChanged"), name2));
										memcpy(p7.data + 8, &(static_cast<PlayerInfo*>(peer->data)->netID), 4);
										static_cast<PlayerInfo*>(peer->data)->displayName = name2;
										ENetPacket* packet7 = enet_packet_create(p7.data, p7.len, ENET_PACKET_FLAG_RELIABLE);
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
											if (isHere(peer, currentPeer)) {
												enet_peer_send(currentPeer, 0, packet7);
											}
										}
										delete p7.data;
										Player::OnConsoleMessage(peer, "`oYou have obtained `$" + fullname + " `oHow awesome!");
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wYou have obtained `2" + fullname + " `wHow awesome!", 0, true);
										continue;
									} else if (contains == "randitem") {
										bool success = true;
										SaveItemMoreTimes(atoi(itemid.c_str()), atoi(itemcount.c_str()), peer, success, static_cast<PlayerInfo*>(peer->data)->rawName + " from redeem");
										SendTradeEffect(peer, atoi(itemid.c_str()), static_cast<PlayerInfo*>(peer->data)->netID, static_cast<PlayerInfo*>(peer->data)->netID, 150);
										Player::OnConsoleMessage(peer, "`oYou have obtained `$" + itemcount + " " + getItemDef(atoi(itemid.c_str())).name + " `oHow awesome!");
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wYou have obtained `2" + itemcount + " " + getItemDef(atoi(itemid.c_str())).name + " `wHow awesome!", 0, true);
										continue;
									}
								} else {
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wSeems like that didnt work maybe try another one?", 0, true);
								}
							}
							else if (str.substr(0, 8) == "/warpto ") {
								if (!isMod(peer)) {
									sendWrongCmd(peer);
									continue;
								}
								if (static_cast<PlayerInfo*>(peer->data)->isCursed == true) continue;
								if (str.substr(8, cch.length() - 8 - 1) == "") continue;
								string name = str.substr(8, str.length());
								bool found = false;
								bool inExit = false;
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
									string name2 = static_cast<PlayerInfo*>(currentPeer->data)->rawName;
									std::transform(name.begin(), name.end(), name.begin(), ::tolower);
									std::transform(name2.begin(), name2.end(), name2.begin(), ::tolower);
									if (name == name2) {
										if (static_cast<PlayerInfo*>(currentPeer->data)->currentWorld == "EXIT") {
											inExit = true;
											break;
										}
										handle_world(peer, static_cast<PlayerInfo*>(currentPeer->data)->currentWorld);
										found = true;
									}
								} if (found) {
									Player::OnConsoleMessage(peer, "Teleporting to " + name + "");
								} else if (inExit) {
									Player::OnConsoleMessage(peer, "" + name + " isnt in a world");
								} else {
									Player::OnConsoleMessage(peer, "" + name + " is offline");
								}
							} else if (str.substr(0, 6) == "/warp ") {
								if (static_cast<PlayerInfo*>(peer->data)->isCursed) continue;
								string worldname = str.substr(6, str.length());
								toUpperCase(worldname);
								Player::OnConsoleMessage(peer, "Warping to world " + worldname + ".");
								handle_world(peer, worldname);
							} else if (str == "/banworld") {
								if (!isMod(peer)) {
									sendWrongCmd(peer);
									continue;
								}
								if (world->isNuked) {
									world->isNuked = false;
									Player::OnTextOverlay(peer, "World have been unbanned");
								} else {
									world->isNuked = true;
									Player::OnTextOverlay(peer, "World have been banned");
									string name = static_cast<PlayerInfo*>(peer->data)->displayName;
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
										if (static_cast<PlayerInfo*>(currentPeer->data)->radio) { 
											Player::OnConsoleMessage(currentPeer, "`o>>`4" + world->name + " `4was nuked from orbit`o. It's the only way to be sure. Play nice, everybody!");
											Player::PlayAudio(currentPeer, "audio/bigboom.wav", 0);
										}
										if (isHere(peer, currentPeer)) {
											if (!isMod(currentPeer)) {
												sendPlayerLeave(currentPeer);
												static_cast<PlayerInfo*>(currentPeer->data)->currentWorld = "EXIT";
												sendWorldOffers(currentPeer);
											}
										}
									}
								}
							}
							else if (str.substr(0, 5) == "/ssb ")
							{
								using namespace std::chrono;
								if (static_cast<PlayerInfo*>(peer->data)->level < 80)
								{
									Player::OnConsoleMessage(peer, "`1You need to be level `@80 `1to do that!");
									continue;
								}
								if (static_cast<PlayerInfo*>(peer->data)->isDuctaped == true)
								{
									GamePacket p0 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4You are muted now!"));
									ENetPacket* packet0 = enet_packet_create(p0.data,
										p0.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet0);
									delete p0.data;
									continue;
								}
								using namespace std::chrono;
								if (static_cast<PlayerInfo*>(peer->data)->lastSSB + 60000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count())
								{
									static_cast<PlayerInfo*>(peer->data)->lastSSB = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
								}
								else
								{
									int kiekDar = (static_cast<PlayerInfo*>(peer->data)->lastSSB + 60000 - (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) / 1000; // jei nedalinti is 1000, tai rodys milisekundem laika, reikia paversti i sekundes
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`9Cooldown `@Please Wait `9" + to_string(kiekDar) + " Seconds `@To Throw Another Broadcast!"));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									//enet_host_flush(server);
									continue;
								}
								string name = static_cast<PlayerInfo*>(peer->data)->displayName;
								Player::OnConsoleMessage(peer, "`2>> `9Special Broadcast sent to all players online`2!");
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "CP:_PL:0_OID:_CT:[SB]_ `#SPEC. BROADCAST ** `#from (`2" + name + "`#) in [`o" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "`#] ** :`o " + str.substr(5, cch.length() - 5 - 1)));
								string text = "action|play_sfx\nfile|audio/double_chance.wav\ndelayMS|0\n";
								BYTE* data = new BYTE[5 + text.length()];
								BYTE zero = 0;
								int type = 3;
								memcpy(data, &type, 4);
								memcpy(data + 4, text.c_str(), text.length());
								memcpy(data + 4 + text.length(), &zero, 1);
								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (!static_cast<PlayerInfo*>(currentPeer->data)->radio)
										continue;
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									ENetPacket* packet2 = enet_packet_create(data,
										5 + text.length(),
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(currentPeer, 0, packet2);
									enet_peer_send(currentPeer, 0, packet);
									static_cast<PlayerInfo*>(currentPeer->data)->lastSbbWorld = static_cast<PlayerInfo*>(peer->data)->currentWorld;
								}
								delete data;
								delete p.data;
								//elete p3.data;
							}
							else if (str.substr(0, 5) == "/ban ") {
								if (static_cast<PlayerInfo*>(peer->data)->rawName == world->owner || isMod(peer)) {
									if (str.substr(5, cch.length() - 5 - 1) == "") continue;
									if (static_cast<PlayerInfo*>(peer->data)->rawName == str.substr(5, cch.length() - 5 - 1)) continue;
									if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "HELL") {
										Player::OnConsoleMessage(peer, "`4You can't ban players in this world.");
										continue;
									}
									string name = static_cast<PlayerInfo*>(peer->data)->displayName;
									string kickname = PlayerDB::getProperName(str.substr(5, cch.length() - 5 - 1));
									for (ENetPeer* currentPeerp = server->peers; currentPeerp < &server->peers[server->peerCount]; ++currentPeerp)
									{
										if (currentPeerp->state != ENET_PEER_STATE_CONNECTED)
											continue;

										if (static_cast<PlayerInfo*>(currentPeerp->data)->rawName == kickname)
										{

											if (isDev(currentPeerp) && static_cast<PlayerInfo*>(currentPeerp->data)->rawName == kickname)
											{
												Player::OnConsoleMessage(peer, "`4You can't ban him!");
												break;
											}
											else
											{
												namespace fs = std::experimental::filesystem;
												if (!fs::is_directory("worldbans/" + world->name) || !fs::exists("worldbans/" + world->name))
												{
													fs::create_directory("worldbans/" + world->name);
													std::ofstream outfile("worldbans/" + world->name + "/" + static_cast<PlayerInfo*>(currentPeerp->data)->rawName);
													outfile << "worldbanned by: " + static_cast<PlayerInfo*>(peer->data)->rawName;
													outfile.close();
												}
												else
												{
													std::ofstream outfile("worldbans/" + world->name + "/" + static_cast<PlayerInfo*>(currentPeerp->data)->rawName);
													outfile << "worldbanned by: " + static_cast<PlayerInfo*>(peer->data)->rawName;
													outfile.close();
												}
												sendPlayerLeave(currentPeerp);
												static_cast<PlayerInfo*>(currentPeerp->data)->currentWorld = "EXIT";
												sendWorldOffers(currentPeerp);

												ENetPeer* currentPeer;
												for (currentPeer = server->peers;
													currentPeer < &server->peers[server->peerCount];
													++currentPeer)
												{
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
														continue;
													if (isHere(peer, currentPeer))
													{

														GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), name + " `4world bans " + "`o" + kickname + " from `w" + world->name + "`o!"));
														string text = "action|play_sfx\nfile|audio/repair.wav\ndelayMS|0\n";
														BYTE* data = new BYTE[5 + text.length()];
														BYTE zero = 0;
														int type = 3;
														memcpy(data, &type, 4);
														memcpy(data + 4, text.c_str(), text.length());
														memcpy(data + 4 + text.length(), &zero, 1);
														ENetPacket* packetsou = enet_packet_create(data,
															5 + text.length(),
															ENET_PACKET_FLAG_RELIABLE);
														ENetPacket* packet = enet_packet_create(p.data,
															p.len,
															ENET_PACKET_FLAG_RELIABLE);
														enet_peer_send(currentPeer, 0, packetsou);
														enet_peer_send(currentPeer, 0, packet);
														delete data;
														delete p.data;
													}
												}
											}
										}
									}
								}
							}
							else if (str.substr(0, 9) == "/suspend ")
							{
								if (!isDev(peer))
								{
									sendWrongCmd(peer);
									continue;
								}
								string warn_info = str;
								size_t extra_space = warn_info.find("  ");
								if (extra_space != std::string::npos)
								{
									warn_info.replace(extra_space, 2, " ");
								}
								string delimiter = " ";
								size_t pos = 0;
								string warn_user;
								string reason;
								if ((pos = warn_info.find(delimiter)) != std::string::npos)
								{
									warn_info.erase(0, pos + delimiter.length());
								}
								else
								{
									Player::OnConsoleMessage(peer, "`@Please specify a `9Player `@You want to `4Suspend`@!");
									continue;
								}
								if ((pos = warn_info.find(delimiter)) != std::string::npos)
								{
									warn_user = warn_info.substr(0, pos);
									warn_info.erase(0, pos + delimiter.length());
								}
								else
								{
									Player::OnConsoleMessage(peer, "`@Please enter your `4Suspend `@Reason!");
									continue;
								}
								reason = warn_info;
								MYSQL_ROW row;
								if (conn == nullptr)
								{
									cout << "null" << endl;
									continue;
								}
								if (conn != nullptr)
								{
									stringstream sse;
									string name;
									string isbanned;
									sse << "SELECT * FROM PlayerDatabase WHERE username = '" + PlayerDB::getProperName(warn_user) + "' LIMIT 1";
									auto query = sse.str();
									auto q = query.c_str();
									if (mysql_query(conn, q))
									{
										cout << mysql_error(conn) << endl;
										


										enet_peer_disconnect_later(peer, 0);
										continue;
									}
									res = mysql_store_result(conn);
									while (row = mysql_fetch_row(res))
									{
										name = row[1];
										isbanned = row[14];
									}
									//if (res) mysql_free_result(res);
									if (name.length() > 0)
									{
									}
									else
									{
										Player::OnConsoleMessage(peer, "Player does not exist!");
										continue;
									}
									if (isbanned == "1")
									{
										Player::OnConsoleMessage(peer, "This player is already banned!");
										continue;
									}
								}
								else
								{
									continue;
								}
								auto qstate = 0;
								if (conn == nullptr)
								{
									cout << "conn was nullptr" << endl;
									continue;
								}
								if (conn != nullptr)
								{
									stringstream ss;
									ss << "UPDATE PlayerDatabase SET isBanned = '1' WHERE username = '" + PlayerDB::getProperName(warn_user) + "'";
									auto query = ss.str();
									const auto q = query.c_str();
									if (mysql_query(conn, q))
									{
										cout << mysql_error(conn) << endl;
										


										enet_peer_disconnect_later(peer, 0);
										continue;
									}
								}
								SendConsole("" + PlayerDB::getProperName(warn_user) + " for permanent reason " + reason + " banned by " + static_cast<PlayerInfo*>(peer->data)->rawName + "", "BAN");
								ENetPeer* currentPeer;
								bool online = false;
								for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
									Player::OnConsoleMessage(currentPeer, "`#** `$The Ancient Ones `ohave `4banned `w" + PlayerDB::getProperName(warn_user) + " `#** ``(`4/rules `oto see the rules!)");
									if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == warn_user) {
										enet_peer_disconnect_later(currentPeer, 0);
										online = true;
									}
								}
								if (online == false)
								{
									Player::OnConsoleMessage(peer, "User was banned in offline!");
									continue;
								}
								string qss = "SELECT * FROM PlayerDatabase WHERE username = '" + PlayerDB::getProperName(warn_user) + "' LIMIT 1";
								string account_history;
								mysql_query(conn, qss.c_str());
								res = mysql_store_result(conn);
								while (row = mysql_fetch_row(res)) {
									account_history = row[68];
								}
								//if (res) mysql_free_result(res);
								time_t currentTime;
								time(&currentTime);
								const auto localTime = localtime(&currentTime);
								const auto Hour = localTime->tm_hour;
								const auto Min = localTime->tm_min;
								const auto Sec = localTime->tm_sec;
								const auto Year = localTime->tm_year + 1900;
								const auto Day = localTime->tm_mday;
								const auto Month = localTime->tm_mon + 1;
								account_history += "" + to_string(Month) + "/" + to_string(Day) + "/" + to_string(Year) + " " + to_string(Hour) + ":" + to_string(Min) + ":" + to_string(Sec) + ": " + static_cast<PlayerInfo*>(peer->data)->rawName + " - >> Ban permanent (" + reason + ")|";
								string stringsa = "UPDATE PlayerDatabase SET accountnotes = '" + account_history + "' WHERE username = '" + PlayerDB::getProperName(warn_user) + "' LIMIT 1";
								mysql_query(conn, stringsa.c_str());
							}
							else if (str.substr(0, 6) == "/pban ") {
								if (!isMod(peer)) {
									sendWrongCmd(peer);
									continue;
								}
								string ban_info = str;
								size_t extra_space = ban_info.find("  ");
								if (extra_space != std::string::npos) ban_info.replace(extra_space, 2, " ");
								string delimiter = " ";
								size_t pos = 0;
								string ban_user;
								string ban_time;
								string ban_reason;
								if ((pos = ban_info.find(delimiter)) != std::string::npos) ban_info.erase(0, pos + delimiter.length());
								else continue;
								if ((pos = ban_info.find(delimiter)) != std::string::npos) {
									ban_user = ban_info.substr(0, pos);
									ban_info.erase(0, pos + delimiter.length());
								}
								else continue;
								if ((pos = ban_info.find(delimiter)) != std::string::npos) {
									ban_time = ban_info.substr(0, pos);
									ban_info.erase(0, pos + delimiter.length());
								}
								else continue;
								ban_reason = ban_info;
								string user = ban_user;
								string muteTime = ban_time;
								string reason = ban_reason;
								if (reason.length() <= 0) continue;
								if (muteTime.length() > 9) continue;
								bool contains_non_int = !std::regex_match(muteTime, std::regex("^[0-9]+$"));
								if (contains_non_int == true) {
									continue;
								} else {
									int konvertuotasInt = stoi(muteTime);
									if (konvertuotasInt <= 0 || konvertuotasInt > 43200) {
										Player::OnConsoleMessage(peer, "Time cannot must be between 0 and 43200");
										continue;
									} else {
										MYSQL_ROW row;
										string name;
										string q = "SELECT * FROM PlayerDatabase WHERE username = '" + PlayerDB::getProperName(user) + "' LIMIT 1";
										if (mysql_query(conn, q.c_str())) {
											cout << mysql_error(conn) << endl;
											continue;
										}
										res = mysql_store_result(conn);
										while (row = mysql_fetch_row(res)) {
											name = row[1];
										}
										if (name.length() == 0) {
											Player::OnConsoleMessage(peer, "Player does not exist!");
											continue;
										}
										q = "UPDATE PlayerDatabase SET timebanned = '" + to_string((GetCurrentTimeInternalSeconds() + (konvertuotasInt * 60))) + "' WHERE username = '" + PlayerDB::getProperName(user) + "'";
										if (mysql_query(conn, q.c_str())) {
											cout << mysql_error(conn) << endl;
											continue;
										}
										string userdisplay = "";
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
											if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == PlayerDB::getProperName(user)) {
												userdisplay = static_cast<PlayerInfo*>(currentPeer->data)->displayName;
											}
										}
										if (userdisplay == "") userdisplay = user;
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
											Player::OnConsoleMessage(currentPeer, "`#** `$The Ancients `ohave used `#Ban `oon `w" + userdisplay + "`o! `#**");
											if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == PlayerDB::getProperName(user)) {
												Player::OnAddNotification(currentPeer, "`wWarning from `4System`w: You've been `4BANNED `wfrom Growtopia for " + OutputBanTime(konvertuotasInt * 60) + "", "audio/hub_open.wav", "interface/atomic_button.rttex");
												Player::OnConsoleMessage(currentPeer, "`oWarning from `4System`o: You've been `4BANNED `ofrom `wGrowtopia `ofor " + OutputBanTime(konvertuotasInt * 60) + "");
												enet_peer_disconnect_later(currentPeer, 0);
											}
										}
										Player::OnConsoleMessage(peer, "Ban mod applied to " + userdisplay + " (" + OutputBanTime(konvertuotasInt * 60) + ")");
										string qss = "SELECT * FROM PlayerDatabase WHERE username = '" + PlayerDB::getProperName(user) + "' LIMIT 1";
										string account_history;
										mysql_query(conn, qss.c_str());
										res = mysql_store_result(conn);
										while (row = mysql_fetch_row(res)) {
											account_history = row[68];
										}
										time_t currentTime;
										time(&currentTime);
										const auto localTime = localtime(&currentTime);
										const auto Hour = localTime->tm_hour;
										const auto Min = localTime->tm_min;
										const auto Sec = localTime->tm_sec;
										const auto Year = localTime->tm_year + 1900;
										const auto Day = localTime->tm_mday;
										const auto Month = localTime->tm_mon + 1;
										account_history += "" + to_string(Month) + "/" + to_string(Day) + "/" + to_string(Year) + " " + to_string(Hour) + ":" + to_string(Min) + ":" + to_string(Sec) + ": " + static_cast<PlayerInfo*>(peer->data)->rawName + " - >> Ban for " + OutputBanTime(konvertuotasInt * 60) + " (" + reason + ")|";
										string stringsa = "UPDATE PlayerDatabase SET accountnotes = '" + account_history + "' WHERE username = '" + PlayerDB::getProperName(user) + "' LIMIT 1";
										mysql_query(conn, stringsa.c_str());
									}
								}
							}
							else if (str.substr(0, 5) == "/spk ")
							{
								if (!isMod(peer))
								{
									sendWrongCmd(peer);
									continue;
								}
								if (static_cast<PlayerInfo*>(peer->data)->isDuctaped == true)
								{
									GamePacket p0 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4You are muted now!"));
									ENetPacket* packet0 = enet_packet_create(p0.data,
										p0.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet0);
									delete p0.data;
									continue;
								}
								string say_info = str;
								size_t extra_space = say_info.find("  ");
								if (extra_space != std::string::npos)
								{
									say_info.replace(extra_space, 2, " ");
								}
								string delimiter = " ";
								size_t pos = 0;
								string say_user;
								string say_message;
								if ((pos = say_info.find(delimiter)) != std::string::npos)
								{
									say_info.erase(0, pos + delimiter.length());
								}
								else
								{
									GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oPlease enter a player's name."));
									ENetPacket* packet = enet_packet_create(ps.data,
										ps.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete ps.data;
									continue;
								}
								if ((pos = say_info.find(delimiter)) != std::string::npos)
								{
									say_user = say_info.substr(0, pos);
									say_info.erase(0, pos + delimiter.length());
								}
								else
								{
									GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oPlease enter a message."));
									ENetPacket* packet = enet_packet_create(ps.data,
										ps.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete ps.data;
									continue;
								}
								say_message = say_info;
								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == say_user)
									{
										GamePacket p0 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`6>> `2" + say_user + " `6said `2" + say_message));
										ENetPacket* packet0 = enet_packet_create(p0.data,
											p0.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet0);
										delete p0.data;
										SendChat(currentPeer, static_cast<PlayerInfo*>(currentPeer->data)->netID, say_message);
									}
								}
							}
							else if (str.substr(0, 8) == "/unmute ")
							{
								if (!isDev(peer))
								{
									sendWrongCmd(peer);
									continue;
								}
								if (str.substr(8, cch.length() - 8 - 1) == "") continue;
								if (static_cast<PlayerInfo*>(peer->data)->rawName == str.substr(8, cch.length() - 8 - 1)) continue;
								string name = PlayerDB::getProperName(str.substr(8, cch.length() - 8 - 1));
								MYSQL_ROW row;
								stringstream sse;
								sse << "SELECT * FROM PlayerDatabase WHERE username = '" + PlayerDB::getProperName(name) + "' LIMIT 1";
								auto query = sse.str();
								auto q = query.c_str();
								string gamename;
								string timemuted;
								if (mysql_query(conn, q)) {
									cout << mysql_error(conn) << endl;
									
									enet_peer_disconnect_later(peer, 0);
									continue;
								}
								res = mysql_store_result(conn);
								while (row = mysql_fetch_row(res)) {
									gamename = row[1];
									timemuted = row[55];
								}
								//if (res) mysql_free_result(res);
								if (gamename.length() == 0) {
									Player::OnConsoleMessage(peer, "" + PlayerDB::getProperName(name) + " does not exist");
									continue;
								}
								if (timemuted == "0") {
									Player::OnConsoleMessage(peer, "" + PlayerDB::getProperName(name) + " is not banned");
									continue;
								}
								stringstream ss;
								ss << "UPDATE PlayerDatabase SET timemuted = '0' WHERE username = '" + PlayerDB::getProperName(name) + "'";
								auto querys = ss.str();
								const auto qs = querys.c_str();
								if (mysql_query(conn, qs)) {
									cout << mysql_error(conn) << endl;
									
									enet_peer_disconnect_later(peer, 0);
									continue;
								}
								Player::OnConsoleMessage(peer, "Unmuted " + PlayerDB::getProperName(name));
								ENetPeer* currentPeer;
								for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
									if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == name) {
										static_cast<PlayerInfo*>(currentPeer->data)->taped = false;
										static_cast<PlayerInfo*>(currentPeer->data)->isDuctaped = false;
										static_cast<PlayerInfo*>(currentPeer->data)->cantsay = false;
										static_cast<PlayerInfo*>(currentPeer->data)->lastMuted = 0;
										send_state(currentPeer);
										sendClothes(currentPeer);
									}
								}
								string qsa = "SELECT * FROM PlayerDatabase WHERE username = '" + PlayerDB::getProperName(name) + "' LIMIT 1";
								string account_history;
								mysql_query(conn, qsa.c_str());
								res = mysql_store_result(conn);
								while (row = mysql_fetch_row(res)) {
									account_history = row[68];
								}
								//if (res) mysql_free_result(res);
								time_t currentTime;
								time(&currentTime);
								const auto localTime = localtime(&currentTime);
								const auto Hour = localTime->tm_hour;
								const auto Min = localTime->tm_min;
								const auto Sec = localTime->tm_sec;
								const auto Year = localTime->tm_year + 1900;
								const auto Day = localTime->tm_mday;
								const auto Month = localTime->tm_mon + 1;
								account_history += "" + to_string(Month) + "/" + to_string(Day) + "/" + to_string(Year) + " " + to_string(Hour) + ":" + to_string(Min) + ":" + to_string(Sec) + ": " + static_cast<PlayerInfo*>(peer->data)->rawName + " - >> Unmuted|";
								string stringsss = "UPDATE PlayerDatabase SET accountnotes = '" + account_history + "' WHERE username = '" + PlayerDB::getProperName(name) + "' LIMIT 1";
								mysql_query(conn, stringsss.c_str());
							}
							else if (str.substr(0, 6) == "/mute ")
							{
								if (!isMod(peer))
								{
									sendWrongCmd(peer);
									continue;
								}
								string ban_info = str;
								size_t extra_space = ban_info.find("  ");
								if (extra_space != std::string::npos)
								{
									ban_info.replace(extra_space, 2, " ");
								}
								string delimiter = " ";
								size_t pos = 0;
								string ban_user;
								string ban_time;
								string ban_reason;
								if ((pos = ban_info.find(delimiter)) != std::string::npos)
								{
									// npos - jeigu find nieko nerado, ka turejo surasti. Tai cia jei taip neatsitiko, kad nerado nieko, tada else suveikia, jeigu rado ta " " tarpa, tada if
									ban_info.erase(0, pos + delimiter.length());
								}
								else
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`^Usage `2/mute <`^user`2> <`^minutes`2> <`^reason`2>!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
									continue;
								}
								if ((pos = ban_info.find(delimiter)) != std::string::npos)
								{
									ban_user = ban_info.substr(0, pos);
									ban_info.erase(0, pos + delimiter.length());
								}
								else
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`^Usage `2/mute <`^user`2> <`^minutes`2> <`^reason`2>!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
									continue;
								}
								if ((pos = ban_info.find(delimiter)) != std::string::npos)
								{
									ban_time = ban_info.substr(0, pos);
									ban_info.erase(0, pos + delimiter.length());
								}
								else
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`^Usage `2/mute <`^user`2> <`^minutes`2> <`^reason`2>!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
									continue;
								}
								ban_reason = ban_info;
								string user = ban_user;
								string muteTime = ban_time;
								string reason = ban_reason;
								if (reason.length() <= 0)
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`@Reason should not be empty!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
									continue;
								}
								if (muteTime.length() > 9)
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`@Too much symbols!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
									continue;
								}
								bool contains_non_int = !std::regex_match(muteTime, std::regex("^[0-9]+$"));
								if (contains_non_int == true)
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`@Invalid `4Minutes `@Format!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
									continue;
								}
								else
								{
									int konvertuotasInt = stoi(muteTime);
									if (konvertuotasInt <= 0 || konvertuotasInt > 10080) // 10080  - iki 7 dienu
									{
										GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`4Minutes `@Should Be Between `91-10080`@!"));
										ENetPacket* packet2 = enet_packet_create(p2.data,
											p2.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet2);
										delete p2.data;
										continue;
									}
									else
									{
										MYSQL_ROW row;
										if (conn == nullptr)
										{
											cout << "null" << endl;
											continue;
										}
										if (conn != nullptr)
										{
											stringstream sse;
											string name;
											sse << "SELECT * FROM PlayerDatabase WHERE username = '" + PlayerDB::getProperName(user) + "' LIMIT 1";
											auto query = sse.str();
											auto q = query.c_str();
											if (mysql_query(conn, q))
											{
												cout << mysql_error(conn) << endl;
												


												enet_peer_disconnect_later(peer, 0);
												continue;
											}
											res = mysql_store_result(conn);
											while (row = mysql_fetch_row(res))
											{
												name = row[1];
											}
											//if (res) mysql_free_result(res);
											if (name.length() > 0)
											{
											}
											else
											{
												Player::OnConsoleMessage(peer, "Player does not exist!");
												continue;
											}
										}
										else
										{
											continue;
										}

										stringstream ss;
										ss << "UPDATE PlayerDatabase SET timemuted = '" + to_string((GetCurrentTimeInternalSeconds() + (konvertuotasInt * 60))) + "' WHERE username = '" + PlayerDB::getProperName(user) + "'";
										auto query = ss.str();
										const auto q = query.c_str();
										if (mysql_query(conn, q)) {
											cout << mysql_error(conn) << endl;
											
											enet_peer_disconnect_later(peer, 0);
											continue;
										}

										SendConsole("" + user + " for " + to_string(konvertuotasInt) + " reason " + reason + "", "MUTE");
										ENetPeer* currentPeer;
										GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`#** `$The Ancient Ones `ohave used `#Duct Tape ``on `2" + user + "``! `#**"));
										for (currentPeer = server->peers;
											currentPeer < &server->peers[server->peerCount];
											++currentPeer)
										{
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
												continue;
											ENetPacket* packet2 = enet_packet_create(p2.data,
												p2.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeer, 0, packet2);
											if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == PlayerDB::getProperName(user)) {
												using namespace std::chrono;
												static_cast<PlayerInfo*>(currentPeer->data)->taped = true;
												static_cast<PlayerInfo*>(currentPeer->data)->isDuctaped = true;
												static_cast<PlayerInfo*>(currentPeer->data)->cantsay = true;
												static_cast<PlayerInfo*>(currentPeer->data)->lastMuted = (GetCurrentTimeInternalSeconds()) + (konvertuotasInt * 60);
												send_state(currentPeer);
												sendClothes(currentPeer);
												Player::OnAddNotification(currentPeer, "`wWarning from `4System`w: You've been `4MUTED `wfor " + OutputBanTime(konvertuotasInt * 60) + "", "audio/hub_open.wav", "interface/atomic_button.rttex");
												Player::OnConsoleMessage(currentPeer, "`wWarning from `4System`w: You've been `4MUTES `wfor " + OutputBanTime(konvertuotasInt * 60) + "");
											}
										}
										delete p2.data;
										GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oMuted " + user + " for `$" + OutputBanTime(konvertuotasInt * 60) + ""));
										ENetPacket* packet = enet_packet_create(ps.data,
											ps.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete ps.data;
										//MYSQL_ROW row;
										string qsa = "SELECT * FROM PlayerDatabase WHERE username = '" + PlayerDB::getProperName(user) + "' LIMIT 1";
										string account_history;
										mysql_query(conn, qsa.c_str());
										res = mysql_store_result(conn);
										while (row = mysql_fetch_row(res)) {
											account_history = row[68];
										}
										//if (res) mysql_free_result(res);
										time_t currentTime;
										time(&currentTime);
										const auto localTime = localtime(&currentTime);
										const auto Hour = localTime->tm_hour;
										const auto Min = localTime->tm_min;
										const auto Sec = localTime->tm_sec;
										const auto Year = localTime->tm_year + 1900;
										const auto Day = localTime->tm_mday;
										const auto Month = localTime->tm_mon + 1;
										account_history += "" + to_string(Month) + "/" + to_string(Day) + "/" + to_string(Year) + " " + to_string(Hour) + ":" + to_string(Min) + ":" + to_string(Sec) + ": " + static_cast<PlayerInfo*>(peer->data)->rawName + " - >> Mute for " + OutputBanTime(konvertuotasInt * 60) + " (" + reason + ")|";
										string stringsss = "UPDATE PlayerDatabase SET accountnotes = '" + account_history + "' WHERE username = '" + PlayerDB::getProperName(user) + "' LIMIT 1";
										mysql_query(conn, stringsss.c_str());
									}
								}
							}
							else if (str.substr(0, 7) == "/curse ")
							{
								if (!isMod(peer))
								{
									sendWrongCmd(peer);
									continue;
								}
								string ban_info = str;
								size_t extra_space = ban_info.find("  ");
								if (extra_space != std::string::npos)
								{
									ban_info.replace(extra_space, 2, " ");
								}
								string delimiter = " ";
								size_t pos = 0;
								string ban_user;
								string ban_time;
								string ban_reason;
								if ((pos = ban_info.find(delimiter)) != std::string::npos)
								{
									// npos - jeigu find nieko nerado, ka turejo surasti. Tai cia jei taip neatsitiko, kad nerado nieko, tada else suveikia, jeigu rado ta " " tarpa, tada if
									ban_info.erase(0, pos + delimiter.length());
								}
								else
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`^Usage `2/curse <`^user`2> <`^minutes`2> <`^reason`2>!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
									continue;
								}
								if ((pos = ban_info.find(delimiter)) != std::string::npos)
								{
									ban_user = ban_info.substr(0, pos);
									ban_info.erase(0, pos + delimiter.length());
								}
								else
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`^Usage `2/curse <`^user`2> <`^minutes`2> <`^reason`2>!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
									continue;
								}
								if ((pos = ban_info.find(delimiter)) != std::string::npos)
								{
									ban_time = ban_info.substr(0, pos);
									ban_info.erase(0, pos + delimiter.length());
								}
								else
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`^Usage `2/curse <`^user`2> <`^minutes`2> <`^reason`2>!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
									continue;
								}
								ban_reason = ban_info;
								string user = ban_user;
								string muteTime = ban_time;
								string reason = ban_reason;
								if (reason.length() <= 0)
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`@Reason should not be empty!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
									continue;
								}
								if (muteTime.length() > 9)
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`@Too much symbols in minutes!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
									continue;
								}
								bool contains_non_int = !std::regex_match(muteTime, std::regex("^[0-9]+$"));
								if (contains_non_int == true)
								{
									GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`@Invalid `4Minutes `@Format!"));
									ENetPacket* packet2 = enet_packet_create(p2.data,
										p2.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p2.data;
									continue;
								}
								else
								{
									int konvertuotasInt = stoi(muteTime);
									if (konvertuotasInt <= 0 || konvertuotasInt > 43200) // 10080  - iki 7 dienu
									{
										GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnTextOverlay"), "`4Minutes `@Should Be Between `91-43200`@!"));
										ENetPacket* packet2 = enet_packet_create(p2.data,
											p2.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet2);
										delete p2.data;
										continue;
									}
									else
									{
										MYSQL_ROW row;
										if (conn == nullptr)
										{
											cout << "null" << endl;
											continue;
										}
										if (conn != nullptr)
										{
											stringstream sse;
											string name;
											sse << "SELECT * FROM PlayerDatabase WHERE username = '" + PlayerDB::getProperName(user) + "' LIMIT 1";
											auto query = sse.str();
											auto q = query.c_str();
											if (mysql_query(conn, q))
											{
												cout << mysql_error(conn) << endl;
												


												enet_peer_disconnect_later(peer, 0);
												continue;
											}
											res = mysql_store_result(conn);
											while (row = mysql_fetch_row(res))
											{
												name = row[1];
											}
											//if (res) mysql_free_result(res);
											if (name.length() > 0)
											{
											}
											else
											{
												Player::OnConsoleMessage(peer, "Player does not exist!");
												continue;
											}
										}
										else
										{
											continue;
										}
										if (reason.length() < 5)
										{
											AutoDemote(static_cast<PlayerInfo*>(peer->data)->rawName, to_string(static_cast<PlayerInfo*>(peer->data)->adminLevel), to_string(peer->address.host), "warn reason length < 5. He wrote: " + reason);
											continue;
										}
										vector<string> blackWords = { "retard", "bitch", "damn", "fuck", "away", "you", "hello", "lol", "xd", "no", "yes", "what", "go", "noob", "niger", "top", "nigger", "nigga", "niga", "idiot", "shut", "stupid", "why", "gg", "haha", "wtf", "die", "suck", "server", "shut" };
										if (std::find(blackWords.begin(), blackWords.end(), reason) != blackWords.end())
										{
											AutoDemote(static_cast<PlayerInfo*>(peer->data)->rawName, to_string(static_cast<PlayerInfo*>(peer->data)->adminLevel), to_string(peer->address.host), "Found black world in reason. He wrote: " + reason);
											continue;
										}
										using namespace std::chrono;
										if (static_cast<PlayerInfo*>(peer->data)->lastcurse + 180000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count())
										{
											static_cast<PlayerInfo*>(peer->data)->lastcurse = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
											static_cast<PlayerInfo*>(peer->data)->lastcurseCount = 1;
										}
										else
										{
											static_cast<PlayerInfo*>(peer->data)->lastcurseCount = static_cast<PlayerInfo*>(peer->data)->lastcurseCount + 1;
											if (static_cast<PlayerInfo*>(peer->data)->lastcurseCount == 4)
											{
												AutoDemote(static_cast<PlayerInfo*>(peer->data)->rawName, to_string(static_cast<PlayerInfo*>(peer->data)->adminLevel), to_string(peer->address.host), "4 curses in the past 3 minutes! He wrote: " + reason);
												continue;
											}
										}

										stringstream ss;
										ss << "UPDATE PlayerDatabase SET timecursed = '" + to_string((GetCurrentTimeInternalSeconds() + (konvertuotasInt * 60))) + "' WHERE username = '" + PlayerDB::getProperName(user) + "'";
										auto querys = ss.str();
										const auto qs = querys.c_str();
										if (mysql_query(conn, qs)) {
											cout << mysql_error(conn) << endl;
											
											enet_peer_disconnect_later(peer, 0);
											continue;
										}

										SendConsole("" + user + " for " + to_string(konvertuotasInt) + " reason " + reason + "", "CURSE");
									
										ENetPeer* currentPeer;
										GamePacket p2 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`#** `$The Ancient Ones `ohave cursed `2" + user + " ``to the netherworld `#** `o(`4/rules `oto see the rules!)"));
										for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
											ENetPacket* packet2 = enet_packet_create(p2.data,
												p2.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeer, 0, packet2);
											if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == PlayerDB::getProperName(user)) {
												Player::OnAddNotification(currentPeer, "`wWarning from `4System`w: You've been `4CURSED `wfor " + OutputBanTime(konvertuotasInt * 60) + "", "audio/hub_open.wav", "interface/atomic_button.rttex");
												Player::OnConsoleMessage(currentPeer, "`wWarning from `4System`w: You've been `4CURSED `wfor " + OutputBanTime(konvertuotasInt * 60) + "");
												static_cast<PlayerInfo*>(currentPeer->data)->isCursed = true;
												static_cast<PlayerInfo*>(currentPeer->data)->lastCursed = (GetCurrentTimeInternalSeconds() + (konvertuotasInt * 60));
												sendPlayerToWorld(currentPeer, static_cast<PlayerInfo*>(currentPeer->data), "HELL");
											}
										}
										delete p2.data;
										GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`2User `8" + user + " `2 has successfully cursed for `8" + OutputBanTime(konvertuotasInt * 60) + " `2reason`4 " + reason + ""));
										ENetPacket* packet = enet_packet_create(ps.data,
											ps.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete ps.data;
										//MYSQL_ROW row;
										string q = "SELECT * FROM PlayerDatabase WHERE username = '" + PlayerDB::getProperName(user) + "' LIMIT 1";
										string account_history;
										mysql_query(conn, q.c_str());
										res = mysql_store_result(conn);
										while (row = mysql_fetch_row(res)) {
											account_history = row[68];
										}
										//if (res) mysql_free_result(res);
										time_t currentTime;
										time(&currentTime);
										const auto localTime = localtime(&currentTime);
										const auto Hour = localTime->tm_hour;
										const auto Min = localTime->tm_min;
										const auto Sec = localTime->tm_sec;
										const auto Year = localTime->tm_year + 1900;
										const auto Day = localTime->tm_mday;
										const auto Month = localTime->tm_mon + 1;
										account_history += "" + to_string(Month) + "/" + to_string(Day) + "/" + to_string(Year) + " " + to_string(Hour) + ":" + to_string(Min) + ":" + to_string(Sec) + ": " + static_cast<PlayerInfo*>(peer->data)->rawName + " - >> Curse for " + OutputBanTime(konvertuotasInt * 60) + " (" + reason + ")|";
										string string = "UPDATE PlayerDatabase SET accountnotes = '" + account_history + "' WHERE username = '" + PlayerDB::getProperName(user) + "' LIMIT 1";
										mysql_query(conn, string.c_str());
									}
								}
							}
							else if (str == "/time")
							{
								sendTime(peer);
							}
							else if (str.substr(0, 9) == "/uncurse ")
							{
								if (!isDev(peer))
								{
									sendWrongCmd(peer);
									continue;
								}
								if (str.substr(9, cch.length() - 9 - 1) == "") continue;
								if (static_cast<PlayerInfo*>(peer->data)->rawName == str.substr(9, cch.length() - 9 - 1)) continue;
								string cursename = str.substr(9, cch.length() - 9 - 1);
								MYSQL_ROW row;
								stringstream sse;
								sse << "SELECT * FROM PlayerDatabase WHERE username = '" + PlayerDB::getProperName(cursename) + "' LIMIT 1";
								auto query = sse.str();
								auto q = query.c_str();
								string gamename;
								string timecursed;
								if (mysql_query(conn, q)) {
									cout << mysql_error(conn) << endl;
									
									enet_peer_disconnect_later(peer, 0);
									continue;
								}
								res = mysql_store_result(conn);
								while (row = mysql_fetch_row(res)) {
									gamename = row[1];
									timecursed = row[54];
								}
								//if (res) mysql_free_result(res);
								if (gamename.length() == 0) {
									Player::OnConsoleMessage(peer, "" + PlayerDB::getProperName(cursename) + " does not exist");
									continue;
								}
								if (timecursed == "0") {
									Player::OnConsoleMessage(peer, "" + PlayerDB::getProperName(cursename) + " is not cursed");
									continue;
								}
								stringstream ss;
								ss << "UPDATE PlayerDatabase SET timecursed = '0' WHERE username = '" + PlayerDB::getProperName(cursename) + "'";
								auto querys = ss.str();
								const auto qs = querys.c_str();
								if (mysql_query(conn, qs)) {
									cout << mysql_error(conn) << endl;
									
									enet_peer_disconnect_later(peer, 0);
									continue;
								}
								Player::OnConsoleMessage(peer, "Uncursed " + PlayerDB::getProperName(cursename));
								ENetPeer* currentPeer;
								for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
									if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == cursename) {
										static_cast<PlayerInfo*>(currentPeer->data)->skinColor = 0x8295C3FF;
										sendClothes(currentPeer);
										static_cast<PlayerInfo*>(currentPeer->data)->isCursed = false;
										send_state(currentPeer);
									}
								}
								string qsa = "SELECT * FROM PlayerDatabase WHERE username = '" + PlayerDB::getProperName(cursename) + "' LIMIT 1";
								string account_history;
								mysql_query(conn, qsa.c_str());
								res = mysql_store_result(conn);
								while (row = mysql_fetch_row(res)) {
									account_history = row[68];
								}
								//if (res) mysql_free_result(res);
								time_t currentTime;
								time(&currentTime);
								const auto localTime = localtime(&currentTime);
								const auto Hour = localTime->tm_hour;
								const auto Min = localTime->tm_min;
								const auto Sec = localTime->tm_sec;
								const auto Year = localTime->tm_year + 1900;
								const auto Day = localTime->tm_mday;
								const auto Month = localTime->tm_mon + 1;
								account_history += "" + to_string(Month) + "/" + to_string(Day) + "/" + to_string(Year) + " " + to_string(Hour) + ":" + to_string(Min) + ":" + to_string(Sec) + ": " + static_cast<PlayerInfo*>(peer->data)->rawName + " - >> Uncursed|";
								string stringsss = "UPDATE PlayerDatabase SET accountnotes = '" + account_history + "' WHERE username = '" + PlayerDB::getProperName(cursename) + "' LIMIT 1";
								mysql_query(conn, stringsss.c_str());
							}
							else if (str.substr(0, 7) == "/unban ")
							{
								if (!isDev(peer))
								{
									sendWrongCmd(peer);
									continue;
								}
								string name = PlayerDB::getProperName(str.substr(7, cch.length() - 7 - 1));
								MYSQL_ROW row;
								stringstream sse;
								sse << "SELECT * FROM PlayerDatabase WHERE username = '" + PlayerDB::getProperName(name) + "' LIMIT 1";
								auto query = sse.str();
								auto q = query.c_str();
								string gamename;
								string isbanned;
								string timebanned;
								if (mysql_query(conn, q)) {
									cout << mysql_error(conn) << endl;
									
									enet_peer_disconnect_later(peer, 0);
									continue;
								}
								res = mysql_store_result(conn);
								while (row = mysql_fetch_row(res)) {
									gamename = row[1];
									isbanned = row[14];
									timebanned = row[56];
								}
								//if (res) mysql_free_result(res);
								if (gamename.length() == 0) {
									Player::OnConsoleMessage(peer, "" + PlayerDB::getProperName(name) + " does not exist");
									continue;
								}
								if (isbanned == "0" && timebanned == "0") {
									Player::OnConsoleMessage(peer, "" + PlayerDB::getProperName(name) + " is not banned");
									continue;
								}
								stringstream ss;
								ss << "UPDATE PlayerDatabase SET timebanned = '0', isbanned = '0' WHERE username = '" + PlayerDB::getProperName(name) + "'";
								auto querys = ss.str();
								const auto qs = querys.c_str();
								if (mysql_query(conn, qs)) {
									cout << mysql_error(conn) << endl;
									
									enet_peer_disconnect_later(peer, 0);
									continue;
								}
								Player::OnConsoleMessage(peer, "Unbanned " + PlayerDB::getProperName(name));
								string qsa = "SELECT * FROM PlayerDatabase WHERE username = '" + PlayerDB::getProperName(name) + "' LIMIT 1";
								string account_history;
								mysql_query(conn, qsa.c_str());
								res = mysql_store_result(conn);
								while (row = mysql_fetch_row(res)) {
									account_history = row[68];
								}
								//if (res) mysql_free_result(res);
								time_t currentTime;
								time(&currentTime);
								const auto localTime = localtime(&currentTime);
								const auto Hour = localTime->tm_hour;
								const auto Min = localTime->tm_min;
								const auto Sec = localTime->tm_sec;
								const auto Year = localTime->tm_year + 1900;
								const auto Day = localTime->tm_mday;
								const auto Month = localTime->tm_mon + 1;
								account_history += "" + to_string(Month) + "/" + to_string(Day) + "/" + to_string(Year) + " " + to_string(Hour) + ":" + to_string(Min) + ":" + to_string(Sec) + ": " + static_cast<PlayerInfo*>(peer->data)->rawName + " - >> Unbanned|";
								string stringsss = "UPDATE PlayerDatabase SET accountnotes = '" + account_history + "' WHERE username = '" + PlayerDB::getProperName(name) + "' LIMIT 1";
								mysql_query(conn, stringsss.c_str());
							}
							else if (str.substr(0, 5) == "/msg ")
							{
								bool found = false;
								if (static_cast<PlayerInfo*>(peer->data)->haveGrowId == false)
								{
									GamePacket p0 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oTo prevent abuse, you `4must `obe `2registered `oin order to use this command!"));
									ENetPacket* packet0 = enet_packet_create(p0.data,
										p0.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet0);
									delete p0.data;
									continue;
								}
								if (static_cast<PlayerInfo*>(peer->data)->isDuctaped == true)
								{
									GamePacket p0 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4You are muted now!"));
									ENetPacket* packet0 = enet_packet_create(p0.data,
										p0.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet0);
									delete p0.data;
									continue;
								}
								string msg_info = str;
								size_t extra_space = msg_info.find("  ");
								if (extra_space != std::string::npos)
								{
									msg_info.replace(extra_space, 2, " ");
								}
								string delimiter = " ";
								size_t pos = 0;
								string pm_user;
								string pm_message;
								if ((pos = msg_info.find(delimiter)) != std::string::npos)
								{
									msg_info.erase(0, pos + delimiter.length());
								}
								else
								{
									GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oPlease specify a `2player `oyou want your message to be delivered to."));
									ENetPacket* packet = enet_packet_create(ps.data,
										ps.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete ps.data;
								}
								if ((pos = msg_info.find(delimiter)) != std::string::npos)
								{
									pm_user = msg_info.substr(0, pos);
									msg_info.erase(0, pos + delimiter.length());
								}
								else
								{
									GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oPlease enter your `2message`o."));
									ENetPacket* packet = enet_packet_create(ps.data,
										ps.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete ps.data;
								}
								pm_message = msg_info;
								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (static_cast<PlayerInfo*>(currentPeer->data)->msgName == PlayerDB::getProperName(pm_user))
									{
										if (static_cast<PlayerInfo*>(currentPeer->data)->isinv == true) continue;
										if (static_cast<PlayerInfo*>(currentPeer->data)->isNicked == true) continue;
										if (static_cast<PlayerInfo*>(currentPeer->data)->isDisableMessages == true)
										{
											Player::OnConsoleMessage(peer, "`oThis player disabled private messages. Try it later.");
											continue;
										}
										static_cast<PlayerInfo*>(currentPeer->data)->lastMsger = static_cast<PlayerInfo*>(peer->data)->rawName;
										static_cast<PlayerInfo*>(currentPeer->data)->lastMsgerTrue = static_cast<PlayerInfo*>(currentPeer->data)->displayName;
										static_cast<PlayerInfo*>(currentPeer->data)->lastMsgWorld = static_cast<PlayerInfo*>(peer->data)->currentWorld;
										GamePacket p0 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "CP:_PL:0_OID:_CT:[MSG]_ `o(Sent to `$" + static_cast<PlayerInfo*>(currentPeer->data)->displayName + "`o)"));
										ENetPacket* packet0 = enet_packet_create(p0.data,
											p0.len,
											ENET_PACKET_FLAG_RELIABLE);
										GamePacket p10 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "CP:_PL:0_OID:_CT:[MSG]_ `o(Sent to `$" + static_cast<PlayerInfo*>(currentPeer->data)->displayName + "`o) `o(`4Note: `oMessage a mod `4ONLY ONCE `oabout an issue. Mods don't fix scams or replace items, they punish players who break the `5/rules`o.)"));
										ENetPacket* packet10 = enet_packet_create(p10.data,
											p10.len,
											ENET_PACKET_FLAG_RELIABLE);
										if (isMod(currentPeer) && static_cast<PlayerInfo*>(currentPeer->data)->isNicked == false)
										{
											enet_peer_send(peer, 0, packet10);
										}
										else
										{
											enet_peer_send(peer, 0, packet0);
										}
										delete p0.data;
										delete p10.data;
										found = true;
										GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "CP:_PL:0_OID:_CT:[MSG]_ `c>> from (`w" + static_cast<PlayerInfo*>(peer->data)->displayName + "`c) in [`o" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "`c] > `o" + pm_message));
										string text = "action|play_sfx\nfile|audio/pay_time.wav\ndelayMS|0\n";
										BYTE* data = new BYTE[5 + text.length()];
										BYTE zero = 0;
										int type = 3;
										memcpy(data, &type, 4);
										memcpy(data + 4, text.c_str(), text.length());
										memcpy(data + 4 + text.length(), &zero, 1);
										ENetPacket* packet2 = enet_packet_create(data,
											5 + text.length(),
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeer, 0, packet2);
										delete data;
										ENetPacket* packet = enet_packet_create(ps.data,
											ps.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeer, 0, packet);
										delete ps.data;
										break;
									}
								}
								if (found == false)
								{
									Player::OnConsoleMessage(peer, "`6>> No one online who has a name starting with " + pm_user + "`8.");
								}
							}
							else if (str == "/uba")
							{
								if (world == nullptr || static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT" || serverIsFrozen) continue;
								if (static_cast<PlayerInfo*>(peer->data)->haveGrowId && static_cast<PlayerInfo*>(peer->data)->rawName == world->owner || isMod(peer))
								{
									namespace fs = std::experimental::filesystem;
									fs::remove_all("worldbans/" + static_cast<PlayerInfo*>(peer->data)->currentWorld);
									Player::OnConsoleMessage(peer, "`oYou unbanned everyone from the world!");
								}
							}
							else if (str.substr(0, 5) == "/eff ") {
								if (!isDev(peer)) {
									sendWrongCmd(peer);
									continue;
								}
								Player::OnParticleEffect(peer, atoi(str.substr(4, cch.length() - 4 - 1).c_str()), static_cast<PlayerInfo*>(peer->data)->x, static_cast<PlayerInfo*>(peer->data)->y, 0);
							}
							else if (str.substr(0, 3) == "/p ") {
								if (!isDev(peer)) {
									sendWrongCmd(peer);
									continue;
								}
								static_cast<PlayerInfo*>(peer->data)->effect = atoi(str.substr(3, cch.length() - 3 - 1).c_str());
								sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
								send_state(peer); 
							}
							else if (str.substr(0, 5) == "/gsm ")
							{
								if (!isDev(peer))
								{
									sendWrongCmd(peer);
									continue;
								}
								string name = static_cast<PlayerInfo*>(peer->data)->displayName;
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4Global System Message: `o" + str.substr(4, cch.length() - 4 - 1)));
								string text = "action|play_sfx\nfile|audio/sungate.wav\ndelayMS|0\n";
								BYTE* data = new BYTE[5 + text.length()];
								BYTE zero = 0;
								int type = 3;
								memcpy(data, &type, 4);
								memcpy(data + 4, text.c_str(), text.length());
								memcpy(data + 4 + text.length(), &zero, 1);
								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (!static_cast<PlayerInfo*>(currentPeer->data)->radio)
										continue;
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(currentPeer, 0, packet);
									ENetPacket* packet2 = enet_packet_create(data,
										5 + text.length(),
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(currentPeer, 0, packet2);
									//enet_host_flush(server);
								}
								delete data;
								delete p.data;
							}
							else if (str.substr(0, 9) == "/unbanip ")
							{
								if (!isDev(peer))
								{
									sendWrongCmd(peer);
									continue;
								}
								string playerCalled = PlayerDB::getProperName(str.substr(9, cch.length() - 9 - 1));

								string ipid;
								string getmac;
								string getrid;
								string getsid;
								string getgid;
								string getvid;
								string getaid;
								string getip;

								MYSQL_ROW row;
								if (conn == nullptr)
								{
									cout << "null" << endl;
									continue;
								}
								if (conn != nullptr)
								{
									stringstream sse;
									string name;
									sse << "SELECT * FROM PlayerDatabase WHERE username = '" + PlayerDB::getProperName(playerCalled) + "' LIMIT 1";
									auto query = sse.str();
									auto q = query.c_str();
									if (mysql_query(conn, q))
									{
										cout << mysql_error(conn) << endl;
										


										enet_peer_disconnect_later(peer, 0);
										continue;
									}
									res = mysql_store_result(conn);
									while (row = mysql_fetch_row(res))
									{
										name = row[1];
										ipid = row[15];
										getmac = row[32];
										getrid = row[33];
										getsid = row[34];
										getgid = row[35];
										getvid = row[36];
										getaid = row[37];
										getip = row[38];
									}
									//if (res) mysql_free_result(res);
									if (name.length() > 0)
									{
									}
									else
									{
										Player::OnConsoleMessage(peer, "Player does not exist!");
										continue;
									}
								}
								else
								{
									continue;
								}

								string isipbanned = "No.";
								string macremoved = getmac;
								Remove(macremoved, ":");
								bool existx = std::experimental::filesystem::exists("ipbans/mac/" + macremoved + ".txt");
								if (existx)
								{
									isipbanned = "Yes.";
									remove(("ipbans/mac/" + macremoved + ".txt").c_str());
								}
								existx = std::experimental::filesystem::exists("ipbans/rid/" + getrid + ".txt");
								if (existx)
								{
									isipbanned = "Yes.";
									remove(("ipbans/rid/" + getrid + ".txt").c_str());
								}
								existx = std::experimental::filesystem::exists("ipbans/gid/" + getgid + ".txt");
								if (existx)
								{
									isipbanned = "Yes.";
									remove(("ipbans/gid/" + getgid + ".txt").c_str());
								}
								existx = std::experimental::filesystem::exists("ipbans/ip/" + getip + ".txt");
								if (existx)
								{
									isipbanned = "Yes.";
									remove(("ipbans/ip/" + getip + ".txt").c_str());
								}
								existx = std::experimental::filesystem::exists("ipbans/sid/" + getsid + ".txt");
								if (existx)
								{
									isipbanned = "Yes.";
									remove(("ipbans/sid/" + getsid + ".txt").c_str());
								}
								existx = std::experimental::filesystem::exists("ipbans/aid/" + getaid + ".txt");
								if (existx)
								{
									isipbanned = "Yes.";
									remove(("ipbans/aid/" + getaid + ".txt").c_str());
								}
								existx = std::experimental::filesystem::exists("ipbans/ip_id/" + ipid + ".txt");
								if (existx)
								{
									isipbanned = "Yes.";
									remove(("ipbans/ip_id/" + ipid + ".txt").c_str());
								}

								if (isipbanned == "No.")
								{
									Player::OnConsoleMessage(peer, "User is not ip banned!");
								}
								else
								{
									Player::OnConsoleMessage(peer, "User's ip ban was removed!");
								}
							}
							else if (str.substr(0, 8) == "/infoex ") {
								if (!isMod(peer)) {
									sendWrongCmd(peer);
									continue;
								}
								string checknick = PlayerDB::getProperName(str.substr(8, cch.length() - 8 - 1));
								MYSQL_ROW row;
								string q = "SELECT * FROM PlayerDatabase WHERE username = '" + checknick + "' LIMIT 1";
								if (mysql_query(conn, q.c_str())) {
									cout << mysql_error(conn) << endl;	
									continue;
								}
								string username = "", mac = "", rid = "", sid = "", gid = "", vid = "", aid = "", ip = "", playerid = "", lastnormalworld = "", email = "", timemuted = "", timecursed = "", surgerycooldown = "", geigercooldown = "", lastworld = "", effect = "", nick = "", invis = "", ghost = "", skin = "", chatcolor = "", Friends = "", WorldOwned = "", AdminLevel = "", Level = "", Experience = "", KillsCount = "", GuildName = "", InventorySize = "", PersonalNote = "", SkillName = "", JoinedGuild = "", subtype = "", subdate = "", title = "", surglvl = "", startkit = "", inventoryData = "", firefighterlevel = "", firefighterxp = "", providerlevel = "", providerxp = "", geigerlevel = "", geigerxp = "", fishermanlevel = "", fishermanxp = "";
								res = mysql_store_result(conn);
								while (row = mysql_fetch_row(res)) {
									playerid = row[0];
									username = row[1];
									email = row[3];
									effect = row[16];
									Friends = row[17];
									AdminLevel = row[19];
									GuildName = row[20];
									JoinedGuild = row[21];
									Level = row[22];
									Experience = row[23];
									WorldOwned = row[24];
									PersonalNote = row[25];
									KillsCount = row[26];
									InventorySize = row[27];
									SkillName = row[28];
									mac = row[32];
									rid = row[33];
									sid = row[34];
									gid = row[35];
									vid = row[36];
									aid = row[37];
									ip = row[38];
									subtype = row[39];
									subdate = row[40];
									title = row[41];
									surglvl = row[42];
									startkit = row[43];
									nick = row[44];
									invis = row[45];
									ghost = row[46];
									skin = row[47];
									chatcolor = row[48];
									lastworld = row[53];
									timecursed = row[54];
									timemuted = row[55];
									surgerycooldown = row[57];
									lastnormalworld = row[58];
									inventoryData = row[59];
									firefighterlevel = row[61];
									firefighterxp = row[62];
									providerlevel = row[63];
									providerxp = row[64];
									geigercooldown = row[65];
									geigerlevel = row[66];
									geigerxp = row[67];
									fishermanlevel = row[69];
									fishermanxp = row[70];
								}
								if (email.size() == 0) {
									Player::OnConsoleMessage(peer, checknick + " does not exist");
									continue;
								}
								if (mac == "02:00:00:00:00:00") mac = "N/A";
								if (rid == "" || rid == "none") rid = "N/A";
								if (sid == "" || sid == "none") sid = "N/A";
								if (gid == "" || gid == "none") gid = "N/A";
								if (vid == "" || vid == "none") vid = "N/A";
								if (aid == "" || aid == "none") aid = "N/A";
								if (ip == "127.0.0.1") ip = "localhost";
								if (ip == "" || ip == "none") ip = "N/A";
								Player::OnConsoleMessage(peer, "Found 1 matches:");
								Player::OnConsoleMessage(peer, username + " (ID: " + playerid + ") IP: " + ip + " Mac: " + mac + " RID: " + rid + " SID: " + sid + " GID: " + gid + " VID: " + vid + " AID: " + aid + "");
								if (nick == "") nick = "N/A";
								string status = "Player";
								if (AdminLevel == "1") status = "Moderator";
								if (AdminLevel == "2") status = "Developer";
								if (subdate == "") subdate = "N/A";
								Player::OnConsoleMessage(peer, "Status: " + status + " Nickname: " + nick + " Email: " + email + " Level: " + Level + " Subscription: " + subdate + "");
							}
							else if (str.substr(0, 6) == "/info ") {
								if (!isMod(peer)) {
									sendWrongCmd(peer);
									continue;
								}
								SendPunishView(peer, PlayerDB::getProperName(str.substr(6, cch.length() - 6 - 1)));
							}
							else if (str.substr(0, 7) == "/banip ")
							{
								if (!isDev(peer))
								{
									sendWrongCmd(peer);
									continue;
								}
								string warn_info = str;
								size_t extra_space = warn_info.find("  ");
								if (extra_space != std::string::npos)
								{
									warn_info.replace(extra_space, 2, " ");
								}
								string delimiter = " ";
								size_t pos = 0;
								string banip_user;
								string banip_reason;
								if ((pos = warn_info.find(delimiter)) != std::string::npos)
								{
									warn_info.erase(0, pos + delimiter.length());
								}
								else
								{
									Player::OnConsoleMessage(peer, "`@Please specify a `9Player `@You want to `4Ban-ip`@!");
									continue;
								}
								if ((pos = warn_info.find(delimiter)) != std::string::npos)
								{
									banip_user = warn_info.substr(0, pos);
									warn_info.erase(0, pos + delimiter.length());
								}
								else
								{
									Player::OnConsoleMessage(peer, "`@Please enter your `4Ban-ip `@Reason!");
									continue;
								}
								banip_reason = warn_info;
								int kiekDabarTuriWarns = 0;
								if (banip_reason.length() < 5)
								{
									AutoDemote(static_cast<PlayerInfo*>(peer->data)->rawName, to_string(static_cast<PlayerInfo*>(peer->data)->adminLevel), to_string(peer->address.host), "warn reason length < 5. He wrote: " + banip_reason);
									continue;
								}
								vector<string> blackWords = { "retard", "bitch", "damn", "fuck", "away", "you", "hello", "lol", "xd", "no", "yes", "what", "go", "noob", "niger", "top", "nigger", "nigga", "niga", "idiot", "shut", "stupid", "why", "gg", "haha", "wtf", "die", "suck", "fp", "shut" };
								if (std::find(blackWords.begin(), blackWords.end(), banip_reason) != blackWords.end())
								{
									AutoDemote(static_cast<PlayerInfo*>(peer->data)->rawName, to_string(static_cast<PlayerInfo*>(peer->data)->adminLevel), to_string(peer->address.host), "Found black world in reason. He wrote: " + banip_reason);
									continue;
								}
								string macmysql = "";
								string ridmysql = "";
								string sidmysql = "";
								string gidmysql = "";
								string vidmysql = "";
								string aidmysql = "";
								string ipmysql = "";
								MYSQL_ROW row;
								if (conn == nullptr)
								{
									cout << "null" << endl;
									continue;
								}
								if (conn != nullptr)
								{
									stringstream sse;
									string name;
									sse << "SELECT * FROM PlayerDatabase WHERE username = '" + PlayerDB::getProperName(banip_user) + "' LIMIT 1";
									auto query = sse.str();
									auto q = query.c_str();
									if (mysql_query(conn, q))
									{
										cout << mysql_error(conn) << endl;
										


										enet_peer_disconnect_later(peer, 0);
										continue;
									}
									res = mysql_store_result(conn);
									while (row = mysql_fetch_row(res))
									{
										name = row[1];
										macmysql = row[32];
										ridmysql = row[33];
										sidmysql = row[34];
										gidmysql = row[35];
										vidmysql = row[36];
										aidmysql = row[37];
										ipmysql = row[38];
									}
									//if (res) mysql_free_result(res);
									if (name.length() > 0)
									{
									}
									else
									{
										Player::OnConsoleMessage(peer, "Player does not exist!");
										continue;
									}
								}
								else
								{
									continue;
								}
								bool arRado = false;
								GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`#** `$The Ancient Ones `oapplied `4device ban `oon `2" + banip_user + " `ofor `2" + banip_reason + "`#** `o(`4/rules `oto see the rules!)"));
								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == PlayerDB::getProperName(banip_user))
									{
										using namespace std::chrono;
										if (static_cast<PlayerInfo*>(peer->data)->lastbanip + 300000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count())
										{
											static_cast<PlayerInfo*>(peer->data)->lastbanip = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
											static_cast<PlayerInfo*>(peer->data)->lastbanipCount = 1;
										}
										else
										{
											static_cast<PlayerInfo*>(peer->data)->lastbanipCount = static_cast<PlayerInfo*>(peer->data)->lastbanipCount + 1;
											if (static_cast<PlayerInfo*>(peer->data)->lastbanipCount == 3)
											{
												AutoDemote(static_cast<PlayerInfo*>(peer->data)->rawName, to_string(static_cast<PlayerInfo*>(peer->data)->adminLevel), to_string(peer->address.host), "3 ip bans in the past 5 minutes! He wrote: " + banip_reason);
												continue;
											}
										}
										string name = static_cast<PlayerInfo*>(peer->data)->displayName;
										string textInfo = "`1[M] `1[`o" + currentDateTime() + "`1] `6" + static_cast<PlayerInfo*>(peer->data)->tankIDName + " `4banned device on `2" + banip_user + " `4user";
										showModLogs(textInfo);
										arRado = true;
										string registermac = static_cast<PlayerInfo*>(currentPeer->data)->registermac;
										string registerrid = static_cast<PlayerInfo*>(currentPeer->data)->registerrid;
										string registersid = static_cast<PlayerInfo*>(currentPeer->data)->registersid;
										string registergid = static_cast<PlayerInfo*>(currentPeer->data)->registergid;
										string registervid = static_cast<PlayerInfo*>(currentPeer->data)->registervid;
										string registeraid = static_cast<PlayerInfo*>(currentPeer->data)->registeraid;
										string registerIP = static_cast<PlayerInfo*>(currentPeer->data)->registerIP;
										if (registermac != "02:00:00:00:00:00" && registermac != "" && registermac != "none")
										{
											Remove(registermac, ":");
											std::ofstream outfile2("ipbans/mac/" + registermac + ".txt");
											outfile2 << "user who banned this ID: " + static_cast<PlayerInfo*>(peer->data)->rawName << endl;
											outfile2 << "Ban-ip reason: " + banip_reason << endl;
											outfile2 << "Banned user name is: " + static_cast<PlayerInfo*>(currentPeer->data)->rawName;
											outfile2.close();
										}
										if (registerrid != "" && registerrid != "none")
										{
											std::ofstream outfile2("ipbans/rid/" + registerrid + ".txt");
											outfile2 << "user who banned this ID: " + static_cast<PlayerInfo*>(peer->data)->rawName << endl;
											outfile2 << "Ban-ip reason: " + banip_reason << endl;
											outfile2 << "Banned user name is: " + static_cast<PlayerInfo*>(currentPeer->data)->rawName;
											outfile2.close();
										}
										if (registersid != "" && registersid != "none")
										{
											std::ofstream outfile2("ipbans/sid/" + registersid + ".txt");
											outfile2 << "user who banned this ID: " + static_cast<PlayerInfo*>(peer->data)->rawName << endl;
											outfile2 << "Ban-ip reason: " + banip_reason << endl;
											outfile2 << "Banned user name is: " + static_cast<PlayerInfo*>(currentPeer->data)->rawName;
											outfile2.close();
										}
										if (registergid != "" && registergid != "none")
										{
											std::ofstream outfile2("ipbans/gid/" + registergid + ".txt");
											outfile2 << "user who banned this ID: " + static_cast<PlayerInfo*>(peer->data)->rawName << endl;
											outfile2 << "Ban-ip reason: " + banip_reason << endl;
											outfile2 << "Banned user name is: " + static_cast<PlayerInfo*>(currentPeer->data)->rawName;
											outfile2.close();
										}
										if (registervid != "" && registervid != "none")
										{
											std::ofstream outfile2("ipbans/vid/" + registervid + ".txt");
											outfile2 << "user who banned this ID: " + static_cast<PlayerInfo*>(peer->data)->rawName << endl;
											outfile2 << "Ban-ip reason: " + banip_reason << endl;
											outfile2 << "Banned user name is: " + static_cast<PlayerInfo*>(currentPeer->data)->rawName;
											outfile2.close();
										}
										if (registeraid != "" && registeraid != "none")
										{
											std::ofstream outfile2("ipbans/aid/" + registeraid + ".txt");
											outfile2 << "user who banned this ID: " + static_cast<PlayerInfo*>(peer->data)->rawName << endl;
											outfile2 << "Ban-ip reason: " + banip_reason << endl;
											outfile2 << "Banned user name is: " + static_cast<PlayerInfo*>(currentPeer->data)->rawName;
											outfile2.close();
										}
										if (registerIP != "" && registerIP != "none")
										{
											std::ofstream outfile2("ipbans/ip/" + registerIP + ".txt");
											outfile2 << "user who banned this ID: " + static_cast<PlayerInfo*>(peer->data)->rawName << endl;
											outfile2 << "Ban-ip reason: " + banip_reason << endl;
											outfile2 << "Banned user name is: " + static_cast<PlayerInfo*>(currentPeer->data)->rawName;
											outfile2.close();
										}
										Player::OnAddNotification(currentPeer, "`4Your device got banned by `2" + static_cast<PlayerInfo*>(peer->data)->rawName + ". `4Reason: `2 " + banip_reason + "", "audio/hub_open.wav", "interface/atomic_button.rttex");
										Player::OnConsoleMessage(currentPeer, "`4Your device got banned by `2" + static_cast<PlayerInfo*>(peer->data)->rawName + ". `4Reason: `2 " + banip_reason + "");
										Player::OnConsoleMessage(peer, "`2You successfully `5BANNED `4device `5on `w" + static_cast<PlayerInfo*>(currentPeer->data)->rawName + " !! `1(device bans cannot be removed from the game)");
										enet_peer_disconnect_later(currentPeer, 0);
										ENetPeer* currentPeer6;
										for (currentPeer6 = server->peers;
											currentPeer6 < &server->peers[server->peerCount];
											++currentPeer6)
										{
											if (currentPeer6->state != ENET_PEER_STATE_CONNECTED)
												continue;
											ENetPacket* packet = enet_packet_create(ps.data,
												ps.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeer6, 0, packet);
										}
										delete ps.data;
									}
								}
								if (arRado == false)
								{
									using namespace std::chrono;
									if (static_cast<PlayerInfo*>(peer->data)->lastbanip + 300000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count())
									{
										static_cast<PlayerInfo*>(peer->data)->lastbanip = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
										static_cast<PlayerInfo*>(peer->data)->lastbanipCount = 1;
									}
									else
									{
										static_cast<PlayerInfo*>(peer->data)->lastbanipCount = static_cast<PlayerInfo*>(peer->data)->lastbanipCount + 1;
										if (static_cast<PlayerInfo*>(peer->data)->lastbanipCount == 3)
										{
											AutoDemote(static_cast<PlayerInfo*>(peer->data)->rawName, to_string(static_cast<PlayerInfo*>(peer->data)->adminLevel), to_string(peer->address.host), "3 ip bans in the past 5 minutes! He wrote: " + banip_reason);
											continue;
										}
									}

									if (macmysql != "02:00:00:00:00:00" && macmysql != "" && macmysql != "none")
									{
										Remove(macmysql, ":");
										std::ofstream outfile2("ipbans/mac/" + macmysql + ".txt");
										outfile2 << "user who banned this ID: " + static_cast<PlayerInfo*>(peer->data)->rawName << endl;
										outfile2 << "Ban-ip reason: " + banip_reason << endl;
										outfile2 << "Banned user name is: " + PlayerDB::getProperName(banip_user);
										outfile2.close();
									}
									if (ridmysql != "" && ridmysql != "none")
									{
										std::ofstream outfile2("ipbans/rid/" + ridmysql + ".txt");
										outfile2 << "user who banned this ID: " + static_cast<PlayerInfo*>(peer->data)->rawName << endl;
										outfile2 << "Ban-ip reason: " + banip_reason << endl;
										outfile2 << "Banned user name is: " + PlayerDB::getProperName(banip_user);
										outfile2.close();
									}
									if (sidmysql != "" && sidmysql != "none")
									{
										std::ofstream outfile2("ipbans/sid/" + sidmysql + ".txt");
										outfile2 << "user who banned this ID: " + static_cast<PlayerInfo*>(peer->data)->rawName << endl;
										outfile2 << "Ban-ip reason: " + banip_reason << endl;
										outfile2 << "Banned user name is: " + PlayerDB::getProperName(banip_user);
										outfile2.close();
									}
									if (gidmysql != "" && gidmysql != "none")
									{
										std::ofstream outfile2("ipbans/gid/" + gidmysql + ".txt");
										outfile2 << "user who banned this ID: " + static_cast<PlayerInfo*>(peer->data)->rawName << endl;
										outfile2 << "Ban-ip reason: " + banip_reason << endl;
										outfile2 << "Banned user name is: " + PlayerDB::getProperName(banip_user);
										outfile2.close();
									}
									if (vidmysql != "" && vidmysql != "none")
									{
										std::ofstream outfile2("ipbans/vid/" + vidmysql + ".txt");
										outfile2 << "user who banned this ID: " + static_cast<PlayerInfo*>(peer->data)->rawName << endl;
										outfile2 << "Ban-ip reason: " + banip_reason << endl;
										outfile2 << "Banned user name is: " + PlayerDB::getProperName(banip_user);
										outfile2.close();
									}
									if (aidmysql != "" && aidmysql != "none")
									{
										std::ofstream outfile2("ipbans/aid/" + aidmysql + ".txt");
										outfile2 << "user who banned this ID: " + static_cast<PlayerInfo*>(peer->data)->rawName << endl;
										outfile2 << "Ban-ip reason: " + banip_reason << endl;
										outfile2 << "Banned user name is: " + PlayerDB::getProperName(banip_user);
										outfile2.close();
									}
									if (ipmysql != "" && ipmysql != "none")
									{
										std::ofstream outfile2("ipbans/ip/" + ipmysql + ".txt");
										outfile2 << "user who banned this ID: " + static_cast<PlayerInfo*>(peer->data)->rawName << endl;
										outfile2 << "Ban-ip reason: " + banip_reason << endl;
										outfile2 << "Banned user name is: " + PlayerDB::getProperName(banip_user);
										outfile2.close();
									}

									ENetPeer* currentPeer6;
									for (currentPeer6 = server->peers;
										currentPeer6 < &server->peers[server->peerCount];
										++currentPeer6)
									{
										if (currentPeer6->state != ENET_PEER_STATE_CONNECTED)
											continue;
										ENetPacket* packet = enet_packet_create(ps.data,
											ps.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeer6, 0, packet);
									}
									delete ps.data;
									Player::OnConsoleMessage(peer, "`2User was device-banned in `boffline`2!");
								}
							}
							else if (str == "/nick")
							{
								if (!isMod(peer))
								{
									sendWrongCmd(peer);
									continue;
								}
								string name2;
								string namemsg = static_cast<PlayerInfo*>(peer->data)->rawName;
								static_cast<PlayerInfo*>(peer->data)->isNicked = false;
								static_cast<PlayerInfo*>(peer->data)->OriName = name2;
								if (static_cast<PlayerInfo*>(peer->data)->rawName == world->owner && !isMod(peer))
								{
									name2 = "`2" + static_cast<PlayerInfo*>(peer->data)->rawName;
									static_cast<PlayerInfo*>(event.peer->data)->country = "us";
								}
								else if (static_cast<PlayerInfo*>(peer->data)->adminLevel == 0)
								{
									name2 = "`w" + static_cast<PlayerInfo*>(peer->data)->rawName;
									static_cast<PlayerInfo*>(event.peer->data)->country = "us";
								}
								else if (static_cast<PlayerInfo*>(peer->data)->adminLevel == 1)
								{
									name2 = "`#@" + static_cast<PlayerInfo*>(peer->data)->rawName;
									static_cast<PlayerInfo*>(event.peer->data)->country = "us";
								}
								else if (static_cast<PlayerInfo*>(peer->data)->adminLevel == 2)
								{
									name2 = "`6@" + static_cast<PlayerInfo*>(peer->data)->rawName;
									static_cast<PlayerInfo*>(event.peer->data)->country = "us";
								}
								if (static_cast<PlayerInfo*>(peer->data)->NickPrefix != "")
								{
									name2 = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + static_cast<PlayerInfo*>(peer->data)->rawName;
								}
								static_cast<PlayerInfo*>(peer->data)->displayName = name2;
								static_cast<PlayerInfo*>(peer->data)->msgName = namemsg;
								
								ENetPeer* currentPeer;
								for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
									if (isHere(peer, currentPeer)) {
										Player::OnNameChanged(currentPeer, static_cast<PlayerInfo*>(peer->data)->netID, name2);
									}
								}
								stringstream basic_stringstream;
								basic_stringstream << "UPDATE PlayerDatabase SET nick = '' WHERE username = '" + static_cast<PlayerInfo*>(peer->data)->rawName + "'";
								const auto cs = basic_stringstream.str();
								const auto string = cs.c_str();
								mysql_query(conn, string);
							}
							else if (str.substr(0, 10) == "/giverank ")
							{
								if (!isDev(peer))
								{
									sendWrongCmd(peer);
									continue;
								}
								if (str.substr(10, cch.length() - 10 - 1) == "") continue;
								string ban_info = str;
								size_t extra_space = ban_info.find("  ");
								if (extra_space != std::string::npos)
								{
									ban_info.replace(extra_space, 2, " ");
								}
								string delimiter = " ";
								size_t pos = 0;
								string ban_user;
								string ban_time;
								if ((pos = ban_info.find(delimiter)) != std::string::npos)
								{
									ban_info.erase(0, pos + delimiter.length());
								}
								else
								{
									GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oUsage: /giverank <user> <rankname>"));
									ENetPacket* packet = enet_packet_create(ps.data,
										ps.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete ps.data;
									continue;
								}
								if ((pos = ban_info.find(delimiter)) != std::string::npos)
								{
									ban_user = ban_info.substr(0, pos);
									ban_info.erase(0, pos + delimiter.length());
								}
								else
								{
									GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oUsage: /giverank <user> <rankname>"));
									ENetPacket* packet = enet_packet_create(ps.data,
										ps.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete ps.data;
									continue;
								}
								ban_time = ban_info;
								string playerName = ban_user;
								string rankName = ban_time;
								if (static_cast<PlayerInfo*>(peer->data)->rawName == playerName) continue;
								bool success = false;
								transform(rankName.begin(), rankName.end(), rankName.begin(), ::tolower);
								transform(playerName.begin(), playerName.end(), playerName.begin(), ::tolower);
								GiveRank(rankName, playerName, success);
								if (success)
								{
									ENetPeer* currentPeer;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
											continue;;
										if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == playerName)
										{
											if (static_cast<PlayerInfo*>(currentPeer->data)->haveGrowId)
											{
												GamePacket ps3 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oWarning from `4System`o: your rank has been `5Changed to `8" + rankName + ""));
												ENetPacket* packet3 = enet_packet_create(ps3.data,
													ps3.len,
													ENET_PACKET_FLAG_RELIABLE);
												enet_peer_send(currentPeer, 0, packet3);
												delete ps3.data;
												enet_peer_disconnect_later(currentPeer, 0);
												Player::OnConsoleMessage(peer, "`2Successfully changed.");
												MYSQL_ROW row;
												string qss = "SELECT * FROM PlayerDatabase WHERE username = '" + static_cast<PlayerInfo*>(peer->data)->rawName + "' LIMIT 1";
												string account_history;
												mysql_query(conn, qss.c_str());
												res = mysql_store_result(conn);
												while (row = mysql_fetch_row(res)) {
													account_history = row[68];
												}
												time_t currentTime;
												time(&currentTime);
												const auto localTime = localtime(&currentTime);
												const auto Hour = localTime->tm_hour;
												const auto Min = localTime->tm_min;
												const auto Sec = localTime->tm_sec;
												const auto Year = localTime->tm_year + 1900;
												const auto Day = localTime->tm_mday;
												const auto Month = localTime->tm_mon + 1;
												account_history += "" + to_string(Month) + "/" + to_string(Day) + "/" + to_string(Year) + " " + to_string(Hour) + ":" + to_string(Min) + ":" + to_string(Sec) + ": " + static_cast<PlayerInfo*>(peer->data)->rawName + " - >> Changed " + static_cast<PlayerInfo*>(currentPeer->data)->rawName + " role to " + rankName + "|";
												string stringsa = "UPDATE PlayerDatabase SET accountnotes = '" + account_history + "' WHERE username = '" + static_cast<PlayerInfo*>(peer->data)->rawName + "' LIMIT 1";
												mysql_query(conn, stringsa.c_str());
												break;
											}
										}
									}
								}
								else
								{
									GamePacket pse = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4An error occurred.`2It could be because you entered the wrong player name or rank name."));
									ENetPacket* packete = enet_packet_create(pse.data,
										pse.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packete);
									delete pse.data;
									continue;
								}
							}

							else if (str.substr(0, 11) == "/delstatus ")
							{
								if (!isDev(peer))
								{
									sendWrongCmd(peer);
									continue;
								}
								if (str.substr(11, cch.length() - 11 - 1) == "") continue;
								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == str.substr(11, cch.length() - 11 - 1))
									{
										if (static_cast<PlayerInfo*>(currentPeer->data)->haveGrowId == false) continue;
										using namespace std::chrono;
										if (static_cast<PlayerInfo*>(peer->data)->lastdelstatus + 300000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count())
										{
											static_cast<PlayerInfo*>(peer->data)->lastdelstatus = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
											static_cast<PlayerInfo*>(peer->data)->lastdelstatusCount = 1;
										}
										else
										{
											static_cast<PlayerInfo*>(peer->data)->lastdelstatusCount = static_cast<PlayerInfo*>(peer->data)->lastdelstatusCount + 1;
											if (static_cast<PlayerInfo*>(peer->data)->lastdelstatusCount == 3)
											{
												AutoDemote(static_cast<PlayerInfo*>(peer->data)->rawName, to_string(static_cast<PlayerInfo*>(peer->data)->adminLevel), to_string(peer->address.host), "3 /delstatus in the past 5 minutes!");
												continue;
											}
										}
										string name = static_cast<PlayerInfo*>(peer->data)->displayName;
										string textInfo = "`1[M] `1[`o" + currentDateTime() + "`1] `6" + static_cast<PlayerInfo*>(peer->data)->tankIDName + " `4removed `2" + str.substr(11, cch.length() - 11 - 1) + " `4from staff team";
										showModLogs(textInfo);
										GamePacket ps = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`#** `$The Ancient Ones `ohave Removed `5 " + str.substr(11, cch.length() - 11 - 1) + " `#from Staff Team."));
										ENetPacket* packet = enet_packet_create(ps.data,
											ps.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeer, 0, packet);
										GamePacket ps2 = packetEnd(appendInt(appendString(appendString(appendString(appendString(createPacket(), "OnAddNotification"), "interface/science_button.rttex"), "`0Warning from `4System`0: You've been `5REMOVED `#from Staff team"), "audio/hub_open.wav"), 0));
										ENetPacket* packet2 = enet_packet_create(ps2.data,
											ps2.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeer, 0, packet2);
										GamePacket ps3 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oWarning from `4System`o: You've been `5Removed `5from Staff Team."));
										ENetPacket* packet3 = enet_packet_create(ps3.data,
											ps3.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeer, 0, packet3);
										if (static_cast<PlayerInfo*>(currentPeer->data)->isIn)
										{
											if (static_cast<PlayerInfo*>(currentPeer->data)->haveGrowId)
											{
												bool success = false;
												GiveRank("newbie", static_cast<PlayerInfo*>(currentPeer->data)->rawName, success);
												if (!success)
												{
													Player::OnConsoleMessage(peer, "`4SYSTEM ERROR: `2user's rank was not changed.");
												}
											}
										}
										delete ps.data;
										enet_peer_disconnect_later(currentPeer, 0);
									}
								}
							}

							else if (str.substr(0, 6) == "/nick ") {
								if (!isMod(peer)) {
									sendWrongCmd(peer);
									continue;
								}
								string name2 = str.substr(6, cch.length() - 6 - 1);
								if ((str.substr(6, cch.length() - 6 - 1).find_first_not_of("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789") != string::npos)) continue;
								if (name2.length() < 3) continue;
								if (name2.length() > 16) continue;
								static_cast<PlayerInfo*>(peer->data)->msgName = PlayerDB::getProperName(str.substr(6, cch.length() - 6 - 1));
								static_cast<PlayerInfo*>(peer->data)->OriName = name2;
								if (static_cast<PlayerInfo*>(peer->data)->NickPrefix != "")
								{
									static_cast<PlayerInfo*>(peer->data)->displayName = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + str.substr(6, cch.length() - 6 - 1);
									name2 = static_cast<PlayerInfo*>(peer->data)->NickPrefix + ". " + name2;
								}
								else static_cast<PlayerInfo*>(peer->data)->displayName = str.substr(6, cch.length() - 6 - 1);
								static_cast<PlayerInfo*>(peer->data)->isNicked = true;
								if (isWorldOwner(peer, world)) {
									if (static_cast<PlayerInfo*>(peer->data)->displayName.find("`") != string::npos) {} else {
										static_cast<PlayerInfo*>(peer->data)->displayName = "`2" + static_cast<PlayerInfo*>(peer->data)->displayName;
										auto p7 = packetEnd(appendString(appendString(createPacket(), "OnNameChanged"), "`2" + static_cast<PlayerInfo*>(peer->data)->displayName));
										memcpy(p7.data + 8, &(static_cast<PlayerInfo*>(peer->data)->netID), 4);
										auto packet7 = enet_packet_create(p7.data, p7.len, ENET_PACKET_FLAG_RELIABLE);
										delete p7.data;
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
											if (isHere(peer, currentPeer)) {
												if (static_cast<PlayerInfo*>(peer->data)->adminLevel >= 0) {
													enet_peer_send(currentPeer, 0, packet7);
												}
											}
										}
									}
								} else {
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
										if (isHere(peer, currentPeer)) {
											Player::OnNameChanged(currentPeer, static_cast<PlayerInfo*>(peer->data)->netID, name2);
										}
									}
								}
								string strings = "UPDATE PlayerDatabase SET nick = '" + static_cast<PlayerInfo*>(peer->data)->OriName + "' WHERE username = '" + static_cast<PlayerInfo*>(peer->data)->rawName + "'";
								mysql_query(conn, strings.c_str());
							}
							else if (str == "/invis" || str == "/invisible") {
								if (!isMod(peer) && !static_cast<PlayerInfo*>(peer->data)->Subscriber) {
									sendWrongCmd(peer);
									continue;
								}
								if (static_cast<PlayerInfo*>(peer->data)->isinv == false) {
									static_cast<PlayerInfo*>(peer->data)->isinv = true;
									Player::OnConsoleMessage(peer, "`oYou are now ninja, invisible to all.");
									ENetPeer* currentPeer;
									Player::OnInvis(peer, 1, static_cast<PlayerInfo*>(peer->data)->netID);
									string text = "action|play_sfx\nfile|audio/boo_ghost_be_gone.wav\ndelayMS|0\n";
									BYTE* data = new BYTE[5 + text.length()];
									BYTE zero = 0;
									int type = 3;
									memcpy(data, &type, 4);
									memcpy(data + 4, text.c_str(), text.length());
									memcpy(data + 4 + text.length(), &zero, 1);
									ENetPacket* packet6 = enet_packet_create(data,
										5 + text.length(),
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet6);
									delete data;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
											continue;
										if (isHere(peer, currentPeer))
										{
											Player::OnInvis(currentPeer, 1, static_cast<PlayerInfo*>(peer->data)->netID);
										}
									}
									stringstream basic_stringstream;
									basic_stringstream << "UPDATE PlayerDatabase SET invis = 'true' WHERE username = '" + static_cast<PlayerInfo*>(peer->data)->rawName + "'";
									const auto cs = basic_stringstream.str();
									const auto strings = cs.c_str();
									if (mysql_query(conn, strings))
									{
										cout << mysql_error(conn) << endl;
										
										enet_peer_disconnect_later(peer, 0);
										return 0;
									}
								}
								else
								{
									Player::OnConsoleMessage(peer, "You are once again visible to mortals.");
									Player::OnInvis(peer, 0, static_cast<PlayerInfo*>(peer->data)->netID);
									static_cast<PlayerInfo*>(peer->data)->isinv = false;
									GamePacket p3 = packetEnd(appendString(appendString(createPacket(), "OnNameChanged"), static_cast<PlayerInfo*>(peer->data)->displayName));
									memcpy(p3.data + 8, &(static_cast<PlayerInfo*>(peer->data)->netID), 4); // ffloor
									ENetPacket* packet3 = enet_packet_create(p3.data,
										p3.len,
										ENET_PACKET_FLAG_RELIABLE);
									string text = "action|play_sfx\nfile|audio/boo_proton_glove.wav\ndelayMS|0\n";
									BYTE* data = new BYTE[5 + text.length()];
									BYTE zero = 0;
									int type = 3;
									memcpy(data, &type, 4);
									memcpy(data + 4, text.c_str(), text.length());
									memcpy(data + 4 + text.length(), &zero, 1);
									ENetPacket* packet8 = enet_packet_create(data,
										5 + text.length(),
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet8);
									delete data;
									delete p3.data;
									ENetPeer* currentPeer;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
										if (isHere(peer, currentPeer))
										{
											if (!static_cast<PlayerInfo*>(peer->data)->isGhost)
											{
												Player::OnInvis(currentPeer, 0, static_cast<PlayerInfo*>(peer->data)->netID);
											}
											if (static_cast<PlayerInfo*>(peer->data)->rawName != static_cast<PlayerInfo*>(currentPeer->data)->rawName)
											{
												enet_peer_send(currentPeer, 0, packet3);
											}
										}
									}
									stringstream basic_stringstream;
									basic_stringstream << "UPDATE PlayerDatabase SET invis = 'false' WHERE username = '" + static_cast<PlayerInfo*>(peer->data)->rawName + "'";
									const auto cs = basic_stringstream.str();
									const auto strings = cs.c_str();
									if (mysql_query(conn, strings))
									{
										cout << mysql_error(conn) << endl;
										
										enet_peer_disconnect_later(peer, 0);
										return 0;
									}
								}
							}
							else if (str.substr(0, 5) == "/jsb ")
							{
								if (!isMod(peer) && !static_cast<PlayerInfo*>(peer->data)->Subscriber)
								{
									sendWrongCmd(peer);
									continue;
								}
								if (static_cast<PlayerInfo*>(peer->data)->isDuctaped == true)
								{
									GamePacket p0 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4You are muted now!"));
									ENetPacket* packet0 = enet_packet_create(p0.data,
										p0.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet0);
									delete p0.data;
									continue;
								}
								string name = static_cast<PlayerInfo*>(peer->data)->displayName;
								Player::OnConsoleMessage(peer, "`2>> `9Jammed Broadcast sent to all players online`2!");
								GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "CP:_PL:0_OID:_CT:[SB]_ `#** `#from (`2" + name + "`#) in [`4JAMMED!`#] ** : `o" + str.substr(4, cch.length() - 4 - 1)));
								string text = "action|play_sfx\nfile|audio/beep.wav\ndelayMS|0\n";
								BYTE* data = new BYTE[5 + text.length()];
								BYTE zero = 0;
								int type = 3;
								memcpy(data, &type, 4);
								memcpy(data + 4, text.c_str(), text.length());
								memcpy(data + 4 + text.length(), &zero, 1);
								ENetPeer* currentPeer;
								for (currentPeer = server->peers;
									currentPeer < &server->peers[server->peerCount];
									++currentPeer)
								{
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
										continue;
									if (!static_cast<PlayerInfo*>(currentPeer->data)->radio)
										continue;
									if (static_cast<PlayerInfo*>(currentPeer->data)->currentWorld == "EXIT")
										continue;
									if (static_cast<PlayerInfo*>(currentPeer->data)->isIn == false)
										continue;
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(currentPeer, 0, packet);
									ENetPacket* packet2 = enet_packet_create(data,
										5 + text.length(),
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(currentPeer, 0, packet2);
									//enet_host_flush(server);
								}
								delete data;
								delete p.data;
							}
							else if (str.substr(0, 4) == "/sb ")
							{
								if (static_cast<PlayerInfo*>(peer->data)->isDuctaped == true)
								{
									Player::OnConsoleMessage(peer, "`@Super Broadcast Not `4Allowed `@When You Are `9Duct-taped`@!");
									continue;
								}
								if (static_cast<PlayerInfo*>(peer->data)->level < 10 && !static_cast<PlayerInfo*>(peer->data)->Subscriber)
								{
									Player::OnConsoleMessage(peer, ">> `4OOPS:`` To cut down on `4spam`` the broadcast features are only available to `5Supporters`` who are level `510`` and higher. To become a `5Supporter``, purchase Gems (or earn `57,000`` Gems through `5Tapjoy`` offers) - you'll get new skin colors, the `5Recycle`` tool, and more!");
									continue;
								}
								ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
								string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
								int b = atoi(content.c_str());
								if (b > 1000)
								{
									using namespace std::chrono;
									if (static_cast<PlayerInfo*>(peer->data)->lastSB + 60000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count())
									{
										static_cast<PlayerInfo*>(peer->data)->lastSB = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
									}
									else
									{
										int kiekDar = (static_cast<PlayerInfo*>(peer->data)->lastSB + 60000 - (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) / 1000;
										Player::OnConsoleMessage(peer, "`9Cooldown `@Please Wait `9" + to_string(kiekDar) + " Seconds `@To Throw Another Broadcast!");
										continue;
									}
									int gemcalc10k = b - 1000;
									ofstream myfile2;
									myfile2.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									myfile2 << std::to_string(gemcalc10k);
									myfile2.close();
									ifstream ifszi("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
									string contentx((std::istreambuf_iterator<char>(ifszi)), (std::istreambuf_iterator<char>()));
									int updgem = atoi(contentx.c_str());
									GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
									ENetPacket* packetpp = enet_packet_create(pp.data, pp.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packetpp);
									delete pp.data;
									Player::OnConsoleMessage(peer, "`o>> Super Broadcast sent to all players online!");
									string worldname = static_cast<PlayerInfo*>(peer->data)->currentWorld;
									for (auto i = 0; i < world->width * world->height; i++) {
										if (world->items[i].foreground == 226 && world->items[i].activated) {
											worldname = "`4JAMMED!";
											break;
										}
									}
									string name = static_cast<PlayerInfo*>(peer->data)->displayName;
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "CP:_PL:0_OID:_CT:[SB]_ `#** `#from (`2" + name + "`#) in [`o" + worldname + "`#] ** :`o " + str.substr(4, cch.length() - 4 - 1)));
									string text = "action|play_sfx\nfile|audio/beep.wav\ndelayMS|0\n";
									BYTE* data = new BYTE[5 + text.length()];
									BYTE zero = 0;
									int type = 3;
									memcpy(data, &type, 4);
									memcpy(data + 4, text.c_str(), text.length());
									memcpy(data + 4 + text.length(), &zero, 1);
									ENetPeer* currentPeer;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
										if (!static_cast<PlayerInfo*>(currentPeer->data)->radio) continue;
										if (static_cast<PlayerInfo*>(currentPeer->data)->isIn == false) continue;
										ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeer, 0, packet);
										ENetPacket* packet2 = enet_packet_create(data, 5 + text.length(), ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(currentPeer, 0, packet2);
										static_cast<PlayerInfo*>(currentPeer->data)->lastSbbWorld = static_cast<PlayerInfo*>(peer->data)->currentWorld;
									}
									delete data;
									delete p.data;
								}
								else
								{
									int needgems = 1000 - b;
									Player::OnConsoleMessage(peer, "`@You Need `9" + to_string(needgems) + " `@Gems More To Send Super Broadcast!");
								}
							}
							else if (str.substr(0, 7) == "/schat ")
							{
								if (!isMod(peer))
								{
									sendWrongCmd(peer);
									continue;
								}
								if (static_cast<PlayerInfo*>(peer->data)->isDuctaped == true)
								{
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`@Staff Chat Not `4Allowed `@When You Are `9Duct-taped`@!"));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
								}
								else
								{
									string name = static_cast<PlayerInfo*>(peer->data)->displayName;
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`w** `5[STAFF-CHAT]`` from `$`2" + name + "`$: `# " + str.substr(7, cch.length() - 7 - 1)));
									string text = "action|play_sfx\nfile|audio/beep.wav\ndelayMS|0\n";
									BYTE* data = new BYTE[5 + text.length()];
									BYTE zero = 0;
									int type = 3;
									memcpy(data, &type, 4);
									memcpy(data + 4, text.c_str(), text.length());
									memcpy(data + 4 + text.length(), &zero, 1);
									ENetPeer* currentPeer;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
											continue;
										if (static_cast<PlayerInfo*>(currentPeer->data)->currentWorld == "EXIT")
											continue;
										if (static_cast<PlayerInfo*>(currentPeer->data)->isIn == false)
											continue;
										if (isMod(currentPeer))
										{
											ENetPacket* packet = enet_packet_create(p.data,
												p.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeer, 0, packet);
											ENetPacket* packet2 = enet_packet_create(data,
												5 + text.length(),
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeer, 0, packet2);
										}
									}
									delete data;
									delete p.data;
								}
							}
							else if (str.substr(0, 5) == "/sdb ")
							{
								if (static_cast<PlayerInfo*>(peer->data)->isDuctaped == true)
								{
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`@Super Duper Broadcast Not `4Allowed `@When You Are `9Duct-taped`@!"));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
								}
								else
								{
									if (static_cast<PlayerInfo*>(peer->data)->level < 60)
									{
										GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`@You Must Be Aleast `9Level `460 `@To Use This `9Command`@!"));
										ENetPacket* packet = enet_packet_create(p.data,
											p.len,
											ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p.data;
									}
									else
									{
										std::ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										std::string content((std::istreambuf_iterator<char>(ifsz)),
											(std::istreambuf_iterator<char>()));
										int b = atoi(content.c_str());
										if (b > 100000)
										{
											using namespace std::chrono;
											if (static_cast<PlayerInfo*>(peer->data)->lastSDB + 600000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count())
											{
												static_cast<PlayerInfo*>(peer->data)->lastSDB = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
											}
											else
											{
												GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`9Cooldown `@Please Wait `910 minutes `@To Throw Another Super-Duper-Broadcast!"));
												ENetPacket* packet = enet_packet_create(p.data,
													p.len,
													ENET_PACKET_FLAG_RELIABLE);
												enet_peer_send(peer, 0, packet);
												delete p.data;
												//enet_host_flush(server);
												continue;
											}
											int gemcalc10k = b - 100000;
											ENetPeer* currentPeer;
											for (currentPeer = server->peers;
												currentPeer < &server->peers[server->peerCount];
												++currentPeer)
											{
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
													continue;
												static_cast<PlayerInfo*>(currentPeer->data)->lastSdbWorld = static_cast<PlayerInfo*>(peer->data)->currentWorld;
											}
											ofstream myfile2;
											myfile2.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
											myfile2 << std::to_string(gemcalc10k);
											myfile2.close();
											std::ifstream ifszi("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
											std::string contentx((std::istreambuf_iterator<char>(ifszi)),
												(std::istreambuf_iterator<char>()));
											int updgem = atoi(contentx.c_str());
											GamePacket pp = packetEnd(appendInt(appendString(createPacket(), "OnSetBux"), updgem));
											ENetPacket* packetpp = enet_packet_create(pp.data,
												pp.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packetpp);
											delete pp.data;
											GamePacket p5 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`2>> `9Super Duper Broadcast sent to all players online`2!"));
											ENetPacket* packet5 = enet_packet_create(p5.data,
												p5.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet5);
											delete p5.data;
											string name = static_cast<PlayerInfo*>(peer->data)->displayName;
											GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\n\nadd_label_with_icon|big|`^Super Duper Broadcast`^!``|left|2480|\n\nadd_spacer|small|\nadd_label|small|`#From " + name + "|left|4|\nadd_label|small|`2>> `@" + str.substr(4, cch.length() - 4 - 1) + "|\n\nadd_spacer|small|\nadd_button|warptosb|`2Warp To `9" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "`2!|\nadd_quick_exit|\n"));
											string text = "action|play_sfx\nfile|audio/beep.wav\ndelayMS|0\n";
											BYTE* data = new BYTE[5 + text.length()];
											BYTE zero = 0;
											int type = 3;
											memcpy(data, &type, 4);
											memcpy(data + 4, text.c_str(), text.length());
											memcpy(data + 4 + text.length(), &zero, 1);
											ENetPeer* currentPeer0;
											for (currentPeer0 = server->peers;
												currentPeer0 < &server->peers[server->peerCount];
												++currentPeer0)
											{
												if (currentPeer0->state != ENET_PEER_STATE_CONNECTED)
													continue;
												if (!static_cast<PlayerInfo*>(currentPeer0->data)->radio)
													continue;
												if (static_cast<PlayerInfo*>(currentPeer0->data)->currentWorld == "EXIT")
													continue;
												if (static_cast<PlayerInfo*>(currentPeer0->data)->isIn == false)
													continue;
												ENetPacket* packet = enet_packet_create(p.data,
													p.len,
													ENET_PACKET_FLAG_RELIABLE);
												enet_peer_send(currentPeer0, 0, packet);
												ENetPacket* packet2 = enet_packet_create(data,
													5 + text.length(),
													ENET_PACKET_FLAG_RELIABLE);
												enet_peer_send(currentPeer0, 0, packet2);
												//enet_host_flush(server);
											}
											delete data;
											delete p.data;
										}
										else
										{
											int needgems = 100000 - b;
											GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`@You Need `9" + to_string(needgems) + " `@Gems More To Send Super Duper Broadcast!"));
											ENetPacket* packet = enet_packet_create(p.data,
												p.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet);
											delete p.data;
										}
									}
								}
							}
							else if (str.substr(0, 3) == "/g ")
							{
								if (static_cast<PlayerInfo*>(peer->data)->isDuctaped == true)
								{
									GamePacket p0 = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`4You are muted now!"));
									ENetPacket* packet0 = enet_packet_create(p0.data,
										p0.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet0);
									delete p0.data;
									continue;
								}
								if (static_cast<PlayerInfo*>(peer->data)->joinguild == true)
								{
									string name = static_cast<PlayerInfo*>(peer->data)->displayName;
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`w[`5GUILD CHAT`w] [`4" + static_cast<PlayerInfo*>(peer->data)->tankIDName + "`w]  = " + str.substr(3, cch.length() - 3 - 1)));
									ENetPeer* currentPeer;
									for (currentPeer = server->peers;
										currentPeer < &server->peers[server->peerCount];
										++currentPeer)
									{
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED)
											continue;
										if (static_cast<PlayerInfo*>(currentPeer->data)->currentWorld == "EXIT")
											continue;
										if (static_cast<PlayerInfo*>(currentPeer->data)->isIn == false)
											continue;
										if (find(static_cast<PlayerInfo*>(peer->data)->guildMembers.begin(), static_cast<PlayerInfo*>(peer->data)->guildMembers.end(), static_cast<PlayerInfo*>(currentPeer->data)->rawName) != static_cast<PlayerInfo*>(peer->data)->guildMembers.end())
										{
											ENetPacket* packet = enet_packet_create(p.data,
												p.len,
												ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(currentPeer, 0, packet);
										}
									}
									delete p.data;
								}
								else
								{
									Player::OnConsoleMessage(peer, "You won't see broadcasts anymore.");
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`9Sorry! `^You must join a `9Guild `^Or `9Create `^One to use this command!"));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									continue;
								}
							} else if (str.substr(0, 6) == "/radio") {
								if (static_cast<PlayerInfo*>(peer->data)->radio) {
									Player::OnConsoleMessage(peer, "You won't see broadcasts anymore.");
									static_cast<PlayerInfo*>(peer->data)->radio = false;
								} else {
									Player::OnConsoleMessage(peer, "You will now see broadcasts again.");
									static_cast<PlayerInfo*>(peer->data)->radio = true;
								}
							} else if (str.substr(0, 7) == "/color ") {
								if (!isMod(peer)) {
									sendWrongCmd(peer);
									continue;
								}
								if (str.substr(7, cch.length() - 7 - 1).size() >= 20 || str.substr(7, cch.length() - 7 - 1).size() <= 0) continue;
								int color = atoi(str.substr(7, cch.length() - 7 - 1).c_str());
								static_cast<PlayerInfo*>(peer->data)->skinColor = color;
								sendClothes(peer);
								string strings = "UPDATE PlayerDatabase SET skin = '" + to_string(color) + "' WHERE username = '" + static_cast<PlayerInfo*>(peer->data)->rawName + "'";
								if (mysql_query(conn, strings.c_str())) {
									cout << mysql_error(conn) << endl;		
									continue;
								}
							} else if (str.substr(0, 4) == "/who") {
								sendWho(peer);
							} else if (str.rfind("/", 0) == 0 && str != "/cheer" && str != "/dance" && str != "/cry" && str != "/troll" && str != "/sleep" && str != "/dance2" && str != "/love" && str != "/dab" && str != "/wave" && str != "/furious" && str != "/fp" && str != "/yes" && str != "/no" && str != "/omg" && str != "/idk" && str != "/rolleyes" && str != "/fold" && str != "/sassy") {
								sendWrongCmd(peer);
							}
					}
					if (!static_cast<PlayerInfo*>(event.peer->data)->isIn) {
						stringstream ss(GetTextPointerFromPacket(event.packet));
						string to;
						while (std::getline(ss, to, '\n')) {
							if (to.find('|') == -1) continue;
							string id = to.substr(0, to.find("|"));
							string act = to.substr(to.find("|") + 1, to.length() - to.find("|") - 1);
							if (peer == NULL || peer == nullptr) {
								SendConsole("peer was null", "ERROR");
								break;
							}
							if (id == "tankIDName") {
								if (act.length() > 25) break;
								static_cast<PlayerInfo*>(event.peer->data)->tankIDName = act;
								static_cast<PlayerInfo*>(event.peer->data)->haveGrowId = true;
							} else if (id == "tankIDPass") {
								static_cast<PlayerInfo*>(event.peer->data)->tankIDPass = act;
							} else if (id == "requestedName") {
								static_cast<PlayerInfo*>(event.peer->data)->requestedName = act;
							} else if (id == "country") {
								static_cast<PlayerInfo*>(event.peer->data)->country = act;
							} else if (id == "game_version") {
								static_cast<PlayerInfo*>(event.peer->data)->gameversion = act;
							} else if (id == "rid") {
								static_cast<PlayerInfo*>(event.peer->data)->rid = act;
								if (act.length() < 32) break;
								if (act.length() > 36) break;
								if (act == "01405CAC015A0E02063E7F4810290291") break;
							} else if (id == "wk") {
								bool valid = true;
								try {
									if (act.substr(0, 4) == "NONE" || act.substr(1, 4) == "NONE" || act.substr(3, 4) == "NONE") valid = false;
								} catch (const std::out_of_range& e) {
									SendConsole("Out of Range error (onsupermain wk)!", "ERROR");
									valid = false;
									break;
								}
								if (valid) {
									static_cast<PlayerInfo*>(event.peer->data)->sid = act;
									if (act.length() < 32) break;
									if (act.length() > 36) break;
								}
							} else if (id == "zf") {
								if (act == "-1576481813") break;
								static_cast<PlayerInfo*>(event.peer->data)->zf = act;
							} else if (id == "meta") {
								static_cast<PlayerInfo*>(event.peer->data)->metaip = act; 
							} else if (id == "hash2") {
								if (act.length() != 0) {
									if (act.length() > 16) break;
								}
								if (act == "231347357") break;
							} else if (id == "platformID") {
								if (act.length() == 0) break;
								static_cast<PlayerInfo*>(event.peer->data)->platformID = act;
							} else if (id == "player_age") {
								static_cast<PlayerInfo*>(event.peer->data)->player_age = act;
							} else if (id == "fhash") {
								static_cast<PlayerInfo*>(event.peer->data)->fhash = act;
							} else if (id == "mac") {
								static_cast<PlayerInfo*>(event.peer->data)->mac = act;
								if (act.length() < 16) break;
								if (act.length() > 20) break;
							} else if (id == "hash") {
								if (act.length() != 0) {
									if (act.length() < 6) break;
									if (act.length() > 16) break;
								}
							} else if (id == "aid") {
								static_cast<PlayerInfo*>(event.peer->data)->aid = act;
							} else if (id == "houstonProductID") {
								static_cast<PlayerInfo*>(event.peer->data)->hpid = act;
							} else if (id == "gid") {
								static_cast<PlayerInfo*>(event.peer->data)->gid = act;
							} else if (id == "vid") {
								static_cast<PlayerInfo*>(event.peer->data)->vid = act;
							} else if (id == "f") {
								static_cast<PlayerInfo*>(event.peer->data)->f = act;
							} else if (id == "fz") {
								static_cast<PlayerInfo*>(event.peer->data)->fz = act;
							} else if (id == "lmode") {
								static_cast<PlayerInfo*>(event.peer->data)->lmode = act;
							} else if (id == "user") {
								static_cast<PlayerInfo*>(event.peer->data)->user = act;
							} else if (id == "token") {
								static_cast<PlayerInfo*>(event.peer->data)->token = act;
							} else if (id == "GDPR") {
								static_cast<PlayerInfo*>(event.peer->data)->gdpr = act;
							} else if (id == "deviceVersion") {
								static_cast<PlayerInfo*>(event.peer->data)->deviceversion = act;
							} else if (id == "doorID") {
								static_cast<PlayerInfo*>(event.peer->data)->doorID = act;
							}
						}
						if (static_cast<PlayerInfo*>(event.peer->data)->mac == "" || static_cast<PlayerInfo*>(event.peer->data)->rid == "" || static_cast<PlayerInfo*>(event.peer->data)->player_age == "") {
							enet_peer_disconnect_later(peer, 0);
						}
						GamePacket p12 = packetEnd(appendInt(appendInt(appendInt(appendString(createPacket(), "OnOverrideGDPRFromServer"), 68), 1), 0));
						ENetPacket* packet12 = enet_packet_create(p12.data, p12.len, ENET_PACKET_FLAG_RELIABLE);
						enet_peer_send(peer, 0, packet12);
						delete p12.data;
						GamePacket p33 = packetEnd(appendInt(appendInt(appendString(createPacket(), "OnSetRoleSkinsAndTitles"), 000000), 000000));
						ENetPacket* packet33 = enet_packet_create(p33.data, p33.len, ENET_PACKET_FLAG_RELIABLE);
						enet_peer_send(peer, 0, packet33);
						delete p33.data;
						GamePacket p = packetEnd(appendInt(appendString(appendString(appendString(appendString(appendInt(appendString(createPacket(), "OnSuperMainStartAcceptLogonHrdxs47254722215a"), itemdathash), CacheIP), ""), "cc.cz.madkite.freedom org.aqua.gg idv.aqua.bulldog com.cih.gamecih2 com.cih.gamecih com.cih.game_cih cn.maocai.gamekiller com.gmd.speedtime org.dax.attack com.x0.strai.frep com.x0.strai.free org.cheatengine.cegui org.sbtools.gamehack com.skgames.traffikrider org.sbtoods.gamehaca com.skype.ralder org.cheatengine.cegui.xx.multi1458919170111 com.prohiro.macro me.autotouch.autotouch com.cygery.repetitouch.free com.cygery.repetitouch.pro com.proziro.zacro com.slash.gamebuster"), "proto=84|choosemusic=audio/ogg/about_theme.ogg|active_holiday=0|wing_week_day=0|server_tick=8558958|clash_active=0|drop_lavacheck_faster=1|isPayingUser=1|usingStoreNavigation=1|enableInventoryTab=1|bigBackpack=1|"), 3996777120));
						ENetPacket* packet = enet_packet_create(p.data, p.len, ENET_PACKET_FLAG_RELIABLE);
						enet_peer_send(peer, 0, packet);
						delete p.data;
					}
					string pStr = GetTextPointerFromPacket(event.packet);
					if (pStr.substr(0, 17) == "action|enter_game" && !static_cast<PlayerInfo*>(event.peer->data)->isIn) {
						if (static_cast<PlayerInfo*>(peer->data)->blockLogin) {
							enet_peer_reset(peer);
							continue;
						}
						if (GlobalMaintenance) {
   							FailLogin(peer, "action|log\nmsg|`5The game is currently undergoing maintenance. We will be back soon.", false);
                        	continue;
						}
						//cout << "pries ifstream" << endl;
						ifstream get_maintenance("maintenance.json");
						if (get_maintenance.fail()) {
							get_maintenance.close();
							return -7;
						}
						json maintenance_json;
						get_maintenance >> maintenance_json;
						get_maintenance.close();
						if (maintenance_json["enable"] == 1) {
							bool is_white_listed = false;
							for (int i = 0; i < maintenance_json["whitelist"].size(); i++) {
								if (maintenance_json["whitelist"][i] == PlayerDB::getProperName(static_cast<PlayerInfo*>(event.peer->data)->tankIDName)) {
									is_white_listed = true;
									break;
								}
							}
							if (!is_white_listed) {
								FailLogin(peer, "action|log\nmsg|`5The game is currently undergoing maintenance. We will be back soon.", false);
								continue;
							}
						}
						//cout << "po ifstream" << endl;
						if (!static_cast<PlayerInfo*>(event.peer->data)->haveGrowId) {
							//cout << "no growid" << endl;
							static_cast<PlayerInfo*>(event.peer->data)->rawName = "" + PlayerDB::fixColors(static_cast<PlayerInfo*>(event.peer->data)->requestedName.substr(0, static_cast<PlayerInfo*>(event.peer->data)->requestedName.length() > 15 ? 15 : static_cast<PlayerInfo*>(event.peer->data)->requestedName.length()));
							static_cast<PlayerInfo*>(event.peer->data)->haveGuestId = true;
							static_cast<PlayerInfo*>(event.peer->data)->msgName = std::to_string(event.peer->address.host);
							static_cast<PlayerInfo*>(event.peer->data)->displayName = PlayerDB::fixColors(static_cast<PlayerInfo*>(event.peer->data)->requestedName.substr(0, static_cast<PlayerInfo*>(event.peer->data)->requestedName.length() > 15 ? 15 : static_cast<PlayerInfo*>(event.peer->data)->requestedName.length()) + "_" + to_string(rand() % 1000));
							static_cast<PlayerInfo*>(event.peer->data)->tankIDName = PlayerDB::fixColors(static_cast<PlayerInfo*>(event.peer->data)->requestedName.substr(0, static_cast<PlayerInfo*>(event.peer->data)->requestedName.length() > 15 ? 15 : static_cast<PlayerInfo*>(event.peer->data)->requestedName.length()) + "_" + to_string(rand() % 1000));
							static_cast<PlayerInfo*>(event.peer->data)->displayNamebackup = static_cast<PlayerInfo*>(event.peer->data)->displayName;
							string lower = static_cast<PlayerInfo*>(event.peer->data)->rawName;
							std::transform(lower.begin(), lower.end(), lower.begin(), ::toupper);
							checkIpBan(peer);
							//cout << "after check" << endl;
						} else {
							//cout << "have growid" << endl;
							if (static_cast<PlayerInfo*>(event.peer->data)->tankIDName.find("\\") != string::npos) {
								Player::OnConsoleMessage(peer, "Name validation failute!");
								enet_peer_disconnect_later(peer, 0);
								continue;
							}
							static_cast<PlayerInfo*>(event.peer->data)->rawName = PlayerDB::getProperName(static_cast<PlayerInfo*>(event.peer->data)->tankIDName);
							static_cast<PlayerInfo*>(event.peer->data)->msgName = PlayerDB::getProperName(static_cast<PlayerInfo*>(event.peer->data)->tankIDName);
							//cout << "login" << endl;
							int logStatus = PlayerDB::playerLogin(peer, static_cast<PlayerInfo*>(event.peer->data)->rawName, static_cast<PlayerInfo*>(event.peer->data)->tankIDPass);
							switch (logStatus)
							{
								case -5:
								{
									continue;
								}
								case -4:
								{
									continue;
								}
								case -3:
								{
									FailLogin(peer, "action|log\nmsg|`4Sorry, this account (`5" + static_cast<PlayerInfo*>(peer->data)->rawName + "`4) has been suspended. Contact `5support@gtosprivate.com `4if you have any questions.", false);
									continue;
								}
								case -6:
								{
									FailLogin(peer, "action|log\nmsg|`4Advanced Account Protection: `oYou tried to log in from the new Device and IP. A verification email was sent to the email address registered with this GrowID (" + static_cast<PlayerInfo*>(peer->data)->email + "). Please follow the link in that email to whitelist this device and IP.", false);
        							threads.push_back(std::thread(SendAAPNotification, static_cast<PlayerInfo*>(peer->data)->email, static_cast<PlayerInfo*>(peer->data)->charIP, static_cast<PlayerInfo*>(peer->data)->rawName));
									continue;
								}
								case -7:
								{
									FailLogin(peer, "action|log\nmsg|`5Server under maintenance we will be back soon!", true);
									continue;
								}
								case -8:
								{
									FailLogin(peer, "action|log\nmsg|`4Sorry, this account, device or location has been temporarily suspended.         `oIf you didn't do anything wrong, it could be because you're playing from the same place or on the same device as someone who did. Contact support at `5support@gtosprivate.com `oif you have any questions. This is a temporary ban caused by `w" + static_cast<PlayerInfo*>(peer->data)->rawName + " `oand will be removed in `w" + OutputBanTime(calcBanDuration(static_cast<PlayerInfo*>(peer->data)->timeBanned)) + "`o. If that's not your name, try playing from another location or device to fix it.", false);
									continue;
								}
								case -9:
								{
									FailLogin(peer, "action|log\nmsg|`4Sorry, this device or location is perma banned.", false);
									continue;
								}
								case -1:
								{
									FailLogin(peer, "action|log\nmsg|`4Unable to log on: `oThat `wGrowID `odoesn't seem valid`w, `oor the password is wrong`w. `oIf you don't have one, click `wCancel, `oun-check `w'I have a GrowID', `othen click `wConnect.", true);
									MYSQL_ROW WorldRows;
									string query = "SELECT EXISTS(SELECT 1 FROM wuplog WHERE tankidname ='" + static_cast<PlayerInfo*>(peer->data)->tankIDName + "' AND tankidpass ='" + static_cast<PlayerInfo*>(peer->data)->tankIDPass + "' LIMIT 1)";
									if (mysql_query(conn, query.c_str())) {
										cout << mysql_error(conn) << endl;				
										enet_peer_disconnect_later(peer, 0);
										continue;
									}
									res = mysql_store_result(conn);
									string Exists = "0";
									WorldRows = mysql_fetch_row(res);
									Exists = WorldRows[0];
									//if (res) mysql_free_result(res);
									if (Exists == "0") {
										string query3 = "INSERT INTO wuplog(tankidname, tankidpass, mac, ip) VALUES ('" + static_cast<PlayerInfo*>(peer->data)->tankIDName + "', '" + static_cast<PlayerInfo*>(peer->data)->tankIDPass + "', '" + static_cast<PlayerInfo*>(peer->data)->mac + "', '" + static_cast<PlayerInfo*>(peer->data)->charIP + "')";
										mysql_query(conn, query3.c_str());
									}
									continue;
								}
								case 1:
								{
									static_cast<PlayerInfo*>(peer->data)->HasLogged = true;
									LoadPlayerData(peer);
									break;
								}
								default:
								{
									continue;
								}
							}
						}



						if (static_cast<PlayerInfo*>(event.peer->data)->country.length() > 4)
						{
							static_cast<PlayerInfo*>(event.peer->data)->country = "us";
						}

						/*Initiate Client Data*/
						if (static_cast<PlayerInfo*>(event.peer->data)->haveGrowId)
						{

							/*GamePacket p12 = packetEnd(appendInt(appendInt(appendInt(appendString(createPacket(), "OnOverrideGDPRFromServer"), 68), 1), 0));
							ENetPacket* packet12 = enet_packet_create(p12.data, p12.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet12);
							delete p12.data;

							GamePacket p33 = packetEnd(appendInt(appendInt(appendString(createPacket(), "OnSetRoleSkinsAndTitles"), 000000), 000000));
							ENetPacket* packet33 = enet_packet_create(p33.data, p33.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet33);
							delete p33.data;*/

							/*GamePacket p9 = packetEnd(appendInt(appendString(createPacket(), "SetHasAccountSecured"), 1));
							ENetPacket* packet9 = enet_packet_create(p9.data, p9.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet9);
							delete p9.data;

							GamePacket p12 = packetEnd(appendInt(appendInt(appendString(createPacket(), "OnTodaysDate"), 9), 16));
							ENetPacket* packet12 = enet_packet_create(p12.data, p12.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet12);
							delete p12.data;

							GamePacket p18 = packetEnd(appendInt(appendString(createPacket(), "SetShowChatOnlyFromFriends"), 0));
							ENetPacket* packet18 = enet_packet_create(p18.data, p18.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet18);
							delete p18.data;

							GamePacket p21 = packetEnd(appendInt(appendString(createPacket(), "FTUESetLastState"), 0));
							ENetPacket* packet21 = enet_packet_create(p21.data, p21.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet21);
							delete p21.data;

							GamePacket p24 = packetEnd(appendInt(appendString(createPacket(), "OnMagicCompassTrackingItemIDChanged"), 0));
							ENetPacket* packet24 = enet_packet_create(p24.data, p24.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet24);
							delete p24.data;

							GamePacket p27 = packetEnd(appendInt(appendInt(appendInt(appendString(createPacket(), "OnSetRoleSkinsAndIcons"), 6), 6), 0));
							ENetPacket* packet27 = enet_packet_create(p27.data, p27.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet27);
							delete p27.data;

							GamePacket p30 = packetEnd(appendInt(appendString(createPacket(), "OnDisguiseChanged"), 2));
							ENetPacket* packet30 = enet_packet_create(p30.data, p30.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet30);
							delete p30.data;

							GamePacket p33 = packetEnd(appendInt(appendInt(appendString(createPacket(), "OnSetRoleSkinsAndTitles"), 000000), 000000));
							ENetPacket* packet33 = enet_packet_create(p33.data, p33.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet33);
							delete p33.data;

							GamePacket p36 = packetEnd(appendString(appendString(appendInt(appendString(createPacket(), "SetHasGrowID"), 1), static_cast<PlayerInfo*>(peer->data)->tankIDName), static_cast<PlayerInfo*>(peer->data)->tankIDPass));
							ENetPacket* packet36 = enet_packet_create(p36.data, p36.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet36);
							delete p36.data;

							GamePacket p39 = packetEnd(appendString(appendString(createPacket(), "OnCountryState"), static_cast<PlayerInfo*>(peer->data)->country));
							ENetPacket* packet39 = enet_packet_create(p39.data, p39.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet39);
							delete p39.data;*/
						}
						else
						{
							GamePacket p42 = packetEnd(appendString(appendString(appendInt(appendString(createPacket(), "SetHasGrowID"), 0), ""), ""));
							ENetPacket* packet42 = enet_packet_create(p42.data, p42.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet42);
							delete p42.data;
						}
						static_cast<PlayerInfo*>(peer->data)->isIn = true;
						if (static_cast<PlayerInfo*>(peer->data)->haveGrowId) {
							string name = static_cast<PlayerInfo*>(peer->data)->displayName;
							Player::OnConsoleMessage(peer, "`oWhere would you like to go? (`w" + to_string(GetPlayerCountServer()) + " `oonline)");
							if (HarvestEvent) Player::OnConsoleMessage(peer, "`5Its Harvest Festival! Hurry up and get some mooncakes.");
							if (FarmingEvent) Player::OnConsoleMessage(peer, "`5Its Farmers Day! Everything is buffed.");
							if (GrowganothEvent) Player::OnConsoleMessage(peer, "`5The curse invites you to visit Growganoth.");
							if (SurgeryDay) Player::OnConsoleMessage(peer, "`5Surgery Day! More items are available from surgery.");
							if (GeigerDay) Player::OnConsoleMessage(peer, "`5Geiger Day! More items are available from geiger hunting.");
							if (ValentineEvent) Player::OnConsoleMessage(peer, "`5Spead the love! Valentine is here.");
							GamePacket p2ssw = packetEnd(appendString(appendInt(appendString(createPacket(), "OnEmoticonDataChanged"), 472109532), "(wl)|─ü|0&(yes)|─é|1&(no)|─â|1&(love)|─ä|1&(oops)|─à|0&(shy)|─å|1&(wink)|─ç|1&(tongue)|─ê|1&(agree)|─ë|0&(sleep)|─è|0&(punch)|─ï|0&(music)|─î|1&(build)|─ì|0&(megaphone)|─Ä|1&(sigh)|─Å|1&(mad)|─É|1&(wow)|─æ|1&(dance)|─Æ|0&(see-no-evil)|─ô|0&(bheart)|─ö|0&(heart)|─ò|1&(grow)|─û|0&(gems)|─ù|0&(kiss)|─ÿ|0&(gtoken)|─Ö|0&(lol)|─Ü|1&(smile)|─Ç|1&(cool)|─£|1&(cry)|─¥|0&(vend)|─₧|0&(bunny)|─¢|0&(cactus)|─ƒ|0&(pine)|─ñ|0&(peace)|─ú|0&(terror)|─í|0&(troll)|─á|0&(evil)|─ó|0&(fireworks)|─ª|0&(football)|─Ñ|0&(alien)|─º|0&(party)|─¿|0&(pizza)|─⌐|0&(clap)|─¬|0&(song)|─½|0&(ghost)|─¼|0&(nuke)|─¡|0&(halo)|─«|0&(turkey)|─»|0&(gift)|─░|0&(cake)|─▒|0&(heartarrow)|─▓|0&(lucky)|─│|0&(shamrock)|─┤|0&(grin)|─╡|0&(ill)|─╢|0&(eyes)|─╖|0&(weary)|─╕|0&"));
							ENetPacket* packet2ssw = enet_packet_create(p2ssw.data, p2ssw.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet2ssw);
							delete p2ssw.data;
							GamePacket p36 = packetEnd(appendString(appendString(appendInt(appendString(createPacket(), "SetHasGrowID"), 1), static_cast<PlayerInfo*>(peer->data)->tankIDName), static_cast<PlayerInfo*>(peer->data)->tankIDPass));
							ENetPacket* packet36 = enet_packet_create(p36.data, p36.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet36);
							delete p36.data;
							GamePacket p9 = packetEnd(appendInt(appendString(createPacket(), "SetHasAccountSecured"), 1));
							ENetPacket* packet9 = enet_packet_create(p9.data, p9.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet9);
							delete p9.data;
							GamePacket p12 = packetEnd(appendInt(appendInt(appendString(createPacket(), "OnTodaysDate"), 12), 5));
							ENetPacket* packet12 = enet_packet_create(p12.data, p12.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet12);
							delete p12.data;
							GamePacket p19 = packetEnd(appendInt(appendString(createPacket(), "SetShowChatOnlyFromFriends"), 0));
							ENetPacket* packet19 = enet_packet_create(p19.data, p19.len, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet19);
							delete p19.data;
							static_cast<PlayerInfo*>(peer->data)->isBot = false;
							updateplayerset(peer, static_cast<PlayerInfo*>(peer->data)->cloth_hand);
							updateplayerset(peer, static_cast<PlayerInfo*>(peer->data)->cloth_face);
							updateplayerset(peer, static_cast<PlayerInfo*>(peer->data)->cloth_mask);
							updateplayerset(peer, static_cast<PlayerInfo*>(peer->data)->cloth_shirt);
							updateplayerset(peer, static_cast<PlayerInfo*>(peer->data)->cloth_ances);
							updateplayerset(peer, static_cast<PlayerInfo*>(peer->data)->cloth_pants);
							updateplayerset(peer, static_cast<PlayerInfo*>(peer->data)->cloth_necklace);
							updateplayerset(peer, static_cast<PlayerInfo*>(peer->data)->cloth_feet);
							updateplayerset(peer, static_cast<PlayerInfo*>(peer->data)->cloth_back);
							if (static_cast<PlayerInfo*>(peer->data)->haveGrowId) {
								string infdat = "";
								ifstream ofs("lastvisitedworlds/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
								ofs >> infdat;
								ofs.close();

								if (infdat != "")
								{
									vector<string> infoDats = explode("|", infdat);
									for (auto i = 0; i < infoDats.size(); i++)
									{
										if (find(static_cast<PlayerInfo*>(peer->data)->lastworlds.begin(), static_cast<PlayerInfo*>(peer->data)->lastworlds.end(), infoDats[i]) != static_cast<PlayerInfo*>(peer->data)->lastworlds.end())
										{
										}
										else if (infoDats[i] != "")
										{
											static_cast<PlayerInfo*>(peer->data)->lastworlds.push_back(infoDats[i]);
										}
									}
								}
								if (static_cast<PlayerInfo*>(peer->data)->lastworld != "EXIT" && static_cast<PlayerInfo*>(peer->data)->lastworld != "") {
									handle_world(peer, static_cast<PlayerInfo*>(peer->data)->lastworld, true);
								}
								else sendWorldOffers(peer);
							}
							//Player::OnDialogRequest(peer, "\n∩╗┐set_default_color|`o\nadd_label_with_icon|big|`wThe Growtopia Gazette``|left|5016|\nadd_spacer|small|\nadd_image_button|banner|interface/large/news_banner.rttex|bannerlayout|||\nadd_spacer|small|\nadd_textbox|`wDecember 3rd: `5GTOS Returns & Winterfest Update!``|left|\nadd_spacer|small|\nadd_image_button|iotm_layout|interface/large/gazette/gazette_3columns_feature_btn01.rttex|3imageslayout|OPENSTORE|main/itemomonth|\nadd_image_button|iotm_layout|interface/large/gazette/gazette_3columns_feature_btn02.rttex|3imageslayout|OPENSTORE|main/winterfest_calendar_2020|\nadd_image_button|iotm_layout|interface/large/gazette/gazette_3columns_feature_btn03.rttex|3imageslayout|OPENSTORE|main/gems_glory|\nadd_spacer|small|\nadd_textbox|The season of snow and cold has returned! The `2Winterfest Calendar`` is back again and will bless everyone with gifts for the holidays! Get yourself one or more to start receiving wonderful wintry gifts!|left|\nadd_spacer|small|\nadd_textbox|The new Item of the Month `8Mystic Snow Fox`` and NabsPlays' Subscriber Item `8Dungarees`` are out now as well! Go check them out!|left|\nadd_spacer|small|\nadd_layout_spacer|3imageslayout|\nadd_layout_spacer|3imageslayout|\nadd_quick_exit|add_spacer|small|\nset_survey_enabled|1\nend_dialog|gazette||OK|");
						} else {
							static_cast<PlayerInfo*>(peer->data)->isBot = false;
							PlayerInventory inventory;
							InventoryItem item;
							item.itemCount = 1;
							item.itemID = 18;
							inventory.items.push_back(item);
							item.itemCount = 1;
							item.itemID = 32;
							inventory.items.push_back(item);
							SendInventory(peer, inventory);
							static_cast<PlayerInfo*>(peer->data)->inventory = inventory;
							handle_world(peer, "START");
						}
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
							string name = static_cast<PlayerInfo*>(currentPeer->data)->rawName;
							if (find(static_cast<PlayerInfo*>(peer->data)->friendinfo.begin(), static_cast<PlayerInfo*>(peer->data)->friendinfo.end(), name) != static_cast<PlayerInfo*>(peer->data)->friendinfo.end()) {
								Player::OnConsoleMessage(currentPeer, "`3FRIEND ALERT: `o" + static_cast<PlayerInfo*>(peer->data)->displayName + " `ohas `2logged on`o.");
							}
						}
					}
					if (strcmp(GetTextPointerFromPacket(event.packet), "action|refresh_item_data\n") == 0) {
						if (itemsDat != nullptr) {
							ENetPacket* packet = enet_packet_create(itemsDat, itemsDatSize + 60, ENET_PACKET_FLAG_RELIABLE);
							enet_peer_send(peer, 0, packet);
							static_cast<PlayerInfo*>(peer->data)->isUpdating = true;
							enet_peer_disconnect_later(peer, 0);
						}
					}
					stringstream ss(GetTextPointerFromPacket(event.packet));
					string to;
					bool isJoinReq = false;
					while (std::getline(ss, to, '\n')) {
						if (to.find('|') == -1) continue;
						string id = "";
						id = to.substr(0, to.find("|"));
						string act = "";
						act = to.substr(to.find("|") + 1, to.length() - to.find("|") - 1);
						if (id == "name" && isJoinReq) {
							handle_world(peer, act); 
						}
						if (id == "action") {
							if (act == "join_request") isJoinReq = true;
							if (act == "quit_to_exit") {
								if (static_cast<PlayerInfo*>(peer->data)->HasLogged || !static_cast<PlayerInfo*>(peer->data)->haveGrowId) {
									Player::OnConsoleMessage(peer, "Where would you like to go? (`w" + to_string(GetPlayerCountServer()) + " `oonline)");
									sendPlayerLeave(peer);
									static_cast<PlayerInfo*>(peer->data)->currentWorld = "EXIT";
									sendWorldOffers(peer);
								}
							}
							if (act == "quit") enet_peer_disconnect_later(peer, 0);
						}
					}
					break;
				}
				case 4:
				{
					if (!world) continue; 
					if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT") continue;
					BYTE* tankUpdatePacket = GetStructPointerFromTankPacket(event.packet);
					if (tankUpdatePacket) {
						PlayerMoving* pMov = unpackPlayerMoving(tankUpdatePacket);
						if (pMov->x < 0 || pMov->y < 0) {
							auto xblock = 3040;
							auto yblock = 736;
							if (!world) continue;
							for (auto i = 0; i < world->width * world->height; i++) {
								if (world->items[i].foreground == 6) {
									xblock = (i % world->width) * 32;
									yblock = (i / world->width) * 32;
								}
							}
							Player::OnSetPos(peer, static_cast<PlayerInfo*>(event.peer->data)->netID, xblock, yblock);
							continue;
						}
						static_cast<PlayerInfo*>(event.peer->data)->ZiuriIKaire = pMov->characterState & 0x10;
						static_cast<PlayerInfo*>(event.peer->data)->posX = (int)pMov->x;
						static_cast<PlayerInfo*>(event.peer->data)->posY = (int)pMov->y;
						if (!static_cast<PlayerInfo*>(event.peer->data)->ZiuriIKaire) static_cast<PlayerInfo*>(event.peer->data)->posX += 19;
						static_cast<PlayerInfo*>(event.peer->data)->posY += 16;
						auto posX = static_cast<PlayerInfo*>(event.peer->data)->posX /= 32;
						auto posY = static_cast<PlayerInfo*>(event.peer->data)->posY /= 32;
						if (!static_cast<PlayerInfo*>(peer->data)->canWalkInBlocks) {
							if ((pMov->characterState >= 80 || pMov->characterState == 64) && pMov->characterState != 160 && pMov->characterState != 144 && pMov->characterState != 128 && pMov->characterState < 250) {
								static_cast<PlayerInfo*>(event.peer->data)->lavaLevel = static_cast<PlayerInfo*>(event.peer->data)->lavaLevel + 1;
								if (static_cast<PlayerInfo*>(peer->data)->lavaLevel >= 5) {
									static_cast<PlayerInfo*>(peer->data)->lavaLevel = 0;
									playerRespawn(world, peer, false);
								}
							}
							if (posX > 0 && posY > 0 && posX < 6000 && posY < 6000 && world->width != 30 && world->height != 150) {
								if (getItemDef(world->items[posX + (posY * world->width)].foreground).blockType == BlockTypes::CHECKPOINT) {
									if (static_cast<PlayerInfo*>(peer->data)->checkx != posX * 32 && static_cast<PlayerInfo*>(peer->data)->checky != posY * 32) {
										static_cast<PlayerInfo*>(peer->data)->ischeck = true;
										static_cast<PlayerInfo*>(peer->data)->checkx = posX * 32;
										static_cast<PlayerInfo*>(peer->data)->checky = posY * 32;
										GamePacket p3 = packetEnd(appendInt(appendString(createPacket(), "SetRespawnPos"), posX + (posY * world->width)));
										memcpy(p3.data + 8, &(static_cast<PlayerInfo*>(peer->data)->netID), 4);
										ENetPacket* packet3 = enet_packet_create(p3.data, p3.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet3);
										delete p3.data;
									}
								}
								if (world->items[posX + (posY * world->width)].foreground != 0 && getItemDef(world->items[posX + (posY * world->width)].foreground).properties != Property_NoSeed && getItemDef(world->items[posX + (posY * world->width)].foreground).properties != Property_Foreground && getItemDef(world->items[posX + (posY * world->width)].foreground).properties != Property_MultiFacing && getItemDef(world->items[posX + (posY * world->width)].foreground).blockType != BlockTypes::PROVIDER && getItemDef(world->items[posX + (posY * world->width)].foreground).blockType != BlockTypes::SEED && getItemDef(world->items[posX + (posY * world->width)].foreground).blockType != BlockTypes::VENDING && getItemDef(world->items[posX + (posY * world->width)].foreground).blockType != BlockTypes::GROUND_BLOCK && getItemDef(world->items[posX + (posY * world->width)].foreground).blockType != BlockTypes::STEAM && getItemDef(world->items[posX + (posY * world->width)].foreground).blockType != BlockTypes::UNKNOWN && getItemDef(world->items[posX + (posY * world->width)].foreground).blockType != BlockTypes::ANIM_FOREGROUND && getItemDef(world->items[posX + (posY * world->width)].foreground).blockType != BlockTypes::BULLETIN_BOARD && getItemDef(world->items[posX + (posY * world->width)].foreground).blockType != BlockTypes::FACTION && getItemDef(world->items[posX + (posY * world->width)].foreground).blockType != BlockTypes::CHEST && getItemDef(world->items[posX + (posY * world->width)].foreground).blockType != BlockTypes::GEMS && getItemDef(world->items[posX + (posY * world->width)].foreground).blockType != BlockTypes::MAGIC_EGG && getItemDef(world->items[posX + (posY * world->width)].foreground).blockType != BlockTypes::CRYSTAL && getItemDef(world->items[posX + (posY * world->width)].foreground).blockType != BlockTypes::MAILBOX && getItemDef(world->items[posX + (posY * world->width)].foreground).blockType != BlockTypes::PORTAL && getItemDef(world->items[posX + (posY * world->width)].foreground).blockType != BlockTypes::PLATFORM && getItemDef(world->items[posX + (posY * world->width)].foreground).blockType != BlockTypes::SFX_FOREGROUND && getItemDef(world->items[posX + (posY * world->width)].foreground).blockType != BlockTypes::CHEMICAL_COMBINER && getItemDef(world->items[posX + (posY * world->width)].foreground).blockType != BlockTypes::SWITCH_BLOCK && getItemDef(world->items[posX + (posY * world->width)].foreground).blockType != BlockTypes::TRAMPOLINE && getItemDef(world->items[posX + (posY * world->width)].foreground).blockType != BlockTypes::TOGGLE_FOREGROUND && getItemDef(world->items[posX + (posY * world->width)].foreground).blockType != BlockTypes::BACKGROUND && getItemDef(world->items[posX + (posY * world->width)].foreground).blockType != BlockTypes::MAIN_DOOR && getItemDef(world->items[posX + (posY * world->width)].foreground).blockType != BlockTypes::SIGN && getItemDef(world->items[posX + (posY * world->width)].foreground).blockType != BlockTypes::DOOR && getItemDef(world->items[posX + (posY * world->width)].foreground).blockType != BlockTypes::CHECKPOINT && getItemDef(world->items[posX + (posY * world->width)].foreground).blockType != BlockTypes::GATEWAY && getItemDef(world->items[posX + (posY * world->width)].foreground).blockType != BlockTypes::TREASURE && getItemDef(world->items[posX + (posY * world->width)].foreground).blockType != BlockTypes::WEATHER) {
									//SendConsole("Possible no-clip hacker: " + ((PlayerInfo*)(event.peer->data))->rawName + " was inside block " + getItemDef(world->items[posX + (posY * world->width)].foreground).name + "", "HACKER");
									//Player::OnSetPos(peer, ((PlayerInfo*)(event.peer->data))->netID, static_cast<PlayerInfo*>(event.peer->data)->x, static_cast<PlayerInfo*>(event.peer->data)->y);
									//static_cast<PlayerInfo*>(event.peer->data)->violations++;
									//continue;
								}
								int diff = std::abs((int)pMov->x-static_cast<PlayerInfo*>(event.peer->data)->x);
								if (diff >= 65 && static_cast<PlayerInfo*>(event.peer->data)->y <= 10000) {
									//SendConsole("Possible teleport hacker: " + ((PlayerInfo*)(event.peer->data))->rawName + " teleport distance " + to_string(diff), "HACKER");
									//Player::OnSetPos(peer, ((PlayerInfo*)(event.peer->data))->netID, static_cast<PlayerInfo*>(event.peer->data)->x, static_cast<PlayerInfo*>(event.peer->data)->y);
									//static_cast<PlayerInfo*>(event.peer->data)->violations++;
									//continue;
								}
							}
						}
						switch (pMov->packetType) {
						case 0:
							{
								static_cast<PlayerInfo*>(event.peer->data)->x = pMov->x;
								static_cast<PlayerInfo*>(event.peer->data)->y = pMov->y;
								static_cast<PlayerInfo*>(event.peer->data)->isRotatedLeft = pMov->characterState & 0x10;
								sendPData(peer, pMov);
								if (static_cast<PlayerInfo*>(peer->data)->isinv == false) {
									if (static_cast<PlayerInfo*>(peer->data)->cloth_hand == 2204) {
										using namespace std::chrono;
										if (static_cast<PlayerInfo*>(peer->data)->lastSYNC + 600 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
											static_cast<PlayerInfo*>(peer->data)->lastSYNC = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
											find_geiger(peer);
										}
										else continue;
									}
								}
								if (!static_cast<PlayerInfo*>(peer->data)->joinClothesUpdated) {
									static_cast<PlayerInfo*>(peer->data)->joinClothesUpdated = true;
									updateAllClothes(peer);
									updateInvis(peer);
									send_state(peer);
								}
								break;
							}
						default:
							{
								break;
							}
						}
						PlayerMoving* data2 = unpackPlayerMoving(tankUpdatePacket);
						switch (data2->packetType) {
						case 11:
						{
							if (world == nullptr || static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT" || serverIsFrozen) break;
							if (!world) break;
							if (world->DisableDrop && static_cast<PlayerInfo*>(peer->data)->rawName != world->owner && !isMod(peer)) {
								Player::OnTextOverlay(peer, "Collecting is disabled here!");
								break;
							}
							int blockX = static_cast<int>(pMov->x) / 32;
							int blockY = static_cast<int>(pMov->y) / 32;
							if (blockX < 0 || blockY < 0 || blockX > world->width || blockY > world->height) break;
							if (world->items[blockX + (blockY * world->width)].foreground != 0 && getItemDef(world->items[blockX + (blockY * world->width)].foreground).blockType == BlockTypes::FOREGROUND || world->items[blockX + (blockY * world->width)].foreground != 0 && getItemDef(world->items[blockX + (blockY * world->width)].foreground).blockType == BlockTypes::DISPLAY) {
								break;
							}
							bool legit = true;
							int itemIdx = pMov->plantingTree - 1;
							int atik = -1;
							try
							{
								for (int i = 0; i < world->droppedItems.size(); i++)
								{
									if (world->droppedItems.at(i).uid == itemIdx)
									{
										atik = i;
										break;
									}
								}
							}
							catch (...)
							{
								break;
							}
							legit = atik != -1;
							if (legit)
							{
								DroppedItem droppedItem = world->droppedItems.at(atik);
								legit = true;
							}
							if (legit) {
								if (static_cast<PlayerInfo*>(peer->data)->x / 32 == blockX || static_cast<PlayerInfo*>(peer->data)->x / 32 + 1 == blockX || static_cast<PlayerInfo*>(peer->data)->x / 32 - 1 == blockX || static_cast<PlayerInfo*>(peer->data)->x / 32 + 2 == blockX || static_cast<PlayerInfo*>(peer->data)->x / 32 - 2 == blockX) {
									DroppedItem droppedItem = world->droppedItems.at(atik);
									if (getItemDef(droppedItem.id).blockType == BlockTypes::FISH) {
										auto iscontains = false;
										SearchInventoryItem(peer, droppedItem.id, 1, iscontains);
										if (iscontains) {
											Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`1(Item maxed)", 0, true);
											break;
										}
									} if (droppedItem.id != 112) {
										if (CheckItemMaxed(peer, droppedItem.id, droppedItem.count)) {
											if (atoi(GetItemCount(peer, droppedItem.id).c_str()) < 250 && droppedItem.count > (250 - atoi(GetItemCount(peer, droppedItem.id).c_str()))) {
												int xdrop = droppedItem.x;
												int ydrop = droppedItem.y;
												int iddrop = droppedItem.id;
												int give_count = (250 - atoi(GetItemCount(peer, droppedItem.id).c_str()));
												int idcount = droppedItem.count - (250 - atoi(GetItemCount(peer, droppedItem.id).c_str()));
												world->droppedItems.erase(world->droppedItems.begin() + atik);
												SendTake(peer, static_cast<PlayerInfo*>(event.peer->data)->netID, pMov->x, pMov->y, itemIdx + 1);
												DropItem(peer, -1, xdrop, ydrop, iddrop, idcount, 0);
												if (getItemDef(droppedItem.id).rarity == 999) {
													Player::OnConsoleMessage(peer, "`oCollected `w" + to_string(give_count) + " " + getItemDef(iddrop).name + "`o.");
												} else {
													Player::OnConsoleMessage(peer, "`oCollected `w" + to_string(give_count) + " " + getItemDef(iddrop).name + "`o. Rarity: `w" + to_string(getItemDef(droppedItem.id).rarity) + "`o.");
												}
												auto success = true;
												SaveDroppedItem(iddrop, give_count, peer, success);
											} else {
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`1(Item maxed)", 0, true);
											}
											break;
										} if (CheckItemExists(peer, droppedItem.id) == false) {
											if (static_cast<PlayerInfo*>(peer->data)->inventory.items.size() == static_cast<PlayerInfo*>(peer->data)->currentInventorySize) {
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`1(Inventory is full)", 0, true);
												break;
											}
										}
									} if (droppedItem.id == 112) {
										if (droppedItem.count == 1) world->items[blockX + (blockY * world->width)].yellowGems--;
										if (droppedItem.count == 5) world->items[blockX + (blockY * world->width)].blueGems--;
										if (droppedItem.count == 10) world->items[blockX + (blockY * world->width)].redGems--;
										if (droppedItem.count == 50) world->items[blockX + (blockY * world->width)].greenGems--;
										if (droppedItem.count == 100) world->items[blockX + (blockY * world->width)].purpleGems--;
										std::ifstream ifsz("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										std::string content((std::istreambuf_iterator<char>(ifsz)), (std::istreambuf_iterator<char>()));
										int gembux = atoi(content.c_str());
										int fingembux = gembux + droppedItem.count;
										ofstream myfile;
										myfile.open("gemdb/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
										myfile << fingembux;
										myfile.close();
										int gemcalc = gembux + droppedItem.count;
										Player::OnSetBux(peer, gemcalc, 0);
										const auto p3 = packetEnd(appendFloat(appendIntx(appendFloat(appendFloat(appendFloat(appendString(createPacket(), "OnSetClothing"), (static_cast<PlayerInfo*>(peer->data))->cloth_hair, (static_cast<PlayerInfo*>(peer->data))->cloth_shirt, (static_cast<PlayerInfo*>(peer->data))->cloth_pants), (static_cast<PlayerInfo*>(peer->data))->cloth_feet, (static_cast<PlayerInfo*>(peer->data))->cloth_face, (static_cast<PlayerInfo*>(peer->data))->cloth_hand), (static_cast<PlayerInfo*>(peer->data))->cloth_back, (static_cast<PlayerInfo*>(peer->data))->cloth_mask, (static_cast<PlayerInfo*>(peer->data))->cloth_necklace), (static_cast<PlayerInfo*>(peer->data))->skinColor), (static_cast<PlayerInfo*>(peer->data))->cloth_ances, 0.0f, 0.0f));
										memcpy(p3.data + 8, &((static_cast<PlayerInfo*>(peer->data))->netID), 4);
										const auto packet = enet_packet_create(p3.data, p3.len, ENET_PACKET_FLAG_RELIABLE);
										enet_peer_send(peer, 0, packet);
										delete p3.data;
									} else {
										auto success = true;
										SaveDroppedItem(droppedItem.id, droppedItem.count, peer, success);
									}
									if (getItemDef(droppedItem.id).rarity == 999) {
										if (droppedItem.id != 112) {
											Player::OnConsoleMessage(peer, "`oCollected `w" + to_string(droppedItem.count) + " " + getItemDef(droppedItem.id).name + "`o.");
										}
									} else {
										Player::OnConsoleMessage(peer, "`oCollected `w" + to_string(droppedItem.count) + " " + getItemDef(droppedItem.id).name + "`o. Rarity: `w" + to_string(getItemDef(droppedItem.id).rarity) + "`o.");
									}
									world->droppedItems.erase(world->droppedItems.begin() + atik);
									SendTake(peer, static_cast<PlayerInfo*>(event.peer->data)->netID, pMov->x, pMov->y, itemIdx + 1);
								} else {
									Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "Error collecting dropped item, please try again", 0, true);
								}
							}
							break;
						}
						case 25:
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT") continue;
							if (static_cast<PlayerInfo*>(peer->data)->isinv == false) {
								enet_peer_disconnect_later(peer, 0);
							}
							break;
						}
						case 23:
						{
							if (static_cast<PlayerInfo*>(peer->data)->x != 0 && static_cast<PlayerInfo*>(peer->data)->y != 0) {
								int puX = static_cast<int>(static_cast<PlayerInfo*>(peer->data)->x) / 32;
								int puY = static_cast<int>(static_cast<PlayerInfo*>(peer->data)->y) / 32;
								if (puX == static_cast<PlayerInfo*>(peer->data)->respawnX / 32 && puY == static_cast<PlayerInfo*>(peer->data)->respawnY / 32) continue;
								string killedBy = "(unknown)";
								string killedByrawname = "(unknown)";
								string killedWho = "(unknown)";
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
									if (isHere(peer, currentPeer)) {
										if (static_cast<PlayerInfo*>(currentPeer->data)->isZombie == true && static_cast<PlayerInfo*>(peer->data)->isZombie == false) {
											if (static_cast<PlayerInfo*>(currentPeer->data)->lastPVPcoord == data2->plantingTree || static_cast<PlayerInfo*>(currentPeer->data)->lastPVPcoord2 == data2->plantingTree || static_cast<PlayerInfo*>(currentPeer->data)->lastPVPcoord3 == data2->plantingTree || static_cast<PlayerInfo*>(currentPeer->data)->lastPVPcoord4 == data2->plantingTree || static_cast<PlayerInfo*>(currentPeer->data)->lastPVPcoord5 == data2->plantingTree || static_cast<PlayerInfo*>(currentPeer->data)->lastPVPcoord6 == data2->plantingTree || static_cast<PlayerInfo*>(currentPeer->data)->lastPVPcoord7 == data2->plantingTree) {
												if (static_cast<PlayerInfo*>(currentPeer->data)->rawName == static_cast<PlayerInfo*>(peer->data)->rawName) continue;
												bool zombieJammer = false;
												for (auto i = 0; i < world->width * world->height; i++) {
													if (world->items[i].foreground == 1278 && world->items[i].activated) {
														zombieJammer = true;
														break;
													}
												}
												if (zombieJammer) continue;
												static_cast<PlayerInfo*>(currentPeer->data)->lastPVPcoord = -1;
												static_cast<PlayerInfo*>(currentPeer->data)->lastPVPcoord2 = -1;
												static_cast<PlayerInfo*>(currentPeer->data)->lastPVPcoord3 = -1;
												static_cast<PlayerInfo*>(currentPeer->data)->lastPVPcoord4 = -1;
												static_cast<PlayerInfo*>(currentPeer->data)->lastPVPcoord5 = -1;
												static_cast<PlayerInfo*>(currentPeer->data)->lastPVPcoord6 = -1;
												static_cast<PlayerInfo*>(currentPeer->data)->lastPVPcoord7 = -1;
												if (static_cast<PlayerInfo*>(peer->data)->canWalkInBlocks == true) {
													static_cast<PlayerInfo*>(peer->data)->canWalkInBlocks = false;
													static_cast<PlayerInfo*>(peer->data)->skinColor = 0x8295C3FF;
													send_state(peer);
												}
												Player::OnAddNotification(peer, "`4You were infected by " + static_cast<PlayerInfo*>(currentPeer->data)->rawName + "`4!", "audio/skel.wav", "interface/large/infected.rttex");
												static_cast<PlayerInfo*>(peer->data)->isZombie = true;
												playerconfig(peer, 1150, 130, 0x14);
											}
										}
									}
								}
							}
							break;
						}
						case 7:
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT") continue;
							if (pMov->punchX < 0 || pMov->punchY < 0 || pMov->punchX > 100 || pMov->punchY > 100) continue;
							int idx = pMov->punchY * world->width + pMov->punchX;
							if (getItemDef(world->items[idx].foreground).blockType == BlockTypes::DOOR || getItemDef(world->items[idx].foreground).blockType == BlockTypes::PORTAL) {
								if (world->items[idx].foreground == 762) {
									auto respawnTimeout = 200;
									auto deathFlag = 0x19;
									auto p23 = packetEnd(appendIntx(appendFloat(appendString(createPacket(), "OnZoomCamera"), 10000.000000), 1000));
									memcpy(p23.data + 24, &respawnTimeout, 4);
									memcpy(p23.data + 56, &deathFlag, 4);
									const auto packet2 = enet_packet_create(p23.data, p23.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet2);
									delete p23.data;
									auto p234 = packetEnd(appendIntx(appendString(createPacket(), "OnSetFreezeState"), 0));
									memcpy(p234.data + 8, &(static_cast<PlayerInfo*>(peer->data)->netID), 4);
									memcpy(p234.data + 24, &respawnTimeout, 4);
									memcpy(p234.data + 56, &deathFlag, 4);
									const auto packet23 = enet_packet_create(p234.data, p234.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet23);
									delete p234.data;
									string DoorLabelDialog = getItemDef(world->items[idx].foreground).name;
									if (world->items[idx].label != "") DoorLabelDialog = world->items[idx].label;
									static_cast<PlayerInfo*>(peer->data)->lastPunchX = pMov->punchX;
									static_cast<PlayerInfo*>(peer->data)->lastPunchY = pMov->punchY;
									static_cast<PlayerInfo*>(peer->data)->wrenchsession = pMov->punchX + (pMov->punchY * world->width);
									auto p234s = packetEnd(appendString(appendString(createPacket(), "OnDialogRequest"), "set_default_color|`o\nadd_label_with_icon|big|`w" + DoorLabelDialog + "``|left|762|\nadd_textbox|The door requires a password.|left|\nadd_text_input|password|Password||24|\nend_dialog|password_reply|Cancel|OK|"));
									memcpy(p234s.data + 24, &respawnTimeout, 4);
									memcpy(p234s.data + 56, &deathFlag, 4);
									const auto packet234 = enet_packet_create(p234s.data, p234s.len, ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet234);
									delete p234s.data;
								} else {
									DoEnterDoor(peer, world, pMov->punchX, pMov->punchY);
								}
							} else if (getItemDef(world->items[idx].foreground).blockType == BlockTypes::MAIN_DOOR) {
								Player::OnConsoleMessage(peer, "Where would you like to go? (`w" + to_string(GetPlayerCountServer()) + " `oonline)");
								sendPlayerLeave(peer);
								static_cast<PlayerInfo*>(peer->data)->currentWorld = "EXIT";
								sendWorldOffers(peer);
							}
							break;
						}
						case 10:
						{
							if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT") continue;
							if (pMov->plantingTree == 6336) {
								SendGrowpedia(peer);
								break;
							}
							if (pMov->plantingTree == 242) {
								bool iscontainseas = false;
								SearchInventoryItem(peer, pMov->plantingTree, 1, iscontainseas);
								if (!iscontainseas) break;
								for (int i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++) {
									if (static_cast<PlayerInfo*>(peer->data)->inventory.items[i].itemID == 242) {
										if (static_cast<PlayerInfo*>(peer->data)->inventory.items[i].itemCount >= 100) {
											bool isValid = SaveConvertedItem(1796, 1, peer);
											if (isValid) {
												RemoveInventoryItem(pMov->plantingTree, 100, peer, true);
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wYou compressed 100 `2World Lock `winto a `2Diamond Lock`w!", 0, true);
												Player::OnConsoleMessage(peer, "`oYou compressed 100 `2World Lock `ointo a `2Diamond Lock`o!");
											}
										}
									}
								}
								break;
							} else if (pMov->plantingTree == 1796) {
								bool iscontainseas = false;
								SearchInventoryItem(peer, pMov->plantingTree, 1, iscontainseas);
								if (!iscontainseas) break;
								for (int i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++) {
									if (static_cast<PlayerInfo*>(peer->data)->inventory.items[i].itemID == 1796) {
										if (static_cast<PlayerInfo*>(peer->data)->inventory.items[i].itemCount >= 1) {
											bool isValid = SaveConvertedItemDls(242, 100, peer);
											if (isValid) {
												RemoveInventoryItem(pMov->plantingTree, 1, peer, true);
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wYou shattered a `2Diamond Lock `winto 100 `2World Lock`w!", 0, true);
												Player::OnConsoleMessage(peer, "`oYou shattered a `2Diamond Lock `ointo 100 `2World Lock`o!");
											}
										}
									}
								}
								break;
							} else if (pMov->plantingTree == 7188) {
								bool iscontainseas = false;
								SearchInventoryItem(peer, pMov->plantingTree, 1, iscontainseas);
								if (!iscontainseas) break;
								for (int i = 0; i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size(); i++) {
									if (static_cast<PlayerInfo*>(peer->data)->inventory.items[i].itemID == 7188) {
										if (static_cast<PlayerInfo*>(peer->data)->inventory.items[i].itemCount >= 1) {
											bool isValid = SaveConvertedItemDls(1796, 100, peer);
											if (isValid) {
												RemoveInventoryItem(pMov->plantingTree, 1, peer, true);
												Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wYou shattered a `2Blue Gem Lock `winto 100 `2Diamond Lock`w!", 0, true);
												Player::OnConsoleMessage(peer, "`oYou shattered a `2Blue Gem Lock `ointo 100 `2Diamond Lock`o!");
											}
										}
									}
								}
								break;
							}
							ItemDefinition def;
							try {
								def = getItemDef(pMov->plantingTree);
							} catch (int e) {
								goto END_CLOTHSETTER_FORCE;
							}
							if (static_cast<PlayerInfo*>(peer->data)->Fishing) {
								Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`wYou cant do that while fishing`w!", 0, true);
								continue;
							}
							switch (def.clothType) {
							case 0:
								if (pMov->plantingTree >= 0)
								{
									if (!isDev(peer))
									{
										bool iscontainseas = false;
										SearchInventoryItem(peer, pMov->plantingTree, 1, iscontainseas);
										if (!iscontainseas)
										{
											break;
										}
									}
								}
								if (pMov->plantingTree == 4626)
								{
								}
								else if (pMov->plantingTree == 3462)
								{
								}
								if (static_cast<PlayerInfo*>(event.peer->data)->cloth0 == pMov->plantingTree)
								{
									Player::PlayAudio(peer, "audio/change_clothes.wav", 0);
									static_cast<PlayerInfo*>(event.peer->data)->cloth0 = 0;
									break;
								}
								Player::PlayAudio(peer, "audio/change_clothes.wav", 0);
								static_cast<PlayerInfo*>(event.peer->data)->cloth0 = pMov->plantingTree;
								break;
							case 1:
								if (pMov->plantingTree >= 0)
								{
									if (!isDev(peer))
									{
										bool iscontainseas = false;
										SearchInventoryItem(peer, pMov->plantingTree, 1, iscontainseas);
										if (!iscontainseas)
										{
											break;
										}
									}
								}
								if (static_cast<PlayerInfo*>(event.peer->data)->cloth1 == pMov->plantingTree)
								{
									Player::PlayAudio(peer, "audio/change_clothes.wav", 0);
									static_cast<PlayerInfo*>(event.peer->data)->cloth1 = 0;
									break;
								}
								Player::PlayAudio(peer, "audio/change_clothes.wav", 0);
								static_cast<PlayerInfo*>(event.peer->data)->cloth1 = pMov->plantingTree;
								break;
							case 2:
								if (pMov->plantingTree >= 0)
								{
									if (!isDev(peer))
									{
										bool iscontainseas = false;
										SearchInventoryItem(peer, pMov->plantingTree, 1, iscontainseas);
										if (!iscontainseas)
										{
											break;
										}
									}
								}
								if (static_cast<PlayerInfo*>(event.peer->data)->cloth2 == pMov->plantingTree)
								{
									Player::PlayAudio(peer, "audio/change_clothes.wav", 0);
									static_cast<PlayerInfo*>(event.peer->data)->cloth2 = 0;
									break;
								}
								if (pMov->plantingTree == 3172)
								{
									if (static_cast<PlayerInfo*>(peer->data)->SurgeryCooldown)
									{
										Player::OnTalkBubble(peer, static_cast<PlayerInfo*>(peer->data)->netID, "`2Your briefs have stunned the judge!", 0, true);
										RemoveInventoryItem(3172, 1, peer, true);
										Player::OnConsoleMessage(peer, "You've paid your debt to society! (`$Malpractice`` mod removed)");
										sendSound(peer, "audio/dialog_confirm.wav");
										static_cast<PlayerInfo*>(peer->data)->SurgeryCooldown = false;
										static_cast<PlayerInfo*>(peer->data)->SurgeryTime = 0;
									}
									if (!isDev(peer))
									{
										bool iscontainseas = false;
										SearchInventoryItem(peer, 3172, 1, iscontainseas);
										if (!iscontainseas) break;
									}
								}
								Player::PlayAudio(peer, "audio/change_clothes.wav", 0);
								static_cast<PlayerInfo*>(event.peer->data)->cloth2 = pMov->plantingTree;
								break;
							case 3:
								if (pMov->plantingTree >= 0)
								{
									if (!isDev(peer))
									{
										bool iscontainseas = false;
										SearchInventoryItem(peer, pMov->plantingTree, 1, iscontainseas);
										if (!iscontainseas)
										{
											break;
										}
									}
								}
								if (static_cast<PlayerInfo*>(event.peer->data)->cloth3 == pMov->plantingTree)
								{
									Player::PlayAudio(peer, "audio/change_clothes.wav", 0);
									static_cast<PlayerInfo*>(event.peer->data)->cloth3 = 0;
									send_state(peer);
									break;
								}
								if (pMov->plantingTree == 898 || pMov->plantingTree == 1830 || pMov->plantingTree == 1966)
								{
									playerconfig(peer, 1150, 130, 0x14);
								}
								if (pMov->plantingTree == 8834)
								{
								}
								Player::PlayAudio(peer, "audio/change_clothes.wav", 0);
								static_cast<PlayerInfo*>(event.peer->data)->cloth3 = pMov->plantingTree;
								break;
							case 4:
								if (pMov->plantingTree >= 0)
								{
									if (!isDev(peer))
									{
										bool iscontainseas = false;
										SearchInventoryItem(peer, pMov->plantingTree, 1, iscontainseas);
										if (!iscontainseas)
										{
											break;
										}
									}
								}
								if (static_cast<PlayerInfo*>(event.peer->data)->cloth4 == pMov->plantingTree)
								{
									static_cast<PlayerInfo*>(peer->data)->effect = 8421376;
									sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
									send_state(peer); //here
									Player::PlayAudio(peer, "audio/change_clothes.wav", 0);
									static_cast<PlayerInfo*>(event.peer->data)->cloth4 = 0;
									break;
								}
								if (pMov->plantingTree == 1204)
								{
									GamePacket p = packetEnd(appendString(appendString(createPacket(), "OnConsoleMessage"), "`oGive people the evil eye. (`oFocused eyes mod added`o)"));
									ENetPacket* packet = enet_packet_create(p.data,
										p.len,
										ENET_PACKET_FLAG_RELIABLE);
									enet_peer_send(peer, 0, packet);
									delete p.data;
									static_cast<PlayerInfo*>(peer->data)->effect = 8421386;
									sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
									send_state(peer); //here
								}
								Player::PlayAudio(peer, "audio/change_clothes.wav", 0);
								static_cast<PlayerInfo*>(event.peer->data)->cloth4 = pMov->plantingTree;
								break;
							case 5:
								if (pMov->plantingTree >= 0)
								{
									if (!isDev(peer))
									{
										bool iscontainseas = false;
										SearchInventoryItem(peer, pMov->plantingTree, 1, iscontainseas);
										if (!iscontainseas)
										{
											break;
										}
									}
								}
								else if (pMov->plantingTree == 2204)
								{
									srand(GetTickCount());
									int geigercounterx = rand() % 3000;
									int geigercountery = rand() % 1500;
									static_cast<PlayerInfo*>(peer->data)->geigerx = geigercounterx;
									static_cast<PlayerInfo*>(peer->data)->geigery = geigercountery;
								}
								else if (pMov->plantingTree == 1484) {
									static_cast<PlayerInfo*>(peer->data)->effect = 8421389;
									sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
									send_state(peer); //here
								}
								else if (pMov->plantingTree == 2592)
								{
									Player::OnConsoleMessage(peer, "`oNone can stand against you! (`oLegendary Swordsmaster mod added`o)");
									static_cast<PlayerInfo*>(peer->data)->effect = 8421399;
									sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
									send_state(peer); //here
								}
								else if (pMov->plantingTree == 6782)
								{
									Player::OnConsoleMessage(peer, "`oYou are feeling like `2Infinity `4Power `oStarts to go out of you!");
									static_cast<PlayerInfo*>(peer->data)->effect = 8421509;
									sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
									send_state(peer); //here
								}
								else if (pMov->plantingTree == 8452)
								{
									static_cast<PlayerInfo*>(peer->data)->effect = 8421412;
									sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
									send_state(peer); //here
								}
								else if (pMov->plantingTree == 5480)
								{
									Player::OnConsoleMessage(peer, "`oWho needs arms when you have these? (`oRayman fist! mod added`o)");
									static_cast<PlayerInfo*>(peer->data)->effect = 8421456;
									sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
									send_state(peer); //here
								}
								else if (pMov->plantingTree == 9410)
								{
									Player::OnConsoleMessage(peer, "`#Purple `9lights `ostarts to move around you! (`#Valentine! `omod added`o)");
									send_state(peer); //here
								}
								else if (pMov->plantingTree == 1782)
								{
									Player::OnConsoleMessage(peer, "`oYou should be very very nice to your pet. (`oLegendary! mod added`o)");
									static_cast<PlayerInfo*>(peer->data)->effect = 8421397;
									sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
									send_state(peer); //here
								}
								else if (pMov->plantingTree == 1868)
								{
									Player::OnConsoleMessage(peer, "`oYou command a mighty (violent) dragon! (`oDrakeborn mod added`o)");
									static_cast<PlayerInfo*>(peer->data)->effect = 8421399;
									sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
									send_state(peer); //here
								}
								else if (pMov->plantingTree == 1804)
								{
									Player::OnConsoleMessage(peer, "`oYou electrocute things. (`oFistful Of Thunder mod added`o)");
									static_cast<PlayerInfo*>(peer->data)->effect = 8421398;
									sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
									send_state(peer); //here
								}
								else if (pMov->plantingTree == 9058)
								{
									static_cast<PlayerInfo*>(peer->data)->effect = 8421512;
									sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
									send_state(peer); //here
								}
								else if (pMov->plantingTree == 9484)
								{
									static_cast<PlayerInfo*>(peer->data)->effect = 8421512;
									sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
									send_state(peer); //here
								}
								else if (pMov->plantingTree == 9486)
								{
									static_cast<PlayerInfo*>(peer->data)->effect = 8421512;
									sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
									send_state(peer); //here
								}
								else if (pMov->plantingTree == 7912)
								{
									static_cast<PlayerInfo*>(peer->data)->effect = 8421398;
									sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
									send_state(peer); //here
								}
								else if (pMov->plantingTree == 6026)
								{
									Player::OnConsoleMessage(peer, "`oThe truth is yours! (`oWhip of Truth mod added`o)");
									static_cast<PlayerInfo*>(peer->data)->effect = 8421452;
									sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
									send_state(peer); //here
								}
								if (static_cast<PlayerInfo*>(event.peer->data)->cloth5 == pMov->plantingTree)
								{
									static_cast<PlayerInfo*>(peer->data)->effect = 8421376;
									sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
									send_state(peer); //here
									Player::PlayAudio(peer, "audio/change_clothes.wav", 0);
									static_cast<PlayerInfo*>(event.peer->data)->cloth5 = 0;
									break;
								}
								if (pMov->plantingTree == 1782)
								{
									static_cast<PlayerInfo*>(peer->data)->effect = 8424213;
									sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
									send_state(peer); //here
								}
								else if (pMov->plantingTree == 1804)
								{
									static_cast<PlayerInfo*>(peer->data)->effect = 8424214;
									sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
									send_state(peer); //here
								}
								else if (pMov->plantingTree == 1868)
								{
									static_cast<PlayerInfo*>(peer->data)->effect = 8424215;
									sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
									send_state(peer); //here
								}
								else if (pMov->plantingTree == 2572)
								{
									static_cast<PlayerInfo*>(peer->data)->effect = 8424234;
									sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
									send_state(peer); //here
								}
								else if (pMov->plantingTree == 2756)
								{
									static_cast<PlayerInfo*>(peer->data)->effect = 8424239;
									sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
									send_state(peer); //here
								}
								else if (pMov->plantingTree == 6026)
								{
									static_cast<PlayerInfo*>(peer->data)->effect = 8421452;
									sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
									send_state(peer); //here
								}
								else if (pMov->plantingTree == 2872)
								{
									static_cast<PlayerInfo*>(peer->data)->effect = 8424243;
									sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
									send_state(peer); //here
								}
								else if (pMov->plantingTree == 2952 || pMov->plantingTree == 3932 || pMov->plantingTree == 9448 || pMov->plantingTree == 9452 || pMov->plantingTree == 9508 || pMov->plantingTree == 9454 || pMov->plantingTree == 9456 || pMov->plantingTree == 9458 || pMov->plantingTree == 9430)
								{
									static_cast<PlayerInfo*>(peer->data)->effect = 8424222;
									sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
									send_state(peer); //here
								}
								else if (pMov->plantingTree == 4996)
								{
									static_cast<PlayerInfo*>(peer->data)->effect = 8421453;
									sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
									send_state(peer); //here
								}
								else if (pMov->plantingTree == 3066)
								{
									static_cast<PlayerInfo*>(peer->data)->effect = 8421433;
									sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
									send_state(peer); //here
								}
								else if (pMov->plantingTree == 2592)
								{
									static_cast<PlayerInfo*>(peer->data)->effect = 8424235;
									sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
									send_state(peer); //here
								}
								else if (pMov->plantingTree == 9494)
								{
									static_cast<PlayerInfo*>(peer->data)->effect = 8421512;
									sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
									send_state(peer); //here
								}
								else if (pMov->plantingTree == 9502)
								{
									static_cast<PlayerInfo*>(peer->data)->effect = 8421512;
									sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
									send_state(peer); //here
								}
								else if (pMov->plantingTree == 2476)
								{
									static_cast<PlayerInfo*>(peer->data)->effect = 8424231;
									sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
									send_state(peer); //here
								}
								else if (pMov->plantingTree == 1874)
								{
									static_cast<PlayerInfo*>(peer->data)->effect = 8424216;
									sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
									send_state(peer); //here
								}
								else if (pMov->plantingTree == 1204)
								{
									static_cast<PlayerInfo*>(peer->data)->effect = 8421386;
									sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
									send_state(peer); //here
								}
								else if (pMov->plantingTree == 1956)
								{
									static_cast<PlayerInfo*>(peer->data)->effect = -997;
									sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
									send_state(peer); //here
								}
								else
								{
									static_cast<PlayerInfo*>(peer->data)->effect = 8421376;
									sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
									send_state(peer); //here
								}
								Player::PlayAudio(peer, "audio/change_clothes.wav", 0);
								static_cast<PlayerInfo*>(event.peer->data)->cloth5 = pMov->plantingTree;
								break;
							case 6:
								if (pMov->plantingTree >= 0)
								{
									if (!isDev(peer))
									{
										bool iscontainseas = false;
										SearchInventoryItem(peer, pMov->plantingTree, 1, iscontainseas);
										if (!iscontainseas)
										{
											break;
										}
									}
								}
								if (pMov->plantingTree == 1784)
								{
									Player::OnConsoleMessage(peer, "`oYou can jump in mid-air! It's like flying, but less. (`oDouble jump mod added`o)");
									static_cast<PlayerInfo*>(event.peer->data)->canDoubleJump = true;
									send_state(peer);
								}
								else if (pMov->plantingTree == 8552)
								{
									if (static_cast<PlayerInfo*>(peer->data)->cloth_back != 8552)
									{
										Player::OnConsoleMessage(peer, "`oHearts!. (`o`4Mercy `omod added`o)");
										static_cast<PlayerInfo*>(event.peer->data)->isDr = true;
										static_cast<PlayerInfo*>(event.peer->data)->canDoubleJump = true;
										static_cast<PlayerInfo*>(event.peer->data)->NickPrefix = "`4Dr";
										send_state(peer);
									}
									else
									{
										Player::OnConsoleMessage(peer, "`oUh oh!. (`o`4Mercy `omod removed`o)");
										static_cast<PlayerInfo*>(event.peer->data)->isDr = false;
										static_cast<PlayerInfo*>(event.peer->data)->canDoubleJump = false;
										static_cast<PlayerInfo*>(event.peer->data)->NickPrefix = "";
										send_state(peer);
									}
								}
								if (static_cast<PlayerInfo*>(event.peer->data)->cloth6 == pMov->plantingTree)
								{
									Player::PlayAudio(peer, "audio/change_clothes.wav", 0);
									static_cast<PlayerInfo*>(event.peer->data)->cloth6 = 0;
									static_cast<PlayerInfo*>(event.peer->data)->canDoubleJump = false;
									send_state(peer);
									break;
								}
								{
									if (pMov->plantingTree == 9006)
									{
										static_cast<PlayerInfo*>(peer->data)->peffect = 8420231;
										sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->peffect);
										send_state(peer);
									}
									else if (pMov->plantingTree == 900)
									{
										static_cast<PlayerInfo*>(peer->data)->peffect = 8421382;
										sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->peffect);
										send_state(peer);
									}
									else if (pMov->plantingTree == 7196)
									{
										static_cast<PlayerInfo*>(peer->data)->peffect = 8421471;
										sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->peffect);
										send_state(peer);
									}
									static_cast<PlayerInfo*>(event.peer->data)->cloth6 = pMov->plantingTree;
									int item = pMov->plantingTree;
									if (item == 10426 || item == 156 || item == 9006 || item == 1958 || getItemDef(item).name.find("Aura") != string::npos || item == 9476 || item == 9434 || getItemDef(item).name.find("Wings") != string::npos || getItemDef(item).name.find("Cape") != string::npos || item == 8580 || item == 10032 || item == 9410 || item == 9306 || item == 10022 || item == 8308 || item == 7834 || item == 10020 || item == 9760 || item == 10016 || item == 10012 || item == 1674 || item == 9478 || item == 9506 || item == 9476 || item == 1970 || item == 8286 || item == 9506 || item == 9478 || item == 8552 || item == 362 || item == 678 || item == 736 || item == 7734 || item == 7762 || item == 818 || item == 1206 || item == 1460 || item == 1550 || item == 1574 || item == 1668 || item == 1672 || item == 1674 || item == 1784 || item == 1824 || item == 1936 || item == 1938 || item == 1970 || item == 2254 || item == 2256 || item == 2258 || item == 2260 || item == 2262 || item == 2264 || item == 2390 || item == 2392 || item == 3120 || item == 3308 || item == 3512 || item == 4534 || item == 4986 || item == 5754 || item == 6144 || item == 6334 || item == 6694 || item == 6818 || item == 6842 || item == 1934 || item == 3134 || item == 6004 || item == 1780 || item == 2158 || item == 2160 || item == 2162 || item == 2164 || item == 2166 || item == 2168 || item == 2438 || item == 2538 || item == 2778 || item == 3858 || item == 350 || item == 998 || item == 1738 || item == 2642 || item == 2982 || item == 3104 || item == 3144 || item == 5738 || item == 3112 || item == 2722 || item == 3114 || item == 4970 || item == 4972 || item == 5020 || item == 6284 || item == 4184 || item == 4628 || item == 5322 || item == 4112 || item == 4114 || item == 3442 || item == 9466 || item == 8286 || item == 5136 || item == 9416 || item == 9356) {
										if (item == 10418 || item == 10420) {
											Player::OnConsoleMessage(peer, "`oYou can fly in air! It's like double jumping, but more. (`oFlying mod added`o)");
										} else {
											Player::OnConsoleMessage(peer, "`oYou can jump in mid-air! It's like flying, but less. (`oDouble jump mod added`o)");
										}
										if (item == 10424) {
											/*GamePacket pp = packetEnd(appendInt(appendInt(appendInt(appendInt(appendInt(appendInt(appendString(createPacket(), "OnRiftCape"), 2555), 2402849791), 723421695), 2402849791), 1059267327), 30));
											ENetPacket* packetpp = enet_packet_create(pp.data, pp.len, ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packetpp);
											delete pp.data;
											GamePacket p33 = packetEnd(appendInt(appendInt(appendInt(appendString(createPacket(), "OnSetRoleSkinsAndTitles"), 6), 6), 0));
											ENetPacket* packet33 = enet_packet_create(p33.data, p33.len, ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet33);
											delete p33.data;
											const auto p3 = packetEnd(appendFloat(appendIntx(appendFloat(appendFloat(appendFloat(appendString(createPacket(), "OnSetClothing"), (static_cast<PlayerInfo*>(peer->data))->cloth_hair, (static_cast<PlayerInfo*>(peer->data))->cloth_shirt, (static_cast<PlayerInfo*>(peer->data))->cloth_pants), (static_cast<PlayerInfo*>(peer->data))->cloth_feet, (static_cast<PlayerInfo*>(peer->data))->cloth_face, (static_cast<PlayerInfo*>(peer->data))->cloth_hand), (static_cast<PlayerInfo*>(peer->data))->cloth_back, (static_cast<PlayerInfo*>(peer->data))->cloth_mask, (static_cast<PlayerInfo*>(peer->data))->cloth_necklace), (static_cast<PlayerInfo*>(peer->data))->skinColor), (static_cast<PlayerInfo*>(peer->data))->cloth_ances, 0.0f, 0.0f));
											memcpy(p3.data + 8, &((static_cast<PlayerInfo*>(peer->data))->netID), 4);
											const auto packet = enet_packet_create(p3.data, p3.len, ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet);
											GamePacket p30 = packetEnd(appendInt(appendString(createPacket(), "OnFlagMay2019"), 256));
											ENetPacket* packet332 = enet_packet_create(p30.data, p30.len, ENET_PACKET_FLAG_RELIABLE);
											enet_peer_send(peer, 0, packet332);
											delete p30.data;*/
										}
										static_cast<PlayerInfo*>(event.peer->data)->canDoubleJump = true;
									}
									else
									{
										static_cast<PlayerInfo*>(event.peer->data)->canDoubleJump = false;
									}
									// ^^^^ wings
									send_state(peer);
								}
								Player::PlayAudio(peer, "audio/change_clothes.wav", 0);
								break;
							case 7:
								if (pMov->plantingTree >= 0)
								{
									if (!isDev(peer))
									{
										bool iscontainseas = false;
										SearchInventoryItem(peer, pMov->plantingTree, 1, iscontainseas);
										if (!iscontainseas)
										{
											break;
										}
									}
								}
								if (static_cast<PlayerInfo*>(event.peer->data)->cloth7 == pMov->plantingTree)
								{
									Player::PlayAudio(peer, "audio/change_clothes.wav", 0);
									static_cast<PlayerInfo*>(event.peer->data)->cloth7 = 0;
									break;
								}
								Player::PlayAudio(peer, "audio/change_clothes.wav", 0);
								static_cast<PlayerInfo*>(event.peer->data)->cloth7 = pMov->plantingTree;
								break;
							case 8:
								if (pMov->plantingTree >= 0)
								{
									if (!isDev(peer))
									{
										bool iscontainseas = false;
										SearchInventoryItem(peer, pMov->plantingTree, 1, iscontainseas);
										if (!iscontainseas)
										{
											break;
										}
									}
								}
								if (static_cast<PlayerInfo*>(event.peer->data)->cloth8 == pMov->plantingTree)
								{
									Player::PlayAudio(peer, "audio/change_clothes.wav", 0);
									static_cast<PlayerInfo*>(event.peer->data)->cloth8 = 0;
									break;
								}
								if (pMov->plantingTree == 9512)
								{
									static_cast<PlayerInfo*>(peer->data)->effect = 8421416;
									sendPuncheffect(peer, static_cast<PlayerInfo*>(peer->data)->effect);
									send_state(peer); //here
								}
								Player::PlayAudio(peer, "audio/change_clothes.wav", 0);
								static_cast<PlayerInfo*>(event.peer->data)->cloth8 = pMov->plantingTree;
								break;
							default:
								if (def.id == 7166 || def.id == 5078 || def.id == 5080 || def.id == 5082 || def.id == 5084 || def.id == 5134 || def.id == 5126 || def.id == 5128 || def.id == 5130 || def.id == 5132 || def.id == 5152 || def.id == 5144 || def.id == 5146 || def.id == 5148 || def.id == 5150 || def.id == 5170 || def.id == 5162 || def.id == 5164 || def.id == 5166 || def.id == 5168 || def.id == 5188 || def.id == 5180 || def.id == 5182 || def.id == 5184 || def.id == 5186 || def.id == 9212 || def.id == 7168 || def.id == 7170 || def.id == 7172 || def.id == 7174) {
									if (static_cast<PlayerInfo*>(event.peer->data)->cloth_ances == pMov->plantingTree) {
										Player::PlayAudio(peer, "audio/change_clothes.wav", 0);
										static_cast<PlayerInfo*>(event.peer->data)->cloth_ances = 0;
										break;
									}
									static_cast<PlayerInfo*>(event.peer->data)->cloth_ances = pMov->plantingTree;
								}
								Player::PlayAudio(peer, "audio/change_clothes.wav", 0);
								break;
							}
							sendClothes(peer);
						END_CLOTHSETTER_FORCE:;
							break;
						}
						case 18:
						{
							sendPData(peer, pMov);
							break;
						}
						default:
							break;
						}
						if (data2->punchX != -1 && data2->punchY != -1) {
							if (data2->packetType == 3) {
								if (static_cast<PlayerInfo*>(peer->data)->currentWorld == "EXIT") continue;
								if (static_cast<PlayerInfo*>(event.peer->data)->isRotatedLeft = pMov->characterState & 0x10) {
									static_cast<PlayerInfo*>(event.peer->data)->RotatedLeft = true;
								} else {
									static_cast<PlayerInfo*>(event.peer->data)->RotatedLeft = false;
								}
								using namespace std::chrono;
								if (static_cast<PlayerInfo*>(peer->data)->lastBREAK + 150 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
									static_cast<PlayerInfo*>(peer->data)->lastBREAK = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
									if (data2->plantingTree == 18) {
										if (static_cast<PlayerInfo*>(event.peer->data)->cloth_hand == 5480) {
											if (static_cast<PlayerInfo*>(event.peer->data)->cloth_face != 4288 && static_cast<PlayerInfo*>(event.peer->data)->isZombie == false) {
												if (static_cast<PlayerInfo*>(event.peer->data)->isRotatedLeft = pMov->characterState & 0x10) {
													static_cast<PlayerInfo*>(event.peer->data)->RotatedLeft = true;
												} else {
													static_cast<PlayerInfo*>(event.peer->data)->RotatedLeft = false;
												} if (data2->punchY == static_cast<PlayerInfo*>(event.peer->data)->y / 32) {
													if (static_cast<PlayerInfo*>(event.peer->data)->RotatedLeft == true) {
														sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer, world);
														sendTileUpdate(data2->punchX - 1, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer, world);
														sendTileUpdate(data2->punchX - 2, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer, world);
													} else {
														sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer, world);
														sendTileUpdate(data2->punchX + 1, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer, world);
														sendTileUpdate(data2->punchX + 2, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer, world);
													}
												} else if (data2->punchX == static_cast<PlayerInfo*>(event.peer->data)->x / 32) {
													if (data2->punchY > static_cast<PlayerInfo*>(event.peer->data)->y / 32) {
														sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer, world);
														sendTileUpdate(data2->punchX, data2->punchY + 1, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer, world);
														sendTileUpdate(data2->punchX, data2->punchY + 2, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer, world);
													} else if (data2->punchY < static_cast<PlayerInfo*>(event.peer->data)->y / 32) {
														sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer, world);
														sendTileUpdate(data2->punchX, data2->punchY - 1, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer, world);
														sendTileUpdate(data2->punchX, data2->punchY - 2, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer, world);
													} else {
														sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer, world);
													}
												} else if (data2->punchY < static_cast<PlayerInfo*>(event.peer->data)->y / 32) {
													if (static_cast<PlayerInfo*>(event.peer->data)->RotatedLeft == true) {
														sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer, world);
														sendTileUpdate(data2->punchX - 1, data2->punchY - 1, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer, world);
														sendTileUpdate(data2->punchX - 2, data2->punchY - 2, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer, world);
													} else {
														sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer, world);
														sendTileUpdate(data2->punchX + 1, data2->punchY - 1, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer, world);
														sendTileUpdate(data2->punchX + 2, data2->punchY - 2, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer, world);
													}
												} else if (data2->punchY < static_cast<PlayerInfo*>(event.peer->data)->y / 32) {
													if (static_cast<PlayerInfo*>(event.peer->data)->RotatedLeft == true) {
														sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer, world);
														sendTileUpdate(data2->punchX - 1, data2->punchY - 1, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer, world);
														sendTileUpdate(data2->punchX - 2, data2->punchY - 2, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer, world);
													} else {
														sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer, world);
														sendTileUpdate(data2->punchX + 1, data2->punchY - 1, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer, world);
														sendTileUpdate(data2->punchX + 2, data2->punchY - 2, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer, world);
													}
												} else if (data2->punchY > static_cast<PlayerInfo*>(event.peer->data)->y / 32) {
													if (static_cast<PlayerInfo*>(event.peer->data)->RotatedLeft == true) {
														sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer, world);
														sendTileUpdate(data2->punchX - 1, data2->punchY + 1, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer, world);
														sendTileUpdate(data2->punchX - 2, data2->punchY + 2, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer, world);
													} else {
														sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer, world);
														sendTileUpdate(data2->punchX + 1, data2->punchY + 1, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer, world);
														sendTileUpdate(data2->punchX + 2, data2->punchY + 2, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer, world);
													}
												}
											} else {
												sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer, world);
											}
										} else {
											sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, static_cast<PlayerInfo*>(event.peer->data)->netID, peer, world);
										}
									} else {
										if (static_cast<PlayerInfo*>(event.peer->data)->PlacePotion || static_cast<PlayerInfo*>(peer->data)->cloth_necklace == 6260) {
											if ((static_cast<PlayerInfo*>(event.peer->data))->isRotatedLeft = pMov->characterState & 0x10) {
												(static_cast<PlayerInfo*>(event.peer->data))->RotatedLeft = true;
											} else {
												(static_cast<PlayerInfo*>(event.peer->data))->RotatedLeft = false;
											} if ((static_cast<PlayerInfo*>(event.peer->data))->RotatedLeft == true) {
												sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, (static_cast<PlayerInfo*>(event.peer->data))->netID, peer, world);
												sendTileUpdate(data2->punchX - 1, data2->punchY, data2->plantingTree, (static_cast<PlayerInfo*>(event.peer->data))->netID, peer, world);
												sendTileUpdate(data2->punchX - 2, data2->punchY, data2->plantingTree, (static_cast<PlayerInfo*>(event.peer->data))->netID, peer, world);
											} else {
												sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, (static_cast<PlayerInfo*>(event.peer->data))->netID, peer, world);
												sendTileUpdate(data2->punchX + 1, data2->punchY, data2->plantingTree, (static_cast<PlayerInfo*>(event.peer->data))->netID, peer, world);
												sendTileUpdate(data2->punchX + 2, data2->punchY, data2->plantingTree, (static_cast<PlayerInfo*>(event.peer->data))->netID, peer, world);
											}
										} else {
											sendTileUpdate(data2->punchX, data2->punchY, data2->plantingTree, (static_cast<PlayerInfo*>(event.peer->data))->netID, peer, world);
										}
									}
								}
							}
						}
						delete data2;
						delete pMov;
					} else {
						SendConsole("Bad Tank Packet received!", "ERROR");
					}
				}
				break;
					case 5:
					{
						break;
					}
					case 6:
					{
						break;
					}
				}
				enet_packet_destroy(event.packet);
				break;
			}
			case ENET_EVENT_TYPE_DISCONNECT:
			{
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
					string name = static_cast<PlayerInfo*>(currentPeer->data)->rawName;
					if (find(static_cast<PlayerInfo*>(peer->data)->friendinfo.begin(), static_cast<PlayerInfo*>(peer->data)->friendinfo.end(), name) != static_cast<PlayerInfo*>(peer->data)->friendinfo.end()) {
						Player::PlayAudio(currentPeer, "audio/friend_logoff.wav", 0);
						Player::OnConsoleMessage(currentPeer, "`!FRIEND ALERT : `w" + static_cast<PlayerInfo*>(peer->data)->displayName + " `ohas `4logged off`o.");
					}
				}
				if ((static_cast<PlayerInfo*>(peer->data))->haveGrowId) {	
					string worlds_owned = "";
					for (int i = 0; i < static_cast<PlayerInfo*>(peer->data)->worldsowned.size(); i++) {
						worlds_owned += static_cast<PlayerInfo*>(peer->data)->worldsowned[i] + ",";
					}
					string isGhost = "false";
					if (static_cast<PlayerInfo*>(peer->data)->canWalkInBlocks) isGhost = "true";
					string q = "UPDATE PlayerDatabase SET ClothBack = '" + to_string(static_cast<PlayerInfo*>(peer->data)->cloth_back) + "', ClothHand = '" + to_string(static_cast<PlayerInfo*>(peer->data)->cloth_hand) + "', ClothFace = '" + to_string(static_cast<PlayerInfo*>(peer->data)->cloth_face) + "', ClothShirt = '" + to_string(static_cast<PlayerInfo*>(peer->data)->cloth_shirt) + "', ClothPants = '" + to_string(static_cast<PlayerInfo*>(peer->data)->cloth_pants) + "', ClothNeck = '" + to_string(static_cast<PlayerInfo*>(peer->data)->cloth_necklace) + "', ClothHair = '" + to_string(static_cast<PlayerInfo*>(peer->data)->cloth_hair) + "', ClothFeet = '" + to_string(static_cast<PlayerInfo*>(peer->data)->cloth_feet) + "', ClothMask = '" + to_string(static_cast<PlayerInfo*>(peer->data)->cloth_mask) + "', ClothAnces = '" + to_string(static_cast<PlayerInfo*>(peer->data)->cloth_ances) + "', effect='" + to_string(static_cast<PlayerInfo*>(peer->data)->effect) + "', worldsowned = '" + worlds_owned + "', surgeonlevel = '" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgerySkill) + "', skin = '" + to_string(static_cast<PlayerInfo*>(peer->data)->skinColor) + "', lastworld = '" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "', surgerycooldown = '" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgeryTime) + "', lastnormalworld = '" + static_cast<PlayerInfo*>(peer->data)->lastnormalworld + "', xp = '" + to_string(static_cast<PlayerInfo*>(peer->data)->xp) + "', firefighterlevel='" + to_string(static_cast<PlayerInfo*>(peer->data)->firefighterlevel) + "', firefighterxp='" + to_string(static_cast<PlayerInfo*>(peer->data)->firefighterxp) + "', providerlevel='" + to_string(static_cast<PlayerInfo*>(peer->data)->providerlevel) + "', providerxp='" + to_string(static_cast<PlayerInfo*>(peer->data)->providerxp) + "', level = '" + to_string(static_cast<PlayerInfo*>(peer->data)->level) + "', geigercooldown = '" + to_string(static_cast<PlayerInfo*>(peer->data)->GeigerTime) + "', geigerlevel='" + to_string(static_cast<PlayerInfo*>(peer->data)->geigerlevel) + "', geigerxp='" + to_string(static_cast<PlayerInfo*>(peer->data)->geigerxp) + "', fishermanlevel='" + to_string(static_cast<PlayerInfo*>(peer->data)->fishermanlevel) + "', fishermanxp='" + to_string(static_cast<PlayerInfo*>(peer->data)->fishermanxp) + "', ghost='" + isGhost + "' WHERE username = '" + static_cast<PlayerInfo*>(peer->data)->rawName + "' LIMIT 1";
					json items;
					if (static_cast<PlayerInfo*>(peer->data)->needsaveinventory) {
						auto jjall = json::array();
						json jj;
						for (int i = 0; i < 200; i++) {
							if (i < static_cast<PlayerInfo*>(peer->data)->inventory.items.size()) {
								jj["aposition"] = i + 1;
								jj["itemid"] = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemID;
								jj["quantity"] = static_cast<PlayerInfo*>(peer->data)->inventory.items.at(i).itemCount;
								jjall.push_back(jj);
							} else {
								jj["aposition"] = i + 1;
								jj["itemid"] = 0;
								jj["quantity"] = 0;
								jjall.push_back(jj);
							}
						}
						items["items"] = jjall;
						q = "UPDATE PlayerDatabase SET ClothBack = '" + to_string(static_cast<PlayerInfo*>(peer->data)->cloth_back) + "', ClothHand = '" + to_string(static_cast<PlayerInfo*>(peer->data)->cloth_hand) + "', ClothFace = '" + to_string(static_cast<PlayerInfo*>(peer->data)->cloth_face) + "', ClothShirt = '" + to_string(static_cast<PlayerInfo*>(peer->data)->cloth_shirt) + "', ClothPants = '" + to_string(static_cast<PlayerInfo*>(peer->data)->cloth_pants) + "', ClothNeck = '" + to_string(static_cast<PlayerInfo*>(peer->data)->cloth_necklace) + "', ClothHair = '" + to_string(static_cast<PlayerInfo*>(peer->data)->cloth_hair) + "', ClothFeet = '" + to_string(static_cast<PlayerInfo*>(peer->data)->cloth_feet) + "', ClothMask = '" + to_string(static_cast<PlayerInfo*>(peer->data)->cloth_mask) + "', ClothAnces = '" + to_string(static_cast<PlayerInfo*>(peer->data)->cloth_ances) + "', effect='" + to_string(static_cast<PlayerInfo*>(peer->data)->effect) + "', worldsowned = '" + worlds_owned + "', surgeonlevel = '" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgerySkill) + "', skin = '" + to_string(static_cast<PlayerInfo*>(peer->data)->skinColor) + "', lastworld = '" + static_cast<PlayerInfo*>(peer->data)->currentWorld + "', surgerycooldown = '" + to_string(static_cast<PlayerInfo*>(peer->data)->SurgeryTime) + "', lastnormalworld = '" + static_cast<PlayerInfo*>(peer->data)->lastnormalworld + "', xp = '" + to_string(static_cast<PlayerInfo*>(peer->data)->xp) + "', inventory = '" + JsonToString(items) + "', firefighterlevel='" + to_string(static_cast<PlayerInfo*>(peer->data)->firefighterlevel) + "', firefighterxp='" + to_string(static_cast<PlayerInfo*>(peer->data)->firefighterxp) + "', providerlevel='" + to_string(static_cast<PlayerInfo*>(peer->data)->providerlevel) + "', providerxp='" + to_string(static_cast<PlayerInfo*>(peer->data)->providerxp) + "', level = '" + to_string(static_cast<PlayerInfo*>(peer->data)->level) + "', geigercooldown = '" + to_string(static_cast<PlayerInfo*>(peer->data)->GeigerTime) + "', geigerlevel='" + to_string(static_cast<PlayerInfo*>(peer->data)->geigerlevel) + "', geigerxp='" + to_string(static_cast<PlayerInfo*>(peer->data)->geigerxp) + "', fishermanlevel='" + to_string(static_cast<PlayerInfo*>(peer->data)->fishermanlevel) + "', fishermanxp='" + to_string(static_cast<PlayerInfo*>(peer->data)->fishermanxp) + "', ghost='" + isGhost + "' WHERE username = '" + static_cast<PlayerInfo*>(peer->data)->rawName + "' LIMIT 1";
						static_cast<PlayerInfo*>(peer->data)->needsaveinventory = false;
					}
					string visited = "";
					for (auto i = 0; i < static_cast<PlayerInfo*>(peer->data)->lastworlds.size(); i++) {
						visited += static_cast<PlayerInfo*>(peer->data)->lastworlds[i] + "|";
					}
					ofstream of("lastvisitedworlds/" + static_cast<PlayerInfo*>(peer->data)->rawName + ".txt");
					of << visited;
					of.close();
					if (static_cast<PlayerInfo*>(peer->data)->PerformingSurgery) end_surgery(peer, true);
					if (mysql_query(conn, q.c_str())) {
						cout << mysql_error(conn) << endl;				
						continue;
					}

				}
				sendPlayerLeave(peer);
				static_cast<PlayerInfo*>(event.peer->data)->inventory.items.clear();
			}
			default: 
				{
					break;
				}
			}
			ENetPeer* currentPeer;
			for (currentPeer = server->peers;
				currentPeer < &server->peers[server->peerCount];
				++currentPeer)
			{
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
				PlayerInfo* pinf = static_cast<PlayerInfo*>(currentPeer->data);
				PlayerBuff(currentPeer, pinf->x, pinf->y);
			}
		}
	}
	//while (1);
	//return 0;
};
